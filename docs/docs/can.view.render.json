c({"type": "function", "name": "can.view.render", "parent": "can.view", "body": "<p><code>can.view.render(view, [data], [helpers], callback)</code> returns the rendered markup produced by the corresponding template\nengine as String. If you pass a deferred object in as data, render returns\na deferred resolving to the rendered markup.</p>\n\n<p><code>can.view.render</code> is commonly used for sub-templates.</p>\n\n<h2>Example</h2>\n\n<p><em>welcome.ejs</em> looks like:</p>\n\n<pre><code>&lt;h1&gt;Hello &lt;%= hello %&gt;&lt;/h1&gt;\n</code></pre>\n\n<p>Render it to a string like:</p>\n\n<pre><code>can.view.render(\"welcome.ejs\",{hello: \"world\"})\n  //-&gt; &lt;h1&gt;Hello world&lt;/h1&gt;\n</code></pre>\n\n<h2>Use as a Subtemplate</h2>\n\n<p>If you have a template like:</p>\n\n<pre><code>&lt;ul&gt;\n  &lt;% list(items, function(item){ %&gt;\n    &lt;%== can.view.render(\"item.ejs\",item) %&gt;\n  &lt;% }) %&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<h2>Using renderer functions</h2>\n\n<p>If you only pass the view path, `can.view will return a renderer function that can be called with\nthe data to render:</p>\n\n<pre><code>var renderer = can.view.render(\"welcome.ejs\");\n// Do some more things\nrenderer({hello: \"world\"}) // -&gt; Document Fragment\n</code></pre>", "description": "<p>Render a template. </p>", "title": "", "signatures": [{"code": "can.view.render(template[, callback])", "description": "", "params": [{"types": [{"type": "String"}, {"type": "Object"}], "name": "view", "description": "<p>The path of the view template or a view object.</p>"}, {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}], "optional": true, "name": "callback", "description": "<p>A function executed after the template has been processed.</p>"}], "returns": {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}, {"type": "can.Deferred"}], "description": "<p>A renderer function to be called with data and helpers\nor a Deferred that resolves to a renderer function.</p>"}}, {"code": "can.view.render(template, data[, [helpers,] callback])", "description": "", "params": [{"types": [{"type": "String"}, {"type": "Object"}], "name": "view", "description": "<p>The path of the view template or a view object.</p>"}, {"types": [{"type": "Object"}], "optional": true, "name": "data", "description": "<p>The data to populate the template with.</p>"}, {"types": [{"type": "Object", "template": [{"types": [{"type": "String"}]}, {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}]}]}], "optional": true, "name": "helpers", "description": "<p>Helper methods referenced in the template.</p>"}, {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}], "optional": true, "name": "callback", "description": "<p>A function executed after the template has been processed.</p>"}], "returns": {"types": [{"type": "String"}, {"type": "can.Deferred"}], "description": "<p>The template with interpolated data in string form\nor a Deferred that resolves to the template with interpolated data.</p>"}}], "comment": " ", "src": "can/view/view.js", "line": 295})