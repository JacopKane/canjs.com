c({"type": "function", "name": "static.Y.cached", "params": [{"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}], "name": "source", "description": "<p>The function to memoize.</p>"}, {"types": [{"type": "Object"}], "optional": true, "name": "cache", "defaultValue": "{", "description": "<p>Object in which to store cached values. You may seed\nthis object with pre-existing cached values if desired.</p>"}, {"types": [{"type": "any"}], "optional": true, "name": "refetch", "description": "<p>If supplied, this value is compared with the cached value\nusing a <code>==</code> comparison. If the values are equal, the wrapped function is\nexecuted again even though a cached value exists.</p>"}], "parent": "static", "body": "", "description": "<p>Returns a wrapper for a function which caches the return value of that function,\nkeyed off of the combined string representation of the argument values provided\nwhen the wrapper is called.</p>\n\n<p>Calling this function again with the same arguments will return the cached value\nrather than executing the wrapped function.</p>\n\n<p>Note that since the cache is keyed off of the string representation of arguments\npassed to the wrapper function, arguments that aren't strings and don't provide\na meaningful <code>toString()</code> method may result in unexpected caching behavior. For\nexample, the objects <code>{}</code> and <code>{foo: 'bar'}</code> would both be converted to the\nstring <code>[object Object]</code> when used as a cache key.</p>", "comment": "undefined@method cached\n@for YUI\n", "returns": {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}], "description": "<p>Wrapped function.</p>"}, "src": "can/lib/yui-3.7.3.js", "line": 2674})