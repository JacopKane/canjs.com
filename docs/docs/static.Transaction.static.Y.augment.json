c({"type": "function", "name": "static.Transaction.static.Y.augment", "params": [{"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}, {"type": "Object"}], "name": "receiver", "description": "<p>Object or function to be augmented.</p>"}, {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}], "name": "supplier", "description": "<p>Function that supplies the prototype properties with\nwhich to augment the <em>receiver</em>.</p>"}, {"types": [{"type": "Boolean"}], "optional": true, "name": "overwrite", "defaultValue": "false", "description": "<p>If <code>true</code>, properties already on the receiver\nwill be overwritten if found on the supplier's prototype.</p>"}, {"types": [{"type": "String"}, {"type": "["}], "optional": true, "name": "whitelist", "description": "<p>An array of property names. If specified,\nonly the whitelisted prototype properties will be applied to the receiver, and\nall others will be ignored.</p>"}, {"types": [{"type": "Array"}, {"type": "any"}], "optional": true, "name": "args", "description": "<p>Argument or array of arguments to pass to the\nsupplier's constructor when initializing.</p>"}], "parent": "static.Transaction.static", "body": "", "description": "<p>Augments the <em>receiver</em> with prototype properties from the <em>supplier</em>. The\nreceiver may be a constructor function or an object. The supplier must be a\nconstructor function.</p>\n\n<p>If the <em>receiver</em> is an object, then the <em>supplier</em> constructor will be called\nimmediately after <em>receiver</em> is augmented, with <em>receiver</em> as the <code>this</code> object.</p>\n\n<p>If the <em>receiver</em> is a constructor function, then all prototype methods of\n<em>supplier</em> that are copied to <em>receiver</em> will be sequestered, and the\n<em>supplier</em> constructor will not be called immediately. The first time any\nsequestered method is called on the <em>receiver</em>'s prototype, all sequestered\nmethods will be immediately copied to the <em>receiver</em>'s prototype, the\n<em>supplier</em>'s constructor will be executed, and finally the newly unsequestered\nmethod that was called will be executed.</p>\n\n<p>This sequestering logic sounds like a bunch of complicated voodoo, but it makes\nit cheap to perform frequent augmentation by ensuring that suppliers'\nconstructors are only called if a supplied method is actually used. If none of\nthe supplied methods is ever used, then there's no need to take the performance\nhit of calling the <em>supplier</em>'s constructor.</p>", "comment": "undefined@method augment\n@for YUI\n", "returns": {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}], "description": "<p>Augmented object.</p>"}, "src": "can/lib/yui-3.7.3.js", "line": 5773})