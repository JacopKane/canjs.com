c({"type": "page", "name": "attributes", "body": "<div class='demo_wrapper' data-demo-src='can/observe/attributes/attributes.html'></div><div class='demo_wrapper' data-demo-src='can/observe/attributes/attributes-assocations.html'></div>", "description": "<p>can.Observe.attributes is a plugin that helps convert and normalize data being set on an Observe\nand allows you to specify the way complex types get serialized. The attributes plugin is most\nhelpful when used with [can.Model] (because the serialization aids in sending data to a server),\nbut you can use it with any Observe you plan to make instances\nfrom.</p>\n\n<p>There are three important static properties to give the class you want to use attributes with:\n- <code>[can.Observe.attributes.attributes attributes]</code> lists the properties that will be normalized\nand the types those properties should be.\n- <code>[can.Observe.attributes.convert convert]</code> lists how to convert and normalize arbitrary values\nto the types this class uses.\n- <code>[can.Observe.attributes.serialize serialize]</code> lists serialization algorithms for the types\nthis class uses.</p>\n\n<p>Together, the functions in <em>convert</em> and <em>serialize</em> make up the type definitions for the class.\nThe attributes plugin comes with three useful predefined types: <code>'date'</code>, <code>'number'</code>, and <code>'boolean'</code>.</p>\n\n<p>Here is a quick example of an Observe-based class using the attributes plugin to convert and normalize\nits data, and then to serialize the instance:</p>\n\n<pre>can.Observe('Bio', {\n    attributes: {\n        birthday: 'date',\n        weight: 'number'\n    }\n    // Bio only uses built-in types, so no\n    // need to specify serialize or convert.\n}, {});\n\nvar alice = new Bio({\n    birthday: Date.parse('1985-04-01'), // 481161600000\n    weight: '120'\n});\n\nalice.attr();      // { birthday: Date(481161600000), weight: 120 }\nalice.serialize(); // { birthday: 481161600000, weight: 120 }\n</pre>\n\n<h3>Demo</h3>\n\n<p>When a user enters a new date in the format of <em>YYYY-DD-MM</em>, the control \nlistens for changes in the input box and updates the Observable using \nthe <code>attr</code> method which then converts the string into a JavaScript date object.  </p>\n\n<p>Additionally, the control also listens for changes on the Observable and \nupdates the age in the page for the new birthdate of the contact.</p>\n\n<h3>Reference types</h3>\n\n<p>Types listed in <code>attributes</code> can also be a functions, such as the <code>model</code> or\n<code>models</code> methods of a [can.Model]. When data of this kind of type is set, this\nfunction is used to convert the raw data into an instance of the Model.</p>\n\n<p>This example builds on the previous one to demonstrate these reference types.</p>\n\n<p>can.Observe('Bio', {\n    attributes: {\n        birthday: 'date',\n        weight: 'number'\n    }\n    // Contact only uses built-in types, so you don't have\n    // to specify serialize or convert.\n}, {});</p>\n\n<p>can.Observe('Contact', {\n  attributes: {\n    bio: 'Bio.newInstance'\n  }\n}, {});</p>\n\n<p>var alice = new Contact({\n  first: 'Alice',\n  last: 'Liddell',\n  bio: {\n    birthday: Date.parse('1985-04-01'), // 481161600000\n    weight: 120\n  }\n});</p>\n\n<p>The Attributes plugin provides functionality for converting data attributes from raw types and \nserializing complex types for the server.</p>\n\n<p>Below is an example code of an Observe providing serialization and conversion for dates and numbers.  </p>\n\n<p>When <code>Contact</code> is initialized, the <code>weight</code> attribute is set and converted to a <code>number</code> using the\nconverter we provided.  Next the <code>birthday</code> attribute is set using the <code>attr</code> method and gets converted\nas well.  Lastly, <code>serialize</code> is invoked converting the new attributes to raw types for the server.</p>\n\n<pre><code>var Contact = new can.Observe({\n    attributes: {\n        birthday: 'date'\n        weight: 'number'\n    },\n    serialize : {\n        date : function( val, type ){\n            // returns the string formatted as 'YYYY-DD-MM'\n            return val.getYear() + \n                    \"-\" + (val.getMonth() + 1) + \n                    \"-\" + val.getDate(); \n        },\n        number: (val){\n            return val + '';\n        }\n    },\n    convert: {\n        // converts string to date\n        date: function( date ) {\n            if ( typeof date == 'string' ) {\n                //- Extracts dates formated 'YYYY-DD-MM'\n                var matches = raw.match( /(\\d+)-(\\d+)-(\\d+)/ ); \n\n                //- Parses to date object and returns\n                date = new Date( matches[ 1 ],\n                        ( +matches[ 2 ] ) - 1, \n                        matches[ 3 ] ); \n            }\n\n            return date;\n        },\n\n        // converts string to number\n        number: function(number){\n            if(typeof number === 'string'){\n                number = parseInt(number);\n            }\n            return number;\n        }\n    }\n}, {});\n\nvar brian = new Contact({\n    weight: '300'\n});\n\nvar weight = brian.attr('weight'); //-&gt; 300\n\n//- sets brian's birthday\nbrian.attr('birthday', '11-29-1983');\n\nvar date = brian.attr('birthday'); //-&gt; Date()\n\nvar seralizedObj = brian.serialize();\n//-&gt; { 'birthday': '11-29-1983', 'weight': '300' }\n</code></pre>\n\n<h2>Associations</h2>\n\n<p>Attribute type values can also represent the name of a function. The most common case this is used is for associated data.</p>\n\n<p>For example, a <code>Deliverable</code> might have many tasks and an owner (which is a Person). The attributes property might look like:</p>\n\n<pre><code>var Deliverable = new can.Observe({\n    attributes : {\n        tasks : \"App.Models.Task.models\"\n        owner: \"App.Models.Person.model\"\n    }\n});\n</code></pre>\n\n<p>This points tasks and owner properties to use <em>Task</em> and <em>Person</em> to convert the raw data into an array of Tasks and a Person.</p>\n\n<p>Its important to note that the full names of the models themselves are <em>App.Models.Task</em> and <em>App.Models.Person</em>. The <code>.model</code> \nand <code>.models</code> parts are appended for the benefit of convert to identify the types as models.</p>\n\n<h3>Demo</h3>\n\n<p>Below is a demo that showcases associations between 2 different models to show the tasks\nfor each contact and how much time they have left to complete the task(s) using converters.</p>", "parent": "can.Observe", "plugin": "can/observe/attributes", "test": "can/observe/attributes/qunit.html", "download": "http://donejs.com/can/dist/can.observe.attributes.js", "src": "can/observe/attributes/attributes.md"})