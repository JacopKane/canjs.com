c({"type": "function", "name": "can.Construct.prototype.proxy", "body": "", "description": "<p>can.Construct.proxy is a plugin that helps you manage scope when creating\ncallback functions by ensuring that <code>this</code> is set correctly and sensibly\ninside callbacks.</p>", "parent": "can.Construct", "plugin": "can/construct/proxy", "test": "can/construct/proxy/qunit.html", "download": "http://donejs.com/can/dist/can.construct.proxy.js", "title": "proxy", "signatures": [{"code": undefined, "description": "<p>proxy(callback, [...args])</p>", "params": [{"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}, {"type": "String"}, {"type": "Array", "template": [{"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}, {"type": "String"}]}]}], "name": "callback", "description": "<p>the function or functions to proxy</p>"}, {"variable": true, "types": [{"type": "["}], "name": "args", "description": "<p>parameters to curry into the proxied functions</p>"}], "returns": {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}], "description": "<p>a function that calls <code>callback</code> with the same context as the current context</p>\n\n<p><code>can.Construct.prototype.proxy</code> takes a function and returns a new function that, when invoked,\ncalls the given function with the same <code>this</code> as <code>proxy</code> was called with.</p>\n\n<p>Here is a counter that increments its count after a second:</p>\n\n<pre>can.Construct('DelayedCounter', {\n    init: function() {\n        this.count = 0;\n        setTimeout(this.proxy(function() {\n            this.count++;\n        }), 1000);\n    }\n});\n\nvar counter = new DelayedCounter();\n// check counter's value later\nsetTimeout(function() {\n    counter.count; // 1\n}, 5000);</pre>\n\n<p>(Recall that setTimeout executes its callback in the global scope.)</p>\n\n<p>If you pass the name of a function on the <code>this</code> that <code>proxy</code> is called with,\n<code>proxy</code> will use that function. Here's how you write the previous example using\nthis technique:</p>\n\n<pre>can.Construct('DelayedCounter', {\n    init: function() {\n        this.count = 0;\n        setTimeout(this.proxy('increment'), 1000);\n    },\n    increment: function() {\n        this.count++;\n    }\n});\n\nvar counter = new DelayedCounter();\n// check counter's value later\nsetTimeout(function() {\n    counter.count; // 1\n}, 5000);</pre>\n\n<h2>Currying arguments</h2>\n\n<p>If you pass more than one parameter to <code>proxy</code>, the additional parameters will\nbe passed as parameters to the callback before any parameters passed to the\nproxied function.</p>\n\n<p>Here's a delayed counter that increments by a given amount:</p>\n\n<pre>can.Construct('IncrementalCounter', {\n    init: function(amount) {\n        this.count = 0;\n        setTimeout(this.proxy(function(amount) {\n            this.count += amount;\n        }, amount), 1000);\n    }\n});\n\nvar counter = new IncrementalCounter(5);\n// check counter's value later\nsetTimeout(function() { \n    counter.count; // 5\n}, 5000);</pre>\n\n<h2>Piping callbacks</h2>\n\n<p>If you pass an array of functions and strings as the first parameter to <code>proxy</code>,\n<code>proxy</code> will call the callbacks in sequence, passing the return value of each\nas a parameter to the next. This is useful to avoid having to curry callbacks.</p>\n\n<p>Here's a delayed counter that takes a callback to call after incrementing by a given amount:</p>\n\n<pre>can.Construct('IncrementalCounter', {\n    init: function(amount, callback) {\n        this.count = 0;\n        setTimeout(this.proxy([function(amount) {\n            this.count += amount;\n            return this.count;\n        }, callback], amount), 1000);\n    }\n});\n\nvar counter = new IncrementalCounter(5, function(count) {\n    console.log('The count is ' + count + '.');\n});\n\n// after 1 second, the log says \"The count is 5.\"</pre>\n\n<h2><code>proxy</code> on constructors</h2>\n\n<p>can.Construct.proxy also adds <code>proxy</code> to the constructor, so you can use it\nin static functions with the constructor as <code>this</code>.</p>\n\n<p>Here's a counter construct that keeps its count staticly and increments after one second:</p>\n\n<pre>can.Construct('DelayedStaticCounter', {\n    setup: function() {\n        this.count = 0;\n    }\n    incrementSoon: function() {\n        setTimeout(this.proxy(function() {\n            this.count++;\n        }), 1000);\n    }\n}, {});\n\nDelayedStaticCounter.incrementSoon();</pre>\n\n<h2>See also</h2>\n\n<p>[can.proxy] is a way to proxy callbacks outside of <code>can.Construct</code>s.</p>"}}], "src": "can/construct/proxy/proxy.md"})