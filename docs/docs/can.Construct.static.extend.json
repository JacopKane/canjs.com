c({"type": "function", "name": "can.Construct.static.extend", "params": [{"types": [{"type": "String"}], "optional": true, "name": "fullName", "description": "<p>the class's name (used for classes w/ introspection)</p>"}, {"types": [{"type": "Object", "template": [{"types": [{"type": "string"}]}, {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}]}]}], "optional": true, "name": "klass", "description": "<p>the new class's static functions</p>"}, {"types": [{"type": "Object", "template": [{"types": [{"type": "string"}]}, {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}]}]}], "optional": true, "name": "proto", "description": "<p>the new class's prototype functions</p>"}], "parent": "can.Construct.static", "body": "", "description": "<p>Extends a class with new static and prototype functions.  There are a variety of ways\nto use extend:</p>\n\n<pre><code>// with className, static and prototype functions\ncan.Construct('Task',{ STATIC },{ PROTOTYPE })\n// with just classname and prototype functions\ncan.Construct('Task',{ PROTOTYPE })\n// with just a className\ncan.Construct('Task')\n</code></pre>\n\n<p>You no longer have to use <code>extend</code>.  Instead, you can pass those options directly to\ncan.Construct (and any inheriting classes):</p>\n\n<pre><code>// with className, static and prototype functions\ncan.Construct('Task',{ STATIC },{ PROTOTYPE })\n// with just classname and prototype functions\ncan.Construct('Task',{ PROTOTYPE })\n// with just a className\ncan.Construct('Task')\n</code></pre>", "hide": true, "returns": {"types": [{"type": "can.Construct"}], "description": "<p>returns the new class</p>"}, "src": "can/construct/construct.js", "line": 169})