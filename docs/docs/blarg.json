c({"type": "constructor", "name": "blarg", "body": "", "description": "<p><code>can.Construct</code> provides a way to easily use the power of prototypal inheritance without worrying\nabout hooking up all the particulars yourself. It is inspired by John Resig's \n[http://ejohn.org/blog/simple-javascript-inheritance/|Simple JavaScript Inheritance] concept.</p>", "comment": "undefined@class can.Construct\n", "parent": "canjs", "title": "", "signatures": [{"code": undefined, "description": "<p>can.Construct([name, [staticProperties,]] instanceProperties)</p>", "params": [{"types": [{"type": "String"}], "optional": true, "name": "name", "description": "<p>the namespace and name of the constructor</p>"}, {"types": [{"type": "Object"}], "optional": true, "name": "staticProperties", "description": "<p>properties that will belong to the constructor</p>"}, {"types": [{"type": "Object"}], "optional": true, "name": "instanceProperties", "description": "<p>properties that will belong to instances made with the constructor</p>"}], "returns": {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}], "description": "<p>the constructor</p>\n\n<p>In the example below, <code>Animal</code> is a constructor function. All instances of <code>Animal</code> will have a <code>breathe</code>\nmethod, and the <code>Animal</code> constructor itself has a <code>legs</code> property.</p>\n\n<pre>can.Construct('Animal', {\n    legs: 4\n}, {\n    init: function(sound) {\n        this.sound = sound;\n    }\n    speak: function() {\n        console.log(this.sound);\n    }\n});</pre>\n\n<p>You don't have to pass in a name. If you do, the constructor is assigned to that name globally. If not,\nyou'll want to make sure you save your constructor to use later:</p>\n\n<pre>var Robot = can.Construct({\n    beep: function() {\n        console.log('Beep boop.');\n    }\n});</pre>\n\n<p>You can make instances by calling your constructor with the <code>new</code> keyword. When you do, the [can.Construct::init|init]\nmethod gets called (if you supplied one):</p>\n\n<pre>var panther = new Animal({sound: 'growl'});\npanther.speak(); // \"growl\"\npanther instanceof Animal; // true</pre>\n\n<p>This becomes much more powerful when you add inheritance.</p>\n\n<h2>Inheritance</h2>\n\n<p>Subclasses with <code>can.Construct</code> are simple. All you need to do is call the base constructor\nwith the new function's static and instance properties. For example, we want our <code>Snake</code> to\nbe an <code>Animal</code>, but there are some differences:</p>\n\n<pre>Animal('Snake', {\n    legs: 0\n}, {\n    init: function() {\n        this.sound = 'ssssss';\n    },\n    slither: function() {\n        console.log('slithering...');\n    }\n});\n\nvar baslisk = new Snake();\nbaslisk.speak();   // \"ssssss\"\nbaslisk.slither(); // \"slithering...\"\nbaslisk instanceof Snake;  // true\nbaslisk instanceof Animal; // true</pre>\n\n<p>Note that <code>Animal</code>'s <code>init</code> does not get called.</p>\n\n<h2>Static properties and inheritance</h2>\n\n<p>If you pass all three arguments to can.Construct, the second one will be attached directy to the\nconstructor, allowing you to imitate static properties and functions. You can access these\nproperties through the <code>[can.Construct::constructor|this.constructor]</code> property.</p>\n\n<p>Static properties can get overridden through inheritance just like instance properties. Let's see\nhow this works with <code>Animal</code> and <code>Snake</code>:</p>\n\n<pre>can.Construct('Animal', {\n    legs: 4\n}, {\n    init: function(sound) {\n        this.sound = sound;\n    }\n    speak: function() {\n        console.log(this.sound);\n    }\n});\n\nAnimal('Snake', {\n    legs: 0\n}, {\n    init: function() {\n        this.sound = 'ssssss';\n    },\n    slither: function() {\n        console.log('slithering...');\n    }\n});\n\nAnimal.legs; // 4\nSnake.legs; // 0</pre>\n\n<h2>Plugins</h2>\n\n<p>There are two plugins available to help make using <code>can.Construct</code> even simpler.\n* [can.Construct.super] allows you to easily call base methods by making <code>this._super</code> available in inherited methods.\n* [can.Construct.proxy] helps you keep your scope straight when creating callbacks inside constructors.</p>"}}], "src": "can/construct/construct.md"})