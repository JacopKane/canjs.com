c({"type": "function", "name": "static.setup", "params": [{"types": [{"type": "constructor"}], "name": "base", "description": "<p>the base constructor that is being inherited from</p>"}, {"types": [{"type": "String"}], "optional": true, "name": "fullName", "description": "<p>the name of the new constructor</p>"}, {"types": [{"type": "Object"}], "optional": true, "name": "staticProps", "description": "<p>the static properties of the new constructor</p>"}, {"types": [{"type": "Object"}], "optional": true, "name": "protoProps", "description": "<p>the prototype properties of the new constructor</p>"}], "parent": "static", "body": "", "description": "<p>The static <code>setup</code> method is called immediately after a constructor function is created and \nset to inherit from its base constructor. It is useful for setting up additional inheritance work.\nDo not confuse this with the prototype <code>[can.Construct::setup]</code> method.</p>\n\n<h2>Setup Extends Defaults</h2>\n\n<p>Setup deeply extends the static <code>defaults</code> property of the base constructor with \nproperties of the inheriting constructor.  For example:</p>\n\n<pre>Parent = can.Construct({\n  defaults : {\n    parentProp: 'foo'\n  }\n},{})\n\nChild = Parent({\n  defaults : {\n    childProp : 'bar'\n  }\n},{}\n\nChild.defaults // {parentProp: 'foo', 'childProp': 'bar'}</pre>\n\n<h2>Example</h2>\n\n<p>This <code>Parent</code> class adds a reference to its base class to itself, and\nso do all the classes that inherit from it.</p>\n\n<pre>Parent = can.Construct({\n  setup : function(base, fullName, staticProps, protoProps){\n    this.base = base;\n\n    // call base functionality\n    can.Construct.setup.apply(this, arguments)\n  }\n},{});\n\nParent.base; // can.Construct\n\nChild = Parent({});\n\nChild.base; // Parent</pre>", "src": "can/construct/construct.js", "line": 90})