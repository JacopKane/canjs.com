c({"type": "function", "name": "can.Control.prototype.on", "parent": "can.Control.prototype", "body": "<p><code>on(el, selector, eventName, func)</code> binds an event handler for an event to a selector under the scope of the given element.</p>\n\n<p><code>this.on()</code> is used to rebind \nall event handlers when [can.Control::options this.options] has changed.  It\ncan also be used to bind or delegate from other elements or objects.</p>\n\n<h2>Rebinding</h2>\n\n<p>By using templated event handlers, a control can listen to objects outside\n<code>this.element</code>.  This is extremely common in MVC programming.  For example,\nthe following control might listen to a task model's <code>completed</code> property and\ntoggle a strike className like:</p>\n\n<pre><code>TaskStriker = can.Control({\n  \"{task} completed\": function(){\n       this.update();\n  },\n  update: function(){\n    if ( this.options.task.completed ) {\n         this.element.addClass( 'strike' );\n       } else {\n      this.element.removeClass( 'strike' );\n    }\n  }\n});\n\nvar taskstriker = new TaskStriker({ \n  task: new Task({ completed: 'true' }) \n});\n</code></pre>\n\n<p>To update the taskstriker's task, add a task method that updates\nthis.options and calls rebind like:</p>\n\n<pre><code>TaskStriker = can.Control({\n  \"{task} completed\": function(){\n       this.update();\n  },\n  update: function() {\n    if ( this.options.task.completed ) {\n         this.element.addClass( 'strike' );\n       } else {\n      this.element.removeClass( 'strike' );\n    }\n  },\n  task: function( newTask ) {\n    this.options.task = newTask;\n    this.on();\n    this.update();\n  }\n});\n\nvar taskstriker = new TaskStriker({ \n  task: new Task({ completed: true }) \n});\ntaskstriker.task( new TaskStriker({ \n  task: new Task({ completed: false }) \n}));\n</code></pre>\n\n<h2>Adding new events</h2>\n\n<p>If events need to be bound to outside of the control and templated event handlers\nare not sufficent, you can call this.on to bind or delegate programatically:</p>\n\n<pre><code>init: function() {\n   // calls somethingClicked( el, ev )\n   this.on( 'click', 'somethingClicked' ); \n\n   // calls function when the window is clicked\n   this.on( window, 'click', function( ev ) {\n     //do something\n   });\n},\nsomethingClicked: function( el, ev ) {\n\n}\n</code></pre>", "description": "<p>Bind an event handler to a Control, or rebind all event handlers on a Control. </p>", "signatures": [{"code": "on([el,] selector, eventName, func)", "description": "", "params": [{"types": [{"type": "HTMLElement"}, {"type": "jQuery"}, {"type": "collection"}, {"type": "Object"}], "optional": true, "name": "el", "defaultValue": "this.element", "description": "<p>The element to be bound.  If no element is provided, the control's element is used instead.</p>"}, {"types": [{"type": "String"}], "name": "selector", "description": "<p>A css selector for event delegation.</p>"}, {"types": [{"type": "String"}], "name": "eventName", "description": "<p>The event to listen for.</p>"}, {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}, {"type": "String"}], "name": "func", "description": "<p>A callback function or the String name of a control function.  If a control\nfunction name is given, the control function is called back with the bound element and event as the first\nand second parameter.  Otherwise the function is called back like a normal bind.</p>"}], "returns": {"types": [{"type": "Number"}], "description": "<p>The id of the binding in this._bindings</p>"}}, {"code": "on()", "description": "", "params": [], "returns": {"types": [{"type": "Number"}], "description": "<p>The number of handlers bound to this Control.</p>"}}], "comment": " ", "src": "can/control/control.js", "line": 457})