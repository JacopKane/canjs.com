c({"type": "function", "name": "static.Transaction.static.Y.clone", "params": [{"types": [{"type": "object"}], "name": "o", "description": "<p>what to clone.</p>"}, {"types": [{"type": "boolean"}], "name": "safe", "description": "<p>if true, objects will not have prototype\nitems from the source.  If false, they will.  In this case, the\noriginal is initially protected, but the clone is not completely\nimmune from changes to the source object prototype.  Also, cloned\nprototype items that are deleted from the clone will result\nin the value of the source prototype being exposed.  If operating\non a non-safe clone, items should be nulled out rather than deleted.</p>"}, {"types": [{"type": "function", "constructs": undefined, "returns": {"types": [{"type": "undefined"}]}, "params": [], "context": undefined}], "name": "f", "description": "<p>optional function to apply to each item in a\ncollection; it will be executed prior to applying the value to\nthe new object.  Return false to prevent the copy.</p>"}, {"types": [{"type": "object"}], "name": "c", "description": "<p>optional execution context for f.</p>"}, {"types": [{"type": "object"}], "name": "owner", "description": "<p>Owner object passed when clone is iterating\nan object.  Used to set up context for cloned functions.</p>"}, {"types": [{"type": "object"}], "name": "cloned", "description": "<p>hash of previously cloned objects to avoid\nmultiple clones.</p>"}], "parent": "static.Transaction.static", "body": "", "description": "<p>Deep object/array copy.  Function clones are actually\nwrappers around the original function.\nArray-like objects are treated as arrays.\nPrimitives are returned untouched.  Optionally, a\nfunction can be provided to handle other data types,\nfilter keys, validate values, etc.</p>\n\n<p>NOTE: Cloning a non-trivial object is a reasonably heavy operation, due to\nthe need to recurrsively iterate down non-primitive properties. Clone\nshould be used only when a deep clone down to leaf level properties\nis explicitly required.</p>\n\n<p>In many cases (for example, when trying to isolate objects used as\nhashes for configuration properties), a shallow copy, using Y.merge is\nnormally sufficient. If more than one level of isolation is required,\nY.merge can be used selectively at each level which needs to be\nisolated from the original without going all the way to leaf properties.</p>", "comment": "undefined@method clone\n", "returns": {"types": [{"type": "Array"}, {"type": "Object"}], "description": "<p>the cloned object.</p>"}, "src": "can/lib/yui-3.7.3.js", "line": 5975})