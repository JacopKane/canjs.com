c({"type": "function", "name": "can.Control.prototype.setup", "parent": "can.Control.prototype", "body": "<p>Setup is where most of control's magic happens.  It does the following:</p>\n\n<h3>Sets this.element</h3>\n\n<p>The first parameter passed to new Control( el, options ) is expected to be \nan element.  This gets converted to a Wrapped NodeList element and set as\n[can.Control.prototype.element this.element].</p>\n\n<h3>Adds the control's name to the element's className.</h3>\n\n<p>Control adds it's plugin name to the element's className for easier \ndebugging.  For example, if your Control is named \"Foo.Bar\", it adds\n\"foo_bar\" to the className.</p>\n\n<h3>Saves the control in $.data</h3>\n\n<p>A reference to the control instance is saved in $.data.  You can find \ninstances of \"Foo.Bar\" like: </p>\n\n<pre><code>$( '#el' ).data( 'controls' )[ 'foo_bar' ]\n</code></pre>\n\n<h3>Merges Options</h3>\n\n<p>Merges the default options with optional user-supplied ones.\nAdditionally, default values are exposed in the static [can.Control.static.defaults defaults] \nso that users can change them.</p>\n\n<h3>Binds event handlers</h3>\n\n<p>Setup does the event binding described in [can.Control.listening Listening To Events].</p>", "description": "<p>Perform pre-initialization logic. </p>", "signatures": [{"code": "setup(element, options)", "description": "", "params": [{"types": [{"type": "HTMLElement"}], "name": "element", "description": "<p>the element this instance operates on.</p>"}, {"types": [{"type": "Object"}], "optional": true, "name": "options", "description": "<p>option values for the control.  These get added to\nthis.options and merged with [can.Control.static.defaults defaults].</p>"}], "returns": {"types": [{"type": "undefined"}, {"type": "Array"}], "description": "<p>return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.</p>"}}], "comment": " ", "src": "can/control/control.js", "line": 250})