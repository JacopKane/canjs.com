c({"type": "function", "name": "attr", "parent": "can.Observe.List.prototype", "body": "", "description": "<p>Get or set elements in a List. </p>", "title": "", "signatures": [{"code": "attr()", "description": "<p>Gets a collection of all the elements in this <code>can.Observe.List</code>.</p>", "params": [], "returns": {"types": [{"type": "Array"}], "description": "<p>array with all the elements in this List.</p>"}}, {"code": "attr(index)", "description": "<p>Reads a element from this <code>can.Observe.List</code>.</p>", "params": [{"types": [{"type": "Number"}], "name": "index", "description": "<p>the element to read</p>"}], "returns": {"types": [{"type": "*"}], "description": "<p>the value at <em>index</em>.</p>"}}, {"code": "attr(index, value)", "description": "<p>Assigns <em>value</em> to the index <em>index</em> on this <code>can.Observe.List</code>, expanding the list if necessary.</p>", "params": [{"types": [{"type": "Number"}], "name": "index", "description": "<p>the element to set</p>"}, {"types": [{"type": "*"}], "name": "the", "description": "<p>value to assign at <em>index</em></p>"}], "returns": {"types": [{"type": "can.Observe.List"}], "description": "<p>this List, for chaining</p>"}}, {"code": "attr(elements[, replaceCompletely])", "description": "<p>Merges the members of <em>elements</em> into this List, replacing each from the beginning in order. If\n<em>elements</em> is longer than the current List, the current List will be expanded. If <em>elements</em>\nis shorter than the current List, the extra existing members are not affected (unless\n<em>replaceCompletely</em> is <code>true</code>). To remove elements without replacing them, use <code>[can.Observe.List.prototype.removeAttr removeAttr]</code>.</p>", "params": [{"types": [{"type": "Array"}], "name": "elements", "description": "<p>an array of elements to merge in</p>"}, {"types": [{"type": "bool"}], "optional": true, "name": "replaceCompletely", "defaultValue": "false", "description": "<p>whether to completely replace the elements of List\nIf <em>replaceCompletely</em> is <code>true</code> and <em>elements</em> is shorter than the List, the existing\nextra members of the List will be removed.</p>"}, {"types": [{"type": "Event"}], "name": "ev", "description": "<p>the event object</p>"}, {"types": [{"type": "Index"}], "name": "index", "description": "<p>where the change took place</p>"}, {"types": [{"type": "String"}], "name": "how", "description": "<p>whether elements were added, removed, or set\nPossible values are <code>'add'</code>, <code>'remove'</code>, or <code>'set'</code>.</p>"}, {"types": [{"type": "*"}, {"type": "Array"}, {"type": "undefined"}], "name": "newVal", "description": "<p>the elements affected after the change\n<em>newVal</em> will be a single value when an index is set, an Array when elements\nwere added, and <code>undefined</code> if elements were removed.</p>"}, {"types": [{"type": "*"}, {"type": "Array"}, {"type": "undefined"}], "name": "oldVal", "description": "<p>the elements affected before the change\n<em>newVal</em> will be a single value when an index is set, an Array when elements\nwere removed, and <code>undefined</code> if elements were added.</p>\n\n<p>Here is a concrete tour through the <em>change</em> event handler's arguments:</p>\n\n<pre>var list = new can.Observe.List();\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log(ev + ', ' + index + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\nlist.attr(['Alexis', 'Bill']); // [object Object], 0, add, ['Alexis', 'Bill'], undefined\nlist.attr(2, 'Eve');           // [object Object], 2, add, Eve, undefined\nlist.attr(0, 'Adam');          // [object Object], 0, set, Adam, Alexis\nlist.attr(['Alice', 'Bob']);   // [object Object], 0, set, Alice, Adam\n                               // [object Object], 1, set, Bob, Bill\nlist.removeAttr(1);            // [object Object], 1, remove, undefined, Bob</pre>\n\n<h2>The <em>set</em> event</h2>\n\n<p><em>set</em> events are fired when an element at an index that already exists in the List is\nmodified. Actions can cause <em>set</em> events to fire never also cause <em>length</em> events\nto fire (although some functions, such as <code>[can.Observe.List.prototype.splice splice]</code>\nmay cause unrelated sets of events to fire after being batched).</p>\n\n<p>The parameters of the event handler for the <em>set</em> event are:</p>"}, {"types": [{"type": "Event"}], "name": "ev", "description": "<p>the event object</p>"}, {"types": [{"type": "*"}], "name": "newVal", "description": "<p>the new value of the element</p>"}, {"types": [{"type": "Index"}], "name": "index", "description": "<p>where the set took place</p>\n\n<p>Here is a concrete tour through the <em>set</em> event handler's arguments:</p>\n\n<pre>var list = new can.Observe.List();\nlist.bind('set', function(ev, newVal, index) {\n    console.log(newVal + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');          \nlist.attr(0, 'Adam');          // Adam, 0\nlist.attr(['Alice', 'Bob']);   // Alice, 0\n                               // Bob, 1\nlist.removeAttr(1);            </pre>\n\n<h2>The <em>add</em> event</h2>\n\n<p><em>add</em> events are fired when elements are added or inserted\ninto the List.</p>\n\n<p>The parameters of the event handler for the <em>add</em> event are:</p>"}, {"types": [{"type": "Event"}], "name": "ev", "description": "<p>the event object</p>"}, {"types": [{"type": "Array"}, {"type": "*"}], "name": "newElements", "description": "<p>the new elements\nIf more than one element is added, <em>newElements</em> will be an array.\nOtherwise, it is simply the new element itself.</p>"}, {"types": [{"type": "Index"}], "name": "index", "description": "<p>where the add or insert took place</p>\n\n<p>Here is a concrete tour through the <em>add</em> event handler's arguments:</p>\n\n<pre>var list = new can.Observe.List();\nlist.bind('add', function(ev, newElements, index) {\n    console.log(newElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']); // ['Alexis', 'Bill'], 0\nlist.attr(2, 'Eve');           // Eve, 2\nlist.attr(0, 'Adam');          \nlist.attr(['Alice', 'Bob']);   \n\nlist.removeAttr(1);            </pre>\n\n<h2>The <em>remove</em> event</h2>\n\n<p><em>remove</em> events are fired when elements are removed from the list.</p>\n\n<p>The parameters of the event handler for the <em>remove</em> event are:</p>"}, {"types": [{"type": "Event"}], "name": "ev", "description": "<p>the event object</p>"}, {"types": [{"type": "Array"}, {"type": "*"}], "name": "removedElements", "description": "<p>the removed elements\nIf more than one element was removed, <em>removedElements</em> will be an array.\nOtherwise, it is simply the element itself.</p>"}, {"types": [{"type": "Index"}], "name": "index", "description": "<p>where the removal took place</p>\n\n<p>Here is a concrete tour through the <em>remove</em> event handler's arguments:</p>\n\n<pre>var list = new can.Observe.List();\nlist.bind('remove', function(ev, removedElements, index) {\n    console.log(removedElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']); \nlist.attr(2, 'Eve');           \nlist.attr(0, 'Adam');          \nlist.attr(['Alice', 'Bob']);   \n\nlist.removeAttr(1);            // Bob, 1</pre>\n\n<h2>The <em>length</em> event</h2>\n\n<p><em>length</em> events are fired whenever the list changes.</p>\n\n<p>The parameters of the event handler for the <em>length</em> event are:</p>"}, {"types": [{"type": "Event"}], "name": "ev", "description": "<p>the event object</p>"}, {"types": [{"type": "Number"}], "name": "length", "description": "<p>the current length of the list\nIf events were batched when the <em>length</em> event was triggered, <em>length</em>\nwill have the length of the list when <code>stopBatch</code> was called. Because\nof this, you may recieve multiple <em>length</em> events with the same\n<em>length</em> parameter.</p>\n\n<p>Here is a concrete tour through the <em>length</em> event handler's arguments:</p>\n\n<pre>var list = new can.Observe.List();\nlist.bind('length', function(ev, length) {\n    console.log(length);\n});\n\nlist.attr(['Alexis', 'Bill']); // 2\nlist.attr(2, 'Eve');           // 3\nlist.attr(0, 'Adam');          \nlist.attr(['Alice', 'Bob']);   \n\nlist.removeAttr(1);            // 2</pre>"}], "returns": {"types": [{"type": "can.Observe.List"}], "description": "<p>this List, for chaining</p>\n\n<p><code>attr</code> gets or sets elements on the <code>can.Observe.List</code> it's called on. Here's a tour through\nhow all of its forms work:</p>\n\n<pre>var people = new can.Observe.List(['Alex', 'Bill']);\n\n// set an element:\npeople.attr(0, 'Adam');\n\n// get an element:\npeople.attr(0); // 'Adam'\npeople[0]; // 'Adam'\n\n// get all elements:\npeople.attr(); // ['Adam', 'Bill']\n\n// extend the array:\npeople.attr(4, 'Charlie');\npeople.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n// merge the elements:\npeople.attr(['Alice', 'Bob', 'Eve']);\npeople.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']</pre>\n\n<h2>Deep properties</h2>\n\n<p><code>attr</code> can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using <code>attr</code>.</p>\n\n<pre>var people = new can.Observe.List([{name: 'Alex'}, {name: 'Bob'}]);\n\n// set a property:\npeople.attr('0.name', 'Alice');\n\n// get a property:\npeople.attr('0.name');  // 'Alice'\npeople[0].attr('name'); // 'Alice'\n\n// get all properties:\npeople.attr(); // [{name: 'Alice'}, {name: 'Bob'}]</pre>\n\n<p>The discussion of deep properties under <code>[can.Observe.prototype.attr]</code> may also\nbe enlightening.</p>\n\n<h2>Events</h2>\n\n<p><code>can.Observe.List</code>s emit five types of events in response to changes. They are:\n- the <em>change</em> event fires on every change to a List.\n- the <em>set</em> event is fired when an element is set.\n- the <em>add</em> event is fired when an element is added to the List.\n- the <em>remove</em> event is fired when an element is removed from the List.\n- the <em>length</em> event is fired when the length of the List changes.</p>\n\n<ul>\n<li>## The <em>change</em> event</li>\n</ul>\n\n<p>The first event that is fired is the <em>change</em> event. The <em>change</em> event is useful\nif you want to react to all changes on an List.</p>\n\n<pre>var list = new can.Observe.List([]);\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log('Something changed.');\n});</pre>\n\n<p>The parameters of the event handler for the <em>change</em> event are:</p>"}}], "src": "can/observe/observe.js", "line": 1225})