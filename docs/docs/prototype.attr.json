c({"type": "function", "name": "prototype.attr", "parent": "prototype", "body": "", "description": "<p>Get or set properties on an Observe. </p>", "signatures": [{"code": "attr()", "description": "<p>Gets a collection of all the properties in this <code>can.Observe</code>.</p>", "params": [], "returns": {"types": [{"type": "Object", "template": [{"types": [{"type": "String"}]}, {"types": [{"type": "*"}]}]}], "description": "<p>an object with all the properties in this <code>can.Observe</code>.</p>"}}, {"code": "attr(key)", "description": "<p>Reads a property from this <code>can.Observe</code>.</p>", "params": [{"types": [{"type": "String"}], "name": "key", "description": "<p>the property to read</p>"}], "returns": {"types": [{"type": "*"}], "description": "<p>the value assigned to <em>key</em>.</p>"}}, {"code": "attr(key, value)", "description": "<p>Assigns <em>value</em> to a property on this <code>can.Observe</code> called <em>key</em>.</p>", "params": [{"types": [{"type": "String"}], "name": "key", "description": "<p>the property to set</p>"}, {"types": [{"type": "*"}], "name": "the", "description": "<p>value to assign to <em>key</em>.</p>"}], "returns": {"types": [{"type": "can.Observe"}], "description": "<p>this Observe, for chaining</p>"}}, {"code": "attr(obj[, removeOthers])", "description": "<p>Assigns each value in <em>obj</em> to a property on this <code>can.Observe</code> named after the corresponding key in <em>obj</em>.</p>", "params": [{"types": [{"type": "Object", "template": [{"types": [{"type": "String"}]}, {"types": [{"type": "*"}]}]}], "name": "obj", "description": "<p>a collection of key-value pairs to set.\nIf any properties already exist on the <code>can.Observe</code>, they will be overwritten.</p>"}, {"types": [{"type": "bool"}], "optional": true, "name": "removeOthers", "defaultValue": "false", "description": "<p>whether to remove keys not present in <em>obj</em>.\nTo remove keys without setting other keys, use <code>[can.Observe::removeAttr|removeAttr]</code>.</p>"}], "returns": {"types": [{"type": "can.Observe"}], "description": "<p>this Observe, for chaining</p>\n\n<p><code>attr</code> gets or sets properties on the <code>can.Observe</code> it's called on. Here's a tour through\nhow all of its forms work:</p>\n\n<pre>var people = new can.Observe({});\n\n// set a property:\npeople.attr('a', 'Alex');\n\n// get a property:\npeople.attr('a'); // 'Alex'\n\n// set and merge multiple properties:\npeople.attr({\n    a: 'Alice',\n    b: 'Bob'\n});\n\n// get all properties:\npeople.attr(); // {a: 'Alice', b: 'Bob'}\n\n// set properties while removing others:\npeople.attr({\n    b: 'Bill',\n    e: 'Eve'\n}, true);\n\npeople.attr(); // {b: 'Bill', e: 'Eve'}</pre>\n\n<h2>Deep properties</h2>\n\n<p><code>attr</code> can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using <code>attr</code>.</p>\n\n<pre>var people = new can.Observe({names: {}});\n\n// set a property:\npeople.attr('names.a', 'Alice');\n\n// get a property:\npeople.attr('names.a'); // 'Alice'\npeople.names.attr('a'); // 'Alice'\n\n// get all properties:\npeople.attr(); // {names: {a: 'Alice'}}</pre>\n\n<p>Objects that are added to Observes become Observes themselves behind the scenes,\nso changes to deep properties fire events at each level, and you can bind at any\nlevel. As this example shows, all the same events are fired no matter what level\nyou call <code>attr</code> at:</p>\n\n<pre>var people = new can.Observe({names: {}});\n\npeople.bind('change', function(ev, attr, how, newVal, oldVal) {\n  console.log('people change: ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\npeople.names.bind('change', function(ev, attr, how, newVal, oldVal) {\n   console.log('people.names change' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\npeople.bind('names', function(ev, newVal, oldVal) {\n    console.log('people names: ' + newVal + ', ' + oldVal);\n});\n\npeople.names.bind('a', function(ev, newVal, oldVal) {\n    console.log('people.names a: ' + newVal + ', ' + oldVal);\n});\n\npeople.bind('names.a', function(ev, newVal, oldVal) {\n    console.log('people names.a: ' + newVal + ', ' + oldVal);\n});\n\npeople.attr('names.a', 'Alice'); // people change: names.a, add, Alice, undefined\n                                 // people.names change: a, add, Alice, undefined\n                                 // people.names a: Alice, undefined\n                                 // people names.a: Alice, undefined\n\npeople.names.attr('b', 'Bob');   // people change: names.b, add, Bob, undefined\n                                 // people.names change: b, add, Bob, undefined\n                                 // people.names b: Bob, undefined\n                                 // people names.b: Bob, undefined</pre>\n\n<h2>See also</h2>\n\n<p>For information on the events that are fired on property changes and how\nto listen for those events, see [can.Observe.prototype.bind bind].</p>"}}], "src": "can/observe/observe.js", "line": 370})