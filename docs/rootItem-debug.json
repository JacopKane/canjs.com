{
    "active": false,
    "type": "page",
    "name": "canjs",
    "body": "<p>This is the detailed documentation of the API for CanJS, a framework for building\nweb applications that provides a lightweight inheritance system, observable\nobjects and values, and a powerful MVC core with live-bound templates, among other\nresources. You can use it out of the box on top of jQuery, Zepto, YUI, and Mootools,\nand it's only 13K.</p>\n\n<p>If you are just starting with CanJS, you may want to try our <a href=\"../guides/Tutorial.html\">getting started guide</a>.</p>",
    "description": "",
    "title": "CanJS API",
    "parent": "index",
    "order": 0,
    "comment": " ",
    "src": "can/can.md",
    "id": 0,
    "children": [{
            "active": false,
            "type": "constructor",
            "name": "can.Construct",
            "body": "",
            "description": "",
            "title": "",
            "download": "can/construct",
            "test": "can/construct/qunit.html",
            "parent": "canjs",
            "comment": " ",
            "signatures": [{
                    "code": "can.Construct([name, [staticProperties,]] instanceProperties)",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "optional": true,
                            "name": "name",
                            "description": "<p>the namespace and name of the constructor</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "staticProperties",
                            "description": "<p>properties that will belong to the constructor</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "instanceProperties",
                            "description": "<p>properties that will belong to instances made with the constructor</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "description": "<p>The constructor.</p>"
                    }
                }
            ],
            "src": "can/construct/construct.md",
            "id": 1,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Construct.prototype",
                    "parent": "can.Construct",
                    "src": "can/construct/construct.js",
                    "line": 329,
                    "id": 9,
                    "children": [{
                            "active": false,
                            "type": "property",
                            "body": "",
                            "description": "<p>A reference to the constructor function that created the instance. This allows you to access\nthe constructor's static properties from an instance.</p>\n\n<h2>Example</h2>\n\n<p>This class has a static counter that counts how mane instances have been created:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"Counter\", {\n    count: 0\n}, {\n    init: function() {\n        this.constructor.count++;\n    }\n});\n\nnew Counter();\nCounter.count; // 1</code></pre>         ",
                            "types": [{
                                    "type": "function",
                                    "returns": {
                                        "types": [{
                                                "type": "undefined"
                                            }
                                        ]
                                    },
                                    "params": []
                                }
                            ],
                            "title": "constructor",
                            "name": "can.Construct.prototype.constructor",
                            "parent": "can.Construct.prototype",
                            "src": "can/construct/construct.js",
                            "line": 449,
                            "id": 12
                        }, {
                            "active": false,
                            "body": "<p>If a prototype <code>init</code> method is provided, it is called when a new Construct is created,\nafter [can.Construct::setup]. The <code>init</code> method is where the bulk of your initialization code\nshould go, and a common thing to do in <code>init</code> is to save the arguments passed into the constructor.</p>\n\n<h2>Examples</h2>\n\n<p>First, we'll make a Person constructor that has a first and last name:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"Person\", {\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar justin = new Person(\"Justin\", \"Meyer\");\njustin.first; // \"Justin\"\njustin.last; // \"Meyer\"</code></pre>\n\n<p>Then we'll extend Person into Programmer and add a favorite language:</p>\n\n<pre><code class=\"lang-javascript\">Person(\"Programmer\", {\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return 'Hi! I'm ' + this.first + ' ' + this.last +\n            ' and I write ' + this.language + '.';\n    }\n});\n\nvar brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\nbrian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";</code></pre>\n\n<h2>Be Aware</h2>\n\n<p>[can.Construct::setup] is able to modify the arguments passed to <code>init</code>.\nIf you aren't receiving the right arguments to <code>init</code>, check to make sure\nthat they aren't being changed by <code>setup</code> somewhere along the inheritance chain.</p>",
                            "description": "",
                            "title": "init",
                            "name": "can.Construct.prototype.init",
                            "type": "function",
                            "parent": "can.Construct.prototype",
                            "signatures": [{
                                    "code": "init(...args)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "args",
                                            "description": "<p>the arguments passed to the constructor (or the elements of the array returned from [can.Construct::setup])</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/construct/construct.js",
                            "line": 393,
                            "id": 11
                        }, {
                            "active": false,
                            "body": "<p>If a prototype <code>setup</code> method is provided, it is called when a new \ninstance is created. It is passed the same arguments that were passed\nto the constructor.</p>\n\n<p>Because <code>setup</code> is not defined on <code>can.Construct</code> itself, calling super from\ndirectly-inheriting classes will break. In other words, don't do this:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('Snowflake', {\n    setup: function() {\n        this._super(); // this will break!\n    }\n});</code></pre>\n\n<h2><code>setup</code> vs. <code>init</code></h2>\n\n<p>Usually, you should use [can.Construct::init] to do your class's initialization.\nUse <code>setup</code> instead for:</p>\n\n<ul>\n<li>initialization code that you want to run before the inheriting constructor's \n<code>init</code> method is called.</li>\n<li>initialization code that should run whether or not inheriting constructors\ncall their base's <code>init</code> methods.</li>\n<li>modifying the arguments that will get passed to <code>init</code>.</li>\n</ul>\n\n<h2>Example</h2>\n\n<p>This code is a simplified version of the code in [can.Control]'s setup\nmethod. It converts the first argument to a jQuery collection and\nextends the controller's defaults with the options that were passed.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"can.Control\", {\n    setup: function(domElement, rawOptions) {\n        // set up this.element\n        this.element = $(domElement);\n\n        // set up this.options\n        this.options = can.extend({},\n                                  this.constructor.defaults,\n                                  rawOptions\n                                 );\n\n        // pass this.element and this.options to init.\n        return [this.element, this.options];        \n    }\n});</code></pre>         ",
                            "description": "",
                            "title": "setup",
                            "name": "can.Construct.prototype.setup",
                            "type": "function",
                            "parent": "can.Construct.prototype",
                            "signatures": [{
                                    "code": "setup(...args)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "args",
                                            "description": "<p>the arguments passed to the constructor.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Array"
                                            }, {
                                                "type": "undefined"
                                            }
                                        ],
                                        "description": "<p>if an array is returned, the elements of that array are passed as\narguments to [can.Construct::init]. Otherwise, the arguments to the\nconstructor are passed to [can.Construct::init] and the return value of <code>setup</code> is discarded.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/construct/construct.js",
                            "line": 333,
                            "id": 10
                        }
                    ]
                }, {
                    "active": false,
                    "type": "static",
                    "body": "",
                    "description": "",
                    "name": "can.Construct.static",
                    "parent": "can.Construct",
                    "src": "can/construct/construct.js",
                    "line": 22,
                    "id": 2,
                    "children": [{
                            "active": false,
                            "name": "can.Construct.fullName",
                            "type": "property",
                            "parent": "can.Construct.static",
                            "body": "",
                            "description": "<p>If you pass a name when creating a Construct, the <code>fullName</code> property will be set to\nthe name you passed.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"</code></pre>             ",
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "title": "fullName",
                            "src": "can/construct/construct.js",
                            "line": 299,
                            "id": 8
                        }, {
                            "active": false,
                            "name": "can.Construct.namespace",
                            "type": "property",
                            "parent": "can.Construct.static",
                            "body": "",
                            "description": "<p>The <code>namespace</code> property returns the namespace your constructor is in.\nThis provides a way organize code and ensure globally unique types.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"</code></pre>             ",
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "title": "namespace",
                            "src": "can/construct/construct.js",
                            "line": 268,
                            "id": 6
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Construct.newInstance",
                            "parent": "can.Construct.static",
                            "body": "<p>Creates a new instance of the constructor function. This method is useful for creating new instances\nwith arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n<strong>new</strong> operator.</p>\n\n<h2>Example</h2>\n\n<p>The following creates a <code>Person</code> Construct and then creates a new instance of Person,\nusing <code>apply</code> on newInstance to pass arbitrary parameters.</p>\n\n<pre><code class=\"lang-javascript\">var Person = can.Construct({\n  init : function(first, middle, last) {\n    this.first = first;\n    this.middle = middle;\n    this.last = last;\n  }\n});\n\nvar args = [\"Justin\",\"Barry\",\"Meyer\"],\n    justin = new Person.newInstance.apply(null, args);</code></pre>     ",
                            "description": "<p>Create a new instance of a Construct. </p>",
                            "title": "newInstance",
                            "signatures": [{
                                    "code": "newInstance([...args])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "args",
                                            "description": "<p>arguments that get passed to [can.Construct::setup] and [can.Construct::init]. Note\nthat if [can.Construct::setup] returns an array, those arguments will be passed to [can.Construct::init]\ninstead.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "class"
                                            }
                                        ],
                                        "description": "<p>instance of the class</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/construct/construct.js",
                            "line": 26,
                            "id": 3
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Construct.setup",
                            "parent": "can.Construct.static",
                            "body": "<p>The static <code>setup</code> method is called immediately after a constructor function is created and \nset to inherit from its base constructor. It is useful for setting up additional inheritance work.\nDo not confuse this with the prototype <code>[can.Construct::setup]</code> method.</p>\n\n<h2>Setup Extends Defaults</h2>\n\n<p>Setup deeply extends the static <code>defaults</code> property of the base constructor with \nproperties of the inheriting constructor.  For example:</p>\n\n<pre><code class=\"lang-javascript\">Parent = can.Construct({\n  defaults : {\n    parentProp: 'foo'\n  }\n},{})\n\nChild = Parent({\n  defaults : {\n    childProp : 'bar'\n  }\n},{}\n\nChild.defaults // {parentProp: 'foo', 'childProp': 'bar'}</code></pre>\n\n<h2>Example</h2>\n\n<p>This <code>Parent</code> class adds a reference to its base class to itself, and\nso do all the classes that inherit from it.</p>\n\n<pre><code class=\"lang-javascript\">Parent = can.Construct({\n  setup : function(base, fullName, staticProps, protoProps){\n    this.base = base;\n\n    // call base functionality\n    can.Construct.setup.apply(this, arguments)\n  }\n},{});\n\nParent.base; // can.Construct\n\nChild = Parent({});\n\nChild.base; // Parent</code></pre>     ",
                            "description": "<p>Perform initialization logic for a constructor function. </p>",
                            "title": "setup",
                            "signatures": [{
                                    "code": "setup(base, fullName, staticProps, protoProps)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "constructor"
                                                }
                                            ],
                                            "name": "base",
                                            "description": "<p>The base constructor that is being inherited from.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "fullName",
                                            "description": "<p>The name of the new constructor.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "staticProps",
                                            "description": "<p>The static properties of the new constructor.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "protoProps",
                                            "description": "<p>The prototype properties of the new constructor.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/construct/construct.js",
                            "line": 94,
                            "id": 4
                        }, {
                            "active": false,
                            "name": "can.Construct.shortName",
                            "type": "property",
                            "parent": "can.Construct.static",
                            "body": "",
                            "description": "<p>If you pass a name when creating a Construct, the <code>shortName</code> property will be set to the\nname you passed without the namespace.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"</code></pre>             ",
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "title": "shortName",
                            "src": "can/construct/construct.js",
                            "line": 283,
                            "id": 7
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Construct.static.extend",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "fullName",
                                    "description": "<p>the class's name (used for classes w/ introspection)</p>"
                                }, {
                                    "types": [{
                                            "type": "Object",
                                            "template": [{
                                                    "types": [{
                                                            "type": "string"
                                                        }
                                                    ]
                                                }, {
                                                    "types": [{
                                                            "type": "function",
                                                            "returns": {
                                                                "types": [{
                                                                        "type": "undefined"
                                                                    }
                                                                ]
                                                            },
                                                            "params": []
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ],
                                    "optional": true,
                                    "name": "klass",
                                    "description": "<p>the new class's static functions</p>"
                                }, {
                                    "types": [{
                                            "type": "Object",
                                            "template": [{
                                                    "types": [{
                                                            "type": "string"
                                                        }
                                                    ]
                                                }, {
                                                    "types": [{
                                                            "type": "function",
                                                            "returns": {
                                                                "types": [{
                                                                        "type": "undefined"
                                                                    }
                                                                ]
                                                            },
                                                            "params": []
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ],
                                    "optional": true,
                                    "name": "proto",
                                    "description": "<p>the new class's prototype functions</p>"
                                }
                            ],
                            "parent": "can.Construct.static",
                            "body": "",
                            "description": "<p>Extends a class with new static and prototype functions.  There are a variety of ways\nto use extend:</p>\n\n<pre><code>// with className, static and prototype functions\ncan.Construct('Task',{ STATIC },{ PROTOTYPE })\n// with just classname and prototype functions\ncan.Construct('Task',{ PROTOTYPE })\n// with just a className\ncan.Construct('Task')\n</code></pre>\n\n<p>You no longer have to use <code>extend</code>.  Instead, you can pass those options directly to\ncan.Construct (and any inheriting classes):</p>\n\n<pre><code>// with className, static and prototype functions\ncan.Construct('Task',{ STATIC },{ PROTOTYPE })\n// with just classname and prototype functions\ncan.Construct('Task',{ PROTOTYPE })\n// with just a className\ncan.Construct('Task')\n</code></pre>",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "can.Construct"
                                    }
                                ],
                                "description": "<p>returns the new class</p>"
                            },
                            "src": "can/construct/construct.js",
                            "line": 170,
                            "id": 5
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.Control",
            "body": "<div class='demo_wrapper' data-demo-src='can/control/control.html'></div><div class='iframe_wrapper' data-iframe-src='can/test/demo.html' data-iframe-height='400'></div>",
            "description": "<p>widget factory with declarative event binding. \ncan.Control helps create organized, memory-leak free, rapidly performing,\nstateful controls. Use it to create UI controls like tabs, grids, and context menus,\nand organize them into higher-order business rules with\n[can.route]. It can serve as both a traditional view and a traditional controller.</p>\n\n<h2>Todo Example</h2>\n\n<p>Here is an example of how to build a simple tab widget using can.Control:</p>\n\n<h2>Creating a Control</h2>\n\n<p>The following example builds up a basic todos widget for listing \nand completing todo items. Start by creating a control constructor \nfunction of your own by extending can.Control:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element, options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.element.html( 'todos.ejs', todos );\n    });\n  }\n});\n</code></pre>\n\n<p>Create an instance of the Todos control on the <code>todos</code> element with:</p>\n\n<pre><code>var todosControl = new Todos( '#todos', {} );\n</code></pre>\n\n<p>The control's associated [can.EJS EJS] template looks like:</p>\n\n<pre><code>&lt;% list( todos, function( todo ) { %&gt;\n  &lt;li &lt;%= (el) -&gt; el.data( 'todo', todo ) %&gt; &gt;\n    &lt;%= todo.attr( 'name' ) %&gt;\n    &lt;a href=\"javascript://\" class=\"destroy\"&gt;\n  &lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<h2>init <code>can.Control.prototype.init( element, options )</code></h2>\n\n<p><code>init</code> is called when a new can.Control instance is created. It is called with:</p>\n\n<ul>\n<li><strong>element</strong> - The wrapped element passed to the \n            control. Control accepts a\n            raw HTMLElement, a CSS selector, or a NodeList. This is\n            set as <strong>this.element</strong> on the control instance.</li>\n<li><strong>options</strong> - The second argument passed to new Control, extended with\n            the can.Control's static <strong>defaults</strong>. This is set as \n            <strong>this.options</strong> on the control instance.</li>\n</ul>\n\n<p>and any other arguments passed to <code>new can.Control()</code>. For example:</p>\n\n<pre><code>var Todos = can.Control({\n  defaults : { view: 'todos.ejs' }\n}, {\n  init: function( element , options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n        self.element.html( self.options.view, todos );\n    });\n  }\n});\n\n// create a Todos with default options\nnew Todos( document.body.firstElementChild );\n\n// overwrite the template option\nnew Todos( $( '#todos' ), { template: 'specialTodos.ejs' } );\n</code></pre>\n\n<h2>element <code>this.element</code></h2>\n\n<p>[can.Control::element] is the \nNodeList consisting of the element the control is created on. </p>\n\n<pre><code>var todosControl = new Todos( document.body.firstElementChild );\ntodosControl.element[0] //-&gt; document.body.firstElementChild\n</code></pre>\n\n<p>Each library wraps elements differently. If you are using jQuery, for example,\nthe element is wrapped with <code>jQuery( element )</code>.</p>\n\n<h2>options <code>this.options</code></h2>\n\n<p>[can.Control::options] is the second argument passed to \n<code>new can.Control()</code>, merged with the control's static <strong>defaults</strong> property.</p>\n\n<h2>Listening to events</h2>\n\n<p>Control automatically binds prototype methods that look\nlike event handlers. Listen to <strong>click</strong>s on <code>&lt;li&gt;</code> elements like:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element , options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.element.html( self.options.template, todos );\n    });\n  },\n\n  'li click': function( li, event ) {\n    console.log( 'You clicked', li.text() );\n\n    // let other controls know what happened\n    li.trigger( 'selected' );\n  }\n});\n</code></pre>\n\n<p>When an <code>&lt;li&gt;</code> is clicked, <code>\"li click\"</code> is called with:</p>\n\n<ul>\n<li>The library-wrapped <strong>element</strong> that was clicked</li>\n<li>The <strong>event</strong> data</li>\n</ul>\n\n<p>Control uses event delegation, so you can add <code>&lt;li&gt;</code>s without needing to rebind\nevent handlers.</p>\n\n<p>To destroy a todo when its <code>&lt;a href=\"javascript://\" class=\"destroy\"&gt;</code> link \nis clicked:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element, options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.element.html( self.options.template, todos );\n    });\n  },\n\n  'li click': function( li ) {\n    li.trigger( 'selected', li.model() );\n  },\n\n  'li .destroy click': function( el, ev ) {\n    // get the li element that has todo data\n    var li = el.closest( 'li' );\n\n    // get the model\n    var todo = li.data( 'todo' );\n\n    //destroy it\n    todo.destroy();\n  }\n});\n</code></pre>\n\n<p>When the todo is destroyed, EJS's live binding will remove its LI automatically.</p>\n\n<h2>Templated Event Handlers Part 1 <code>\"{eventName}\"</code></h2>\n\n<p>Customize event handler behavior with <code>\"{NAME}\"</code> in\nthe event handler name.  The following allows customization \nof the event that destroys a todo:</p>\n\n<pre><code>var Todos = can.Control( 'Todos', {\n  init: function( element , options ) { ... },\n\n  'li click': function( li ) { ... },\n\n  'li .destroy {destroyEvent}': function( el, ev ) { \n    // previous destroy code here\n  }\n});\n\n// create Todos with this.options.destroyEvent\nnew Todos( '#todos', { destroyEvent: 'mouseenter' } );\n</code></pre>\n\n<p>Values inside <code>{NAME}</code> are looked up on the control's <code>this.options</code> first,\nand then the <code>window</code>. For example, we could customize it instead like:</p>\n\n<pre><code>var Todos = can.Control( 'Todos', {\n  init: function( element , options ) { ... },\n\n  'li click': function( li ) { ... },\n\n  'li .destroy {Events.destroy}': function( el, ev ) { \n    // previous destroy code here\n  }\n});\n\n// Events config\nEvents = { destroy: 'click' };\n\n// Events.destroy is looked up on the window.\nnew Todos( '#todos' );\n</code></pre>\n\n<p>The selector can also be templated.</p>\n\n<pre><code>var Todos = can.Control( 'Todos', {\n  init: function( element , options ) { ... },\n\n  '{listElement} click': function( li ) { ... },\n\n  '{listElement} .destroy {destroyEvent}': function( el, ev ) { \n    // previous destroy code here\n  }\n});\n\n// create Todos with this.options.destroyEvent\nnew Todos( '#todos',  { \n  destroyEvent: 'mouseenter', \n  listElement: 'li' \n} );\n</code></pre>\n\n<h2>Templated Event Handlers Part 2 <code>\"{objectName}\"</code></h2>\n\n<p>Control can also bind to objects other than <code>this.element</code> with\ntemplated event handlers.  This is <em>critical</em>\nfor avoiding memory leaks that are so common among MVC applications.  </p>\n\n<p>If the value inside <code>{NAME}</code> is an object, Control will bind to that\nobject to listen for events. For example, the following tooltip listens to \nclicks on the window:</p>\n\n<pre><code>var Tooltip = can.Control({\n  '{window} click': function( el, ev ) {\n    // hide only if we clicked outside the tooltip\n    if ( !this.element.has( ev.target ) ) {\n      this.element.remove();\n    }\n  }\n});\n\n// create a Tooltip\nnew Tooltip( $( '&lt;div&gt;INFO&lt;/div&gt;' ).appendTo( el ) );\n</code></pre>\n\n<p>This is convenient when listening for model changes. If EJS were not\ntaking care of removing <code>&lt;li&gt;</code>s after their associated models were destroyed,\nwe could implement it in <code>Todos</code> like:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element, options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.todosList = todos;\n      self.element.html( self.options.template, todos );\n    });\n  },\n\n  'li click': function( li ) {\n    li.trigger( 'selected', li.model() );\n  },\n\n  'li .destroy click': function( el, ev ) {\n    // get the li element that has todo data\n    var li = el.closest( 'li' );\n\n    // get the model\n    var todo = li.data( 'todo' );\n\n    //destroy it\n    todo.destroy();\n  },\n\n  '{Todo} destroyed': function( Todo, ev, todoDestroyed ) {\n    // find where the element\n    var index = this.todosList.indexOf( todoDestroyed );\n    this.element.children( ':nth-child(' + ( index + 1 ) + ')' )\n                .remove();\n  }\n});\n\nnew Todos( '#todos' );\n</code></pre>\n\n<h2>destroy <code>control.destroy()</code></h2>\n\n<p>[can.Control::destroy] unbinds a control's\nevent handlers and releases its element, but does not remove \nthe element from the page. </p>\n\n<pre><code>var todo = new Todos( '#todos' );\ntodo.destroy();\n</code></pre>\n\n<p>When a control's element is removed from the page\n<strong>destroy</strong> is called automatically.</p>\n\n<pre><code>new Todos( '#todos' );\n$( '#todos' ).remove();\n</code></pre>\n\n<p>All event handlers bound with Control are unbound when the control \nis destroyed (or its element is removed).</p>\n\n<p><em>Brief aside on destroy and templated event binding. Taken \ntogether, templated event binding, and control's automatic\nclean-up make it almost impossible \nto write leaking applications. An application that uses\nonly templated event handlers on controls within the body\ncould free up all \ndata by calling <code>$(document.body).empty()</code>.</em></p>\n\n<h2>on <code>control.on()</code></h2>\n\n<p>[can.Control::on] rebinds a control's event handlers. This is useful when you want\nto listen to a specific model and change it:</p>\n\n<pre><code>var Editor = can.Control({\n  todo: function( todo ) {\n    this.options.todo = todo;\n    this.on();\n    this.setName();\n  },\n\n  // a helper that sets the value of the input\n  // to the todo's name\n  setName: function() {\n    this.element.val( this.options.todo.name );\n  },\n\n  // listen for changes in the todo\n  // and update the input\n  '{todo} updated': function() {\n    this.setName();\n  },\n\n  // when the input changes\n  // update the todo instance\n  'change': function() {\n    var todo = this.options.todo;\n    todo.attr( 'name', this.element.val() );\n    todo.save();\n  }\n});\n\nvar todo1 = new Todo({ id: 6, name: 'trash' }),\n    todo2 = new Todo({ id: 6, name: 'dishes' });\n\n// create the editor;\nvar editor = new Editor( '#editor' );\n\n// show the first todo\neditor.todo( todo1 );\n\n// switch it to the second todo\neditor.todo( todo2 );\n</code></pre>\n\n<p>Here's the full todo list manager in action:</p>",
            "title": "",
            "parent": "canjs",
            "download": "can/route",
            "test": "can/control/qunit.html",
            "inherits": "can.Construct",
            "comment": "undefined@group can.Control.plugins plugins\n",
            "src": "can/control/control.md",
            "id": 100,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Control.prototype",
                    "parent": "can.Control",
                    "src": "can/control/control.js",
                    "line": 290,
                    "id": 107,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Control.prototype.destroy",
                            "parent": "can.Control.prototype",
                            "body": "<p><code>destroy</code> prepares a control for garbage collection and is a place to\nreset any changes the control has made.  </p>\n\n<h2>Allowing Garbage Collection</h2>\n\n<p>Destroy is called whenever a control's element is removed from the page using \nthe library's standard HTML modifier methods.  This means that you\ndon't have to call destroy yourself and it \nwill be called automatically when appropriate.  </p>\n\n<p>The following <code>Clicker</code> widget listens on the window for clicks and updates\nits element's innerHTML.  If we remove the element, the window's event handler\nis removed auto-magically:</p>\n\n<pre><code> Clickr = can.Control({\n  \"{window} click\": function() {\n       this.element.html( this.count ? \n                          this.count++ : this.count = 0 );\n  }  \n});\n\n// create a clicker on an element\nnew Clicker( \"#clickme\" );\n\n// remove the element\n$( '#clickme' ).remove();\n</code></pre>\n\n<p>The methods you can use that will destroy controls automatically by library:</p>\n\n<p><strong>jQuery and Zepto</strong></p>\n\n<ul>\n<li>$.fn.remove</li>\n<li>$.fn.html</li>\n<li>$.fn.replaceWith</li>\n<li>$.fn.empty</li>\n</ul>\n\n<p><strong>Dojo</strong></p>\n\n<ul>\n<li>dojo.destroy</li>\n<li>dojo.empty</li>\n<li>dojo.place (with the replace option)</li>\n</ul>\n\n<p><strong>Mootools</strong></p>\n\n<ul>\n<li>Element.prototype.destroy</li>\n</ul>\n\n<p><strong>YUI</strong></p>\n\n<ul>\n<li>TODO!</li>\n</ul>\n\n<h2>Teardown in Destroy</h2>\n\n<p>Sometimes, you want to reset a controlled element back to its\noriginal state when the control is destroyed.  Overwriting destroy\nlets you write teardown code of this manner.  <strong>When overwriting\ndestroy, make sure you call Control's base functionality</strong>.</p>\n\n<p>The following example changes an element's text when the control is\ncreated and sets it back when the control is removed:</p>\n\n<pre><code>Changer = can.Control({\n  init: function() {\n    this.oldText = this.element.text();\n    this.element.text( \"Changed!!!\" );\n  },\n  destroy: function() {\n    this.element.text( this.oldText );\n    can.Control.prototype.destroy.call( this );\n  }\n});\n\n// create a changer which changes #myel's text\nvar changer = new Changer( '#myel' );\n\n// destroy changer which will reset it\nchanger.destroy();\n</code></pre>\n\n<h2>Base Functionality</h2>\n\n<p>Control prepares the control for garbage collection by:</p>\n\n<ul>\n<li>unbinding all event handlers</li>\n<li>clearing references to this.element and this.options</li>\n<li>clearing the element's reference to the control</li>\n<li>removing it's [can.Control.pluginName] from the element's className</li>\n</ul>",
                            "description": "<p>Remove a Control from an element and clean up the Control. </p>",
                            "signatures": [{
                                    "code": "destroy()",
                                    "description": "",
                                    "params": []
                                }
                            ],
                            "title": "destroy",
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 684,
                            "id": 113
                        }, {
                            "active": false,
                            "body": "",
                            "description": "<p>The element the Control is associated with. \nThe control instance's HTMLElement (or window) wrapped by the \nutil library for ease of use. It is set by the first\nparameter to <code>new can.Construct( element, options )</code> \nin [can.Control::setup].  Control listens on <code>this.element</code>\nfor events.</p>\n\n<h3>Quick Example</h3>\n\n<p>The following <code>HelloWorld</code> control sets the control`s text to \"Hello World\":</p>\n\n<pre><code>HelloWorld = can.Control({\n  init: function(){\n       this.element.text( 'Hello World' );\n  }\n});\n\n// create the controller on the element\nnew HelloWorld( document.getElementById( '#helloworld' ) );\n</code></pre>\n\n<h2>Wrapped NodeList</h2>\n\n<p><code>this.element</code> is a wrapped NodeList of one HTMLELement (or window).  This\nis for convience in libraries like jQuery where all methods operate only on a\nNodeList.  To get the raw HTMLElement, write:</p>\n\n<pre><code>this.element[0] //-&gt; HTMLElement\n</code></pre>\n\n<p>The following details the NodeList used by each library with \nan example of updating it's text:</p>\n\n<p><strong>jQuery</strong> <code>jQuery( HTMLElement )</code></p>\n\n<pre><code>this.element.text(\"Hello World\")\n</code></pre>\n\n<p><strong>Zepto</strong> <code>Zepto( HTMLElement )</code></p>\n\n<pre><code>this.element.text(\"Hello World\")\n</code></pre>\n\n<p><strong>Dojo</strong> <code>new dojo.NodeList( HTMLElement )</code></p>\n\n<pre><code>// TODO\n</code></pre>\n\n<p><strong>Mootools</strong> <code>$$( HTMLElement )</code></p>\n\n<p>this.element.empty().appendText(\"Hello World\")</p>\n\n<p><strong>YUI</strong> </p>\n\n<p>// TODO</p>\n\n<h2>Changing <code>this.element</code></h2>\n\n<p>Sometimes you don't want what's passed to <code>new can.Control</code>\nto be this.element.  You can change this by overwriting\nsetup or by unbinding, setting this.element, and rebinding.</p>\n\n<h3>Overwriting Setup</h3>\n\n<p>The following Combobox overwrites setup to wrap a\nselect element with a div.  That div is used \nas <code>this.element</code>. Notice how <code>destroy</code> sets back the\noriginal element.</p>\n\n<pre><code>Combobox = can.Control({\n  setup: function( el, options ) {\n     this.oldElement = $( el );\n     var newEl = $( '&lt;div/&gt;' );\n     this.oldElement.wrap( newEl );\n     can.Controll.prototype.setup.call( this, newEl, options );\n  },\n  init: function() {\n     this.element //-&gt; the div\n  },\n  \".option click\": function() {\n    // event handler bound on the div\n  },\n  destroy: function() {\n     var div = this.element; //save reference\n     can.Control.prototype.destroy.call( this );\n     div.replaceWith( this.oldElement );\n  }\n});\n</code></pre>\n\n<h3>unbinding, setting, and rebinding.</h3>\n\n<p>You could also change this.element by calling\n[can.Control::off], setting this.element, and \nthen calling [can.Control::on] like:</p>\n\n<pre><code>move: function( newElement ) {\n   this.off();\n   this.element = $( newElement );\n   this.on();\n}\n</code></pre>",
                            "title": "element",
                            "name": "can.Control.prototype.element",
                            "type": "property",
                            "parent": "can.Control.prototype",
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 295,
                            "id": 108
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.prototype.off",
                            "params": [],
                            "parent": "can.Control.prototype",
                            "body": "",
                            "description": "<p>Unbinds all event handlers on the controller. You should never\nbe calling this unless in use with [can.Control::on].</p>",
                            "hide": true,
                            "src": "can/control/control.js",
                            "line": 670,
                            "id": 112
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.prototype.on",
                            "parent": "can.Control.prototype",
                            "body": "<p><code>on(el, selector, eventName, func)</code> binds an event handler for an event to a selector under the scope of the given element.</p>\n\n<p><code>this.on()</code> is used to rebind \nall event handlers when [can.Control::options this.options] has changed.  It\ncan also be used to bind or delegate from other elements or objects.</p>\n\n<h2>Rebinding</h2>\n\n<p>By using templated event handlers, a control can listen to objects outside\n<code>this.element</code>.  This is extremely common in MVC programming.  For example,\nthe following control might listen to a task model's <code>completed</code> property and\ntoggle a strike className like:</p>\n\n<pre><code>TaskStriker = can.Control({\n  \"{task} completed\": function(){\n       this.update();\n  },\n  update: function(){\n    if ( this.options.task.completed ) {\n         this.element.addClass( 'strike' );\n       } else {\n      this.element.removeClass( 'strike' );\n    }\n  }\n});\n\nvar taskstriker = new TaskStriker({ \n  task: new Task({ completed: 'true' }) \n});\n</code></pre>\n\n<p>To update the taskstriker's task, add a task method that updates\nthis.options and calls rebind like:</p>\n\n<pre><code>TaskStriker = can.Control({\n  \"{task} completed\": function(){\n       this.update();\n  },\n  update: function() {\n    if ( this.options.task.completed ) {\n         this.element.addClass( 'strike' );\n       } else {\n      this.element.removeClass( 'strike' );\n    }\n  },\n  task: function( newTask ) {\n    this.options.task = newTask;\n    this.on();\n    this.update();\n  }\n});\n\nvar taskstriker = new TaskStriker({ \n  task: new Task({ completed: true }) \n});\ntaskstriker.task( new TaskStriker({ \n  task: new Task({ completed: false }) \n}));\n</code></pre>\n\n<h2>Adding new events</h2>\n\n<p>If events need to be bound to outside of the control and templated event handlers\nare not sufficent, you can call this.on to bind or delegate programatically:</p>\n\n<pre><code>init: function() {\n   // calls somethingClicked( el, ev )\n   this.on( 'click', 'somethingClicked' ); \n\n   // calls function when the window is clicked\n   this.on( window, 'click', function( ev ) {\n     //do something\n   });\n},\nsomethingClicked: function( el, ev ) {\n\n}\n</code></pre>",
                            "description": "<p>Bind an event handler to a Control, or rebind all event handlers on a Control. </p>",
                            "title": "on",
                            "signatures": [{
                                    "code": "on([el,] selector, eventName, func)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "HTMLElement"
                                                }, {
                                                    "type": "jQuery"
                                                }, {
                                                    "type": "collection"
                                                }, {
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "el",
                                            "defaultValue": "this.element",
                                            "description": "<p>The element to be bound.  If no element is provided, the control's element is used instead.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "selector",
                                            "description": "<p>A css selector for event delegation.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventName",
                                            "description": "<p>The event to listen for.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }, {
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "func",
                                            "description": "<p>A callback function or the String name of a control function.  If a control\nfunction name is given, the control function is called back with the bound element and event as the first\nand second parameter.  Otherwise the function is called back like a normal bind.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>The id of the binding in this._bindings</p>"
                                    }
                                }, {
                                    "code": "on()",
                                    "description": "",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>The number of handlers bound to this Control.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 519,
                            "id": 111
                        }, {
                            "active": false,
                            "name": "can.Control.prototype.options",
                            "type": "property",
                            "parent": "can.Control.prototype",
                            "body": "<p>Options are used to configure a control.  They are\nthe 2nd argument\npassed to a control (or the first argument passed to the \n[can.Control.plugin control]'s jQuery plugin).</p>\n\n<p>For example:</p>\n\n<pre><code>can.Control('Hello')\n\nvar h1 = new Hello( $( '#content1' ), { message: 'World' } );\nequal( h1.options.message , \"World\" );\n\nvar h2 = $( '#content2' ).hello({ message: 'There' })\n                         .control();\nequal( h2.options.message , \"There\" );\n</code></pre>\n\n<p>Options are merged with [can.Control.static.defaults defaults] in\n[can.Control.prototype.setup setup].</p>\n\n<p>For example:</p>\n\n<pre><code>Tabs = can.Control({\n   defaults: {\n     activeClass: \"ui-active-state\"\n   }\n}, {\n   init: function(){\n     this.element.addClass( this.options.activeClass );\n   }\n});\n\nnew Tabs( $( \"#tabs1\" ) ); // adds 'ui-active-state'\nnew Tabs( $( \"#tabs2\" ), { activeClass : 'active' } ); // adds 'active'\n</code></pre>",
                            "description": "",
                            "title": "options",
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 371,
                            "id": 110
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.prototype.setup",
                            "parent": "can.Control.prototype",
                            "body": "<p>Setup is where most of control's magic happens.  It does the following:</p>\n\n<h3>Sets this.element</h3>\n\n<p>The first parameter passed to new Control( el, options ) is expected to be \nan element.  This gets converted to a Wrapped NodeList element and set as\n[can.Control.prototype.element this.element].</p>\n\n<h3>Adds the control's name to the element's className</h3>\n\n<p>Control adds it's plugin name to the element's className for easier \ndebugging.  For example, if your Control is named \"Foo.Bar\", it adds\n\"foo_bar\" to the className.</p>\n\n<h3>Saves the control in $.data</h3>\n\n<p>A reference to the control instance is saved in $.data.  You can find \ninstances of \"Foo.Bar\" like: </p>\n\n<pre><code>$( '#el' ).data( 'controls' )[ 'foo_bar' ]\n</code></pre>\n\n<h3>Merges Options</h3>\n\n<p>Merges the default options with optional user-supplied ones.\nAdditionally, default values are exposed in the static [can.Control.static.defaults defaults] \nso that users can change them.</p>\n\n<h3>Binds event handlers</h3>\n\n<p>Setup does the event binding described in [can.Control].</p>",
                            "description": "<p>Perform pre-initialization logic. </p>",
                            "title": "setup",
                            "signatures": [{
                                    "code": "setup(element, options)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "HTMLElement"
                                                }, {
                                                    "type": "NodeList"
                                                }, {
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "element",
                                            "description": "<p>The element as passed to the constructor.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "options",
                                            "description": "<p>option values for the control.  These get added to\nthis.options and merged with [can.Control.static.defaults defaults].</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "undefined"
                                            }, {
                                                "type": "Array"
                                            }
                                        ],
                                        "description": "<p>return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 311,
                            "id": 109
                        }
                    ]
                }, {
                    "active": false,
                    "type": "static",
                    "body": "",
                    "description": "",
                    "name": "can.Control.static",
                    "parent": "can.Control",
                    "src": "can/control/control.js",
                    "line": 43,
                    "id": 101,
                    "children": [{
                            "active": false,
                            "type": "property",
                            "body": "<p><code>defaults</code> provides default values for a Control's options.\nOptions passed into the constructor function will be shallowly merged\ninto the values from defaults in [can.Control::setup], and\nthe result will be stored in <code>[can.Control::options this.options]</code>.</p>\n\n<pre><code>Message = can.Control({\n  defaults: {\n    message: \"Hello World\"\n  }\n}, {\n  init: function(){\n    this.element.text( this.options.message );\n  }\n});\n\nnew Message( \"#el1\" ); //writes \"Hello World\"\nnew Message( \"#el12\", { message: \"hi\" } ); //writes hi\n</code></pre>",
                            "description": "<p>Default values for the Control's options. </p>",
                            "title": "defaults",
                            "name": "can.Control.defaults",
                            "parent": "can.Control.static",
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 264,
                            "id": 106
                        }, {
                            "active": false,
                            "name": "can.Control.processors",
                            "type": "property",
                            "parent": "can.Control.static",
                            "body": "<p><code>processors</code> is an object that allows you to add new events to bind\nto on a control, or to change how existent events are bound. Each\nkey-value pair of <code>processors</code> is a specification that pertains to\nan event where the key is the name of the event, and the value is\na function that processes calls to bind to the event.</p>\n\n<p>The processor function takes five arguments:</p>\n\n<ul>\n<li><em>el</em>: The Control's element.</li>\n<li><em>event</em>: The event type.</li>\n<li><em>selector</em>: The selector preceding the event in the binding used on the Control.</li>\n<li><em>callback</em>: The callback function being bound.</li>\n<li><em>control</em>: The Control the event is bound on.</li>\n</ul>\n\n<p>Inside your processor function, you should bind <em>callback</em> to the event, and\nreturn a function for can.Control to call when <em>callback</em> needs to be unbound.\n(If <em>selector</em> is defined, you will likely want to use some form of delegation\nto bind the event.)</p>\n\n<p>Here is a Control with a custom event processor set and two callbacks bound\nto that event:</p>\n\n<pre><code class=\"lang-javascript\">can.Control.processors.birthday = function(el, ev, selector, callback, control) {\n  if(selector) {\n    myFramework.delegate(ev, el, selector, callback);\n    return function() { myFramework.undelegate(ev, el, selector, callback); };\n  } else {\n    myFramework.bind(ev, el, callback);\n    return function() { myFramework.unbind(ev, el, callback); };  \n  }\n};\n\ncan.Control(\"EventTarget\", { }, {\n  'birthday': function(el, ev) {\n    // do something appropriate for the occasion\n  },\n  '.grandchild birthday': function(el, ev) {\n    // do something appropriate for the occasion\n  }\n});\n\nvar target = new EventTarget('#person');</code></pre>\n\n<p>When <code>target</code> is initialized, can.Control will call <code>can.Control.processors.birthday</code>\ntwice (because there are two event hookups for the <em>birthday</em> event). The first\ntime it's called, the arguments will be:</p>\n\n<ul>\n<li><em>el</em>: A NodeList that wraps the element with id 'person'.</li>\n<li><em>ev</em>: <code>'birthday'</code></li>\n<li><em>selector</em>: <code>''</code></li>\n<li><em>callback</em>: The function assigned to <code>' birthday'</code> in the prototype section of <code>EventTarget</code>'s\ndefinition.</li>\n<li><em>control</em>: <code>target</code> itself.</li>\n</ul>\n\n<p>The second time, the arguments are slightly different:</p>\n\n<ul>\n<li><em>el</em>: A NodeList that wraps the element with id 'person'.</li>\n<li><em>ev</em>: <code>'birthday'</code></li>\n<li><em>selector</em>: <code>'.grandchild'</code></li>\n<li><em>callback</em>: The function assigned to <code>'.grandchild birthday'</code> in the prototype section of <code>EventTarget</code>'s\ndefinition.</li>\n<li><em>control</em>: <code>target</code> itself.</li>\n</ul>\n\n<p>can.Control already has processors for these events:</p>\n\n<ul>\n<li>change </li>\n<li>click </li>\n<li>contextmenu </li>\n<li>dblclick </li>\n<li>focusin</li>\n<li>focusout</li>\n<li>keydown </li>\n<li>keyup </li>\n<li>keypress </li>\n<li>mousedown </li>\n<li>mouseenter</li>\n<li>mouseleave</li>\n<li>mousemove </li>\n<li>mouseout </li>\n<li>mouseover </li>\n<li>mouseup </li>\n<li>reset </li>\n<li>resize </li>\n<li>scroll </li>\n<li>select </li>\n<li>submit  </li>\n</ul>",
                            "description": "<p>A collection of hookups for custom events on Controls. </p>",
                            "title": "processors",
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 165,
                            "id": 105
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.static._action",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "methodName",
                                    "description": "<p>the method that will be bound</p>"
                                }, {
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "options",
                                    "description": "<p>first param merged with class default options</p>"
                                }
                            ],
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "<p>Takes a method name and the options passed to a control\nand tries to return the data necessary to pass to a processor\n(something that binds things).</p>\n\n<p>For performance reasons, this called twice.  First, it is called when \nthe Control class is created.  If the methodName is templated\nlike: \"{window} foo\", it returns null.  If it is not templated\nit returns event binding data.</p>\n\n<p>The resulting data is added to this.actions.</p>\n\n<p>When a control instance is created, _action is called again, but only\non templated actions.  </p>",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p>null or the processor and pre-split parts. <br />\nThe processor is what does the binding/subscribing.</p>"
                            },
                            "src": "can/control/control.js",
                            "line": 112,
                            "id": 104
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.static._isAction",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "methodName",
                                    "description": "<p>a prototype function</p>"
                                }
                            ],
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "Boolean"
                                    }
                                ],
                                "description": "<p>truthy if an action or not</p>"
                            },
                            "src": "can/control/control.js",
                            "line": 93,
                            "id": 103
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.static.setup",
                            "params": [],
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "<p>Setup pre-process which methods are event listeners.</p>",
                            "hide": true,
                            "src": "can/control/control.js",
                            "line": 48,
                            "id": 102
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "body": "",
            "description": "<p><code>can.Deferred</code> is a object that allows users to assign and chain callback\nfunction(s) for the success or failure state of both asynchronous and synchronous function(s).</p>",
            "type": "constructor",
            "name": "can.Deferred",
            "title": "",
            "parent": "canjs",
            "signatures": [{
                    "code": "can.Deferred()",
                    "description": "",
                    "params": [],
                    "returns": {
                        "types": [{
                                "type": "can.Deferred"
                            }
                        ],
                        "description": "<p>A new Deferred object.</p>"
                    }
                }
            ],
            "src": "can/util/util.js",
            "line": 571,
            "id": 207,
            "children": [{
                    "active": false,
                    "body": "",
                    "description": "",
                    "type": "prototype",
                    "name": "can.Deferred.prototype",
                    "parent": "can.Deferred",
                    "src": "can/util/util.js",
                    "line": 582,
                    "id": 208,
                    "children": [{
                            "active": false,
                            "body": "<p><code>deferred.always( alwaysCallbacks )</code> adds handler(s) to be called when the Deferred object is either resolved or rejected.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.always( function(){\n    //- Called whether the handler fails or is success.\n});</code></pre>",
                            "description": "<p>Add a callback to be unconditionally called. </p>",
                            "title": "always",
                            "name": "can.Deferred.prototype.always",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "always(alwaysCallback)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "alwaysCallback",
                                            "description": "<p>A callback to be called whether the Deferred is resolved or rejected.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 679,
                            "id": 213
                        }, {
                            "active": false,
                            "body": "<p><code>deferred.done(doneCallback)</code> adds handler(s) to be called when the Deferred object is resolved.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.done(function(){\n    //- Deferred is done.\n});</code></pre>",
                            "description": "<p>Add a callback to be called when a Deferred is resolved. </p>",
                            "title": "done",
                            "name": "can.Deferred.prototype.done",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "done(doneCallback)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "doneCallback",
                                            "description": "<p>A callback to be called when the Deferred is resolved.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 644,
                            "id": 212
                        }, {
                            "active": false,
                            "body": "<p><code>deferred.isResolved()</code> returns whether a Deferred object has been resolved.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\nvar resolved = def.isResolved();</code></pre>",
                            "description": "<p>Determine whether a Deferred has been resolved. </p>",
                            "title": "isResolved",
                            "name": "can.Deferred.prototype.isResolved",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "isResolved()",
                                    "description": "",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Boolean"
                                            }
                                        ],
                                        "description": "<p>Whether this Boolean has been resolved.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 718,
                            "id": 215
                        }, {
                            "active": false,
                            "body": "<p><code>deferred.reject( args )</code> rejects the Deferred object and calls the fail callbacks with the given arguments.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.reject({ error: 'Thats not an animal.' })</code></pre>",
                            "description": "<p>Reject a Deferred. </p>",
                            "title": "reject",
                            "name": "can.Deferred.prototype.reject",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "reject([argument])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "argument",
                                            "description": "<p>The argument to call the <code>failCallback</code> with.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 748,
                            "id": 216
                        }, {
                            "active": false,
                            "body": "<p><code>deferred.rejectWith(context, arguments)</code> rejects a Deferred and calls the <code>failCallbacks</code> with the given arguments.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.rejectWith(this, { error: \"Animals are gone.\" })</code></pre>",
                            "description": "<p>Reject a Deferred in a particular context. </p>",
                            "title": "rejectWith",
                            "name": "can.Deferred.prototype.rejectWith",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "rejectWith(context[, arguments])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "context",
                                            "description": "<p>Context passed to the <code>failCallbacks</code> as the <code>this</code> object.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "arguments",
                                            "description": "<p>Array of arguments that are passed to the <code>failCallbacks</code>.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 627,
                            "id": 211
                        }, {
                            "active": false,
                            "body": "<p><code>deferred.resolveWith(context, arguments)</code> resolves a Deferred and calls the <code>doneCallbacks</code> with the given arguments.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.resolveWith(this, { animals: [ 'cows', 'monkey', 'panda' ] })</code></pre>",
                            "description": "<p>Resolve a Deferred in a particular context. </p>",
                            "title": "resolveWith",
                            "name": "can.Deferred.prototype.resolveWith",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "resolveWith(context[, arguments])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "context",
                                            "description": "<p>Context passed to the <code>doneCallbacks</code> as the <code>this</code> object.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "arguments",
                                            "description": "<p>Array of arguments that are passed to the <code>doneCallbacks</code>.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 610,
                            "id": 210
                        }, {
                            "active": false,
                            "body": "<p><code>deferred.then( doneCallback, failCallback )</code> adds handler(s) to be called when the Deferred object to be called after its resolved.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.then(function(){\n    //- Called when the deferred is resolved.\n}, function(){\n    //- Called when the deferred fails.\n})</code></pre>",
                            "description": "<p>Add callbacks to a Deferred. </p>",
                            "title": "then",
                            "name": "can.Deferred.prototype.then",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "then(doneCallback[, failCallback])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "doneCallback",
                                            "description": "<p>A function called when the Deferred is resolved.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "failCallback",
                                            "description": "<p>A function called when the Deferred is rejected.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 697,
                            "id": 214
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.EJS",
            "body": "<div class='iframe_wrapper' data-iframe-src='can/view/ejs/demo.html' data-iframe-height='1020'></div>",
            "description": "<p>EJS provides <strong>live</strong> ERB-style client-side templates. Use EJS \nwith [can.view] and for live templating use EJS with [can.Observe].</p>\n\n<h2>Basic Example</h2>\n\n<p>The following renders a Teacher's name and students into an element.  First, \ncreate a teacher template in a script tag like:</p>\n\n<pre><code>&lt;script type='text/ejs' id='teacherEJS'&gt;\n\n  &lt;h2 class='&lt;%= teacher.grade &lt; 'c'? \"good\" : \"bad\" %&gt;'&gt;\n    &lt;%= teacher.name %&gt;\n  &lt;/h2&gt;\n\n  &lt;ul&gt;\n    &lt;% for(var i =0; i&lt; teacher.students.length; i++){ %&gt;\n      &lt;li&gt;&lt;%= teacher.students[i].name %&gt;&lt;/li&gt;\n    &lt;% } %&gt;\n  &lt;/ul&gt;\n\n&lt;/script&gt;\n</code></pre>\n\n<p>Notice the magic tags?  Those are things that look like <code>&lt;% %&gt;</code> and \n<code>&lt;%= %&gt;</code>.  Code between <code>&lt;% %&gt;</code> is run and the return value of code\nbetween <code>&lt;%= %&gt;</code> is inserted into the page.</p>\n\n<p>Next, create a teacher and use can.view to render the template:</p>\n\n<pre><code>var teacher = {\n  name : \"Mr. Smith\",\n  grade : \"a\",\n  students : [\n    {name : \"Suzy\"},\n    {name : \"Payal\"},\n    {name : \"Curtis\"},\n    {name : \"Alexis\"}\n  ]\n};\n\ndocument.getElementById('teacher')\n  .appendChild( can.view(\"teacherEjs\", teacher) )\n</code></pre>\n\n<p>This results in HTML like:</p>\n\n<pre><code>&lt;div id='teachers'&gt;\n  &lt;h2 class='good'&gt;\n    Mr. Smith\n  &lt;/h2&gt;\n\n  &lt;ul&gt;\n     &lt;li&gt;Suzy&lt;/li&gt;\n     &lt;li&gt;Payal&lt;/li&gt;\n     &lt;li&gt;Curtis&lt;/li&gt;\n     &lt;li&gt;Alexis&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>This is nice, but what if we change properties of the teacher?</p>\n\n<h2>Basic Live Binding Example</h2>\n\n<p>EJS sets up live templating binding when a [can.Observe]'s properties are read \nvia [can.Observe::attr attr] within a magic tag.  To make this template\nrespond to changes in the teacher data, first rewrite the template\nto use the attr method to read properties and <code>list( observeList, cb(item, i) )</code>\nto iterate through a list like:</p>\n\n<pre><code>&lt;script type='text/ejs' id='teacherEJS'&gt;\n\n  &lt;h2 class='&lt;%= teacher.attr('grade') &lt; 'c'? \"good\" : \"bad\" %&gt;'&gt;\n    &lt;%= teacher.attr('name') %&gt;\n  &lt;/h2&gt;\n\n  &lt;ul&gt;\n    &lt;% list(teacher.students, function(student){ %&gt;\n      &lt;li&gt;&lt;%= student.attr('name') %&gt;&lt;/li&gt;\n    &lt;% }) %&gt;\n  &lt;/ul&gt;\n\n&lt;/script&gt;\n</code></pre>\n\n<p><strong>Note:</strong> The end of this page discusses why using <code>list</code> is \nhelpful, but it does nothing fancy.</p>\n\n<p>Next, turn your teacher into a <code>new can.Observe(object)</code> and pass\nthat to <code>can.view</code>:</p>\n\n<pre><code>var teacher = can.Observe({\n  name : \"Mr. Smith\",\n  grade : \"a\"\n  students : [\n    {name : \"Suzy\"},\n    {name : \"Payal\"},\n    {name : \"Curtis\"},\n    {name : \"Alexis\"}\n  ]\n});\n\ndocument.getElementById('teacher')\n  .appendChild( can.view(\"teacherEjs\", teacher) );\n</code></pre>\n\n<p>Finally, update some properties of teacher and slap your \nhead with disbelief ...</p>\n\n<pre><code>teacher.attr('name',\"Prof. Snape\")\nteacher.attr('grade','f+')\nteacher.attr('students').push({\n  name : \"Harry Potter\"\n})\n</code></pre>\n\n<p>... but don't slap it too hard, you'll need it for building awesome apps.</p>\n\n<h2>Demo</h2>\n\n<p>The following demo shows an EJS template being rendered with observable data. \nIt demonstrates live binding to attributes. The template and all data properties \nare editable, so experiment!</p>\n\n<h2>Magic Tags</h2>\n\n<p>EJS uses 5 types of tags:</p>\n\n<p><strong><code>&lt;% CODE %&gt;</code></strong> - Runs JS Code.</p>\n\n<p>This type of magic tag does not modify the template but is used for JS control statements \nlike for-loops, if/else, switch, etc.  Some examples:</p>\n\n<pre><code>&lt;% if( items.attr('length') === 0 ) { %&gt;\n    &lt;tr&gt;&lt;td&gt;You have no items&lt;/td&gt;&lt;/tr&gt;\n&lt;% } else { %&gt;\n    &lt;% list(items, function(){ %&gt;\n      &lt;tr&gt; .... &lt;/tr&gt;\n    &lt;% }) %&gt;\n&lt;% } %&gt;\n\n\n&lt;% var address = person.attr('address') %&gt;\n&lt;span&gt;&lt;%= address.attr('street') %&gt;&lt;span&gt;\n</code></pre>\n\n<p><strong><code>&lt;%= CODE %&gt;</code></strong> - Runs JS Code and writes the <em>escaped</em> result into the result of the template.</p>\n\n<p>The following results in the user seeing \"my favorite element is &lt;blink>BLINK&lt;blink>\" and not\n<blink>BLINK</blink>.</p>\n\n<pre><code> &lt;div&gt;my favorite element is &lt;%= '&lt;blink&gt;BLINK&lt;/blink&gt;' %&gt;.&lt;/div&gt;\n</code></pre>\n\n<p><strong><code>&lt;%== CODE %&gt;</code></strong>  - Runs JS Code and writes the <em>unescaped</em> result into the result of the template.</p>\n\n<p>The following results in \"my favorite element is <B>B</B>.\". Using <code>&lt;%==</code> is useful\nfor sub-templates.</p>\n\n<pre><code>     &lt;div&gt;my favorite element is &lt;%== '&lt;B&gt;B&lt;/B&gt;' %&gt;.&lt;/div&gt;\n</code></pre>\n\n<p><strong><code>&lt;%% CODE %&gt;</code></strong> - Writes &lt;% CODE %> to the result of the template.  This is very useful for generators.</p>\n\n<pre><code>     &lt;%%= 'hello world' %&gt;\n</code></pre>\n\n<p><strong><code>&lt;%# CODE %&gt;</code></strong>  - Used for comments.  This does nothing.</p>\n\n<pre><code>     &lt;%# 'hello world' %&gt;\n</code></pre>\n\n<h2>Live Binding</h2>\n\n<p>EJS allows live binding by wrapping magic tag content within a function. When <code>attr()</code> is called \nto update an observable object, these functions are executed to return the new value.</p>\n\n<pre><code>// Suppose an observable \"foo\":\n\nvar foo = can.Observe({\n  count: '0'\n});\n\n// Suppose also, the above observable is passed to our view:\n\n&lt;%= foo.attr('bar') %&gt;\n\n// EJS locates the magic tag and turns the above into:\n\nfunction() { return foo.attr('bar'); }\n\n// As \"foo\" is updated using attr(), this function is called again to\n// render the view with the new value.\n</code></pre>\n\n<p>This means that each function tag has a closure will reference variables in it's \nparent functions. This can cause problems if you don't understand closures in \nJavaScript. For example, the following binding does not work:</p>\n\n<pre><code>&lt;% for(var i =0; i &lt; items.attr('length'); i++){ %&gt;\n  &lt;li&gt;&lt;%= items[i].attr('name') %&gt;&lt;/li&gt;\n&lt;% } %&gt;\n</code></pre>\n\n<p>This is because it gets turned into:</p>\n\n<pre><code>&lt;% for(var i =0; i &lt; items.attr('length'); i++){ %&gt;\n  LIVEBIND( function() { return items[i].attr('name') )\n&lt;% } %&gt;\n</code></pre>\n\n<p>When the wrapping function is called again, <code>i</code> will \nnot be the index of the item, but instead be items.length.</p>\n\n<p>The [can.EJS.Helpers::view view]<code>(observeList,function(item,index,list){})</code> method in EJS should be used to iterate through observe lists:</p>\n\n<pre><code>&lt;% list(items, function(item){ %&gt;\n  &lt;li&gt;&lt;%= item.attr('name') %&gt;&lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<h2>Advanced Live Binding</h2>\n\n<p>Once you get the hang of how EJS works, it makes live-binding of complex\ncalculations possible.  The following extends a [can.Model.List] to suppot a <code>completed</code> method that\nreturns the total number of completed items in the list.  It can be used in a template like:</p>\n\n<pre><code>&lt;h2&gt;&lt;%= todos.complete() %&gt; Complete Todos &lt;/h2&gt;\n</code></pre>\n\n<p>And implemented like:</p>\n\n<pre><code>Todo.List = can.Model.List({\n  completed: function() {\n    var count = 0;\n\n    this.attr('length');\n    this.each(function(i, todo) {\n      if(this.attr('completed')) {\n        count++;\n      }\n    });\n\n    return count;\n  }\n});\n</code></pre>\n\n<p><code>completed</code> listens on changes to the list (via <code>this.attr('length')</code>) and \neach item's <code>'completed'</code> property.  EJS keeps track of which observe/attribute pairs are called\nby <code>.complete()</code>.  If they change, EJS will automatically unbind.</p>\n\n<p>Adding a \"completed\" helper function to the todo model list to return the number of completed todos:</p>\n\n<p><strong>Note:</strong> The object passed into the view becomes \"this\" within the view template.</p>\n\n<pre><code>var todos = Todo.findAll({}); //returns a can.Model.List\ncan.view('//todo/views/init.ejs', todos)\n</code></pre>",
            "title": "",
            "parent": "canjs",
            "src": "can/view/ejs/ejs.md",
            "id": 144,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.EJS.prototype",
                    "parent": "can.EJS",
                    "src": "can/view/ejs/ejs.js",
                    "line": 31,
                    "id": 145,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.EJS.prototype.render",
                            "parent": "can.EJS.prototype",
                            "body": "<p>Renders an object with view helpers attached to the view.</p>\n\n<pre><code>new can.EJS({text: \"&lt;%= message %&gt;\"}).render({\n  message: \"foo\"\n},{helper: function(){ ... }})\n</code></pre>",
                            "description": "<p>Render a view object with data and helpers. </p>",
                            "title": "render",
                            "signatures": [{
                                    "code": "render(data[, helpers])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "data",
                                            "description": "<p>The data to populate the template with.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object",
                                                    "template": [{
                                                            "types": [{
                                                                    "type": "String"
                                                                }
                                                            ]
                                                        }, {
                                                            "types": [{
                                                                    "type": "function",
                                                                    "returns": {
                                                                        "types": [{
                                                                                "type": "undefined"
                                                                            }
                                                                        ]
                                                                    },
                                                                    "params": []
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "optional": true,
                                            "name": "helpers",
                                            "description": "<p>Helper methods referenced in the template.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "String"
                                            }
                                        ],
                                        "description": "<p>The template with interpolated data.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/view/ejs/ejs.js",
                            "line": 36,
                            "id": 146
                        }, {
                            "active": false,
                            "name": "can.EJS.prototype.scanner",
                            "type": "property",
                            "parent": "can.EJS.prototype",
                            "body": "",
                            "description": "<p>Singleton scanner instance for parsing templates.</p>",
                            "hide": true,
                            "src": "can/view/ejs/ejs.js",
                            "line": 58,
                            "id": 147
                        }, {
                            "active": false,
                            "name": "can.EJS.prototype.tokens",
                            "type": "property",
                            "parent": "can.EJS.prototype",
                            "body": "",
                            "description": "<p>An ordered token registry for the scanner.\nThis needs to be ordered by priority to prevent token parsing errors.\nEach token is defined as: [\"token-name\", \"string representation\", \"optional regexp override\"]</p>",
                            "hide": true,
                            "src": "can/view/ejs/ejs.js",
                            "line": 63,
                            "id": 148
                        }
                    ]
                }, {
                    "active": false,
                    "type": "constructor",
                    "name": "can.EJS.static",
                    "params": [{
                            "name": "data",
                            "description": ""
                        }, {
                            "name": "extras",
                            "description": ""
                        }
                    ],
                    "parent": "can.EJS",
                    "body": "",
                    "description": "",
                    "src": "can/view/ejs/ejs.js",
                    "line": 82,
                    "id": 149,
                    "children": [{
                            "active": false,
                            "name": "can.EJS.Helpers",
                            "type": "page",
                            "parent": "can.EJS.static",
                            "body": "<p>By adding functions to can.EJS.Helpers.prototype, those functions will be available in the\nviews.</p>\n\n<p>The following helper converts a given string to upper case:</p>\n\n<pre><code>can.EJS.Helpers.prototype.toUpper = function(params)\n{\n    return params.toUpperCase();\n}\n</code></pre>\n\n<p>Use it like this in any EJS template:</p>\n\n<pre><code>&lt;%= toUpper('javascriptmvc') %&gt;\n</code></pre>\n\n<p>To access the current DOM element return a function that takes the element as a parameter:</p>\n\n<pre><code>can.EJS.Helpers.prototype.upperHtml = function(params)\n{\n    return function(el) {\n        $(el).html(params.toUpperCase());\n    }\n}\n</code></pre>\n\n<p>In your EJS view you can then call the helper on an element tag:</p>\n\n<pre><code>&lt;div &lt;%= upperHtml('javascriptmvc') %&gt;&gt;&lt;/div&gt;\n</code></pre>",
                            "description": "",
                            "title": "Helpers",
                            "comment": " ",
                            "src": "can/view/ejs/ejs.js",
                            "line": 94,
                            "id": 150
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.Model",
            "body": "",
            "description": "",
            "title": "",
            "parent": "canjs",
            "download": "can/model",
            "test": "can/model/qunit.html",
            "signatures": [{
                    "code": "can.Model([name,] staticProperties, instanceProperties)",
                    "description": "<p>Creates a can.Model class constructor. (See [can.Construct] for more details on this syntax.)</p>",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "optional": true,
                            "name": "name",
                            "description": "<p>If given, this will be the globally-available name of the constructor function.</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "staticProperties",
                            "description": "<p>The static properties of the class. See below for properties with\nspecial meanings to <code>can.Model</code>.</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "instanceProperties",
                            "description": "<p>The instance properties of instances of the class. These will usually\nbe functions.</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "description": "<p>A can.Model constructor.</p>"
                    }
                }, {
                    "code": "new ModelConstructor([options])",
                    "description": "<p>Creates a new instance of <em>ModelConstructor</em>.</p>",
                    "params": [{
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "options",
                            "description": "<p>Options to pass to <code>setup</code> or <code>init</code>.</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.Model"
                            }
                        ],
                        "description": "<p>A new instance of <em>ModelConstructor</em>.</p>"
                    }
                }
            ],
            "comment": " ",
            "src": "can/model/model.md",
            "id": 78,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Model.prototype",
                    "parent": "can.Model",
                    "src": "can/model/model.js",
                    "line": 875,
                    "id": 90,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.bind",
                            "parent": "can.Model.prototype",
                            "body": "<p><code>bind(eventName, handler(ev, args...) )</code> is used to listen\nto events on this model instance.  Example:</p>\n\n<pre><code>Task = can.Model()\nvar task = new Task({name : \"dishes\"})\ntask.bind(\"name\", function(ev, newVal, oldVal){})\n</code></pre>\n\n<p>Use <code>bind</code> the\nsame as [can.Observe::bind] which should be used as\na reference for listening to property changes.</p>\n\n<p>Bind on model can be used to listen to when \nan instance is:</p>\n\n<ul>\n<li>created</li>\n<li>updated</li>\n<li>destroyed</li>\n</ul>\n\n<p>like:</p>\n\n<pre><code>Task = can.Model()\nvar task = new Task({name : \"dishes\"})\n\ntask.bind(\"created\", function(ev, newTask){\n     console.log(\"created\", newTask)\n})\n.bind(\"updated\", function(ev, updatedTask){\n  console.log(\"updated\", updatedTask)\n})\n.bind(\"destroyed\", function(ev, destroyedTask){\n     console.log(\"destroyed\", destroyedTask)\n})\n\n// create, update, and destroy\ntask.save(function(){\n  task.attr('name', \"do dishes\")\n      .save(function(){\n            task.destroy()\n      })\n}); \n</code></pre>\n\n<p><code>bind</code> also extends the inherited \nbehavior of [can.Observe::bind] to track the number\nof event bindings on this object which is used to store\nthe model instance.  When there are no bindings, the \nmodel instance is removed from the store, freeing memory.  </p>",
                            "description": "<p>Listen to events on this Model. </p>",
                            "title": "bind",
                            "signatures": [{
                                    "code": "bind(eventName, handler)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventName",
                                            "description": "<p>The event to bind to.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "handler",
                                            "description": "<p>The function to call when the\nevent occurs. <strong>handler</strong> is passed the event and the\nModel instance.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>The Model, for chaining.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 1013,
                            "id": 94
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.destroy",
                            "parent": "can.Model.prototype",
                            "body": "<p>Destroys the instance by calling \n[Can.Model.destroy] with the id of the instance.</p>\n\n<pre><code>recipe.destroy(success, error);\n</code></pre>\n\n<p>This triggers \"destroyed\" events on the instance and the \nModel constructor function which can be listened to with\n[can.Model::bind] and [can.Model.bind]. </p>\n\n<pre><code>Recipe = can.Model({\n  destroy : \"DELETE /services/recipes/{id}\",\n  findOne : \"/services/recipes/{id}\"\n},{})\n\nRecipe.bind(\"destroyed\", function(){\n  console.log(\"a recipe destroyed\");    \n});\n\n// get a recipe\nRecipe.findOne({id: 5}, function(recipe){\n  recipe.bind(\"destroyed\", function(){\n    console.log(\"this recipe destroyed\")    \n  })\n  recipe.destroy();\n})\n</code></pre>",
                            "description": "<p>Destroy a Model on the server. </p>",
                            "title": "destroy",
                            "signatures": [{
                                    "code": "destroy([success[, error]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "success",
                                            "description": "<p>A callback to call on successful destruction. The callback recieves\nthe can.Model as it was just prior to destruction.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "error",
                                            "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the Model as it was before destruction.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 967,
                            "id": 93
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.isNew",
                            "parent": "can.Model.prototype",
                            "body": "<p><code>isNew()</code> returns if the instance is has been created \non the server. This is essentially if the [can.Model.id]\nproperty is null or undefined.</p>\n\n<pre><code>new Recipe({id: 1}).isNew() //-&gt; false\n</code></pre>",
                            "description": "<p>Check if a Model has yet to be saved on the server. </p>",
                            "title": "isNew",
                            "signatures": [{
                                    "code": "isNew()",
                                    "description": "",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Boolean"
                                            }
                                        ],
                                        "description": "<p>Whether an instance has been saved on the server.\n(This is determined by whether <code>id</code> has a value set yet.)</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 879,
                            "id": 91
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.save",
                            "parent": "can.Model.prototype",
                            "body": "<p><code>model.save([success(model)],[error(xhr)])</code> creates or updates \nthe model instance using [can.Model.create] or\n[can.Model.update] depending if the instance\n[can.Model::isNew has an id or not].</p>\n\n<h2>Using <code>save</code> to create an instance.</h2>\n\n<p>If <code>save</code> is called on an instance that does not have \nan [can.Model.id id] property, it calls [can.Model.create]\nwith the instance's properties.  It also [can.trigger triggers]\na \"created\" event on the instance and the model.</p>\n\n<pre><code>// create a model instance\nvar todo = new Todo({name: \"dishes\"})\n\n// listen when the instance is created\ntodo.bind(\"created\", function(ev){\n     this //-&gt; todo\n})\n\n// save it on the server\ntodo.save(function(todo){\n     console.log(\"todo\", todo, \"created\")\n});\n</code></pre>\n\n<h2>Using <code>save</code> to update an instance.</h2>\n\n<p>If save is called on an instance that has \nan [can.Model.id id] property, it calls [can.Model.create]\nwith the instance's properties.  When the save is complete,\nit triggers an \"updated\" event on the instance and the instance's model.</p>\n\n<p>Instances with an\n<strong>id</strong> are typically retrieved with [can.Model.findAll] or\n[can.Model.findOne].  </p>\n\n<pre><code>// get a created model instance\nTodo.findOne({id: 5},function(todo){\n\n  // listen when the instance is updated\n  todo.bind(\"updated\", function(ev){\n       this //-&gt; todo\n  })\n\n  // update the instance's property\n  todo.attr(\"complete\", true)\n\n  // save it on the server\n  todo.save(function(todo){\n       console.log(\"todo\", todo, \"updated\")\n  });\n\n});\n</code></pre>",
                            "description": "<p>Save a model back to the server. </p>",
                            "title": "save",
                            "signatures": [{
                                    "code": "save([success[, error]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "success",
                                            "description": "<p>A callback to call on successful save. The callback recieves\nthe can.Model after saving.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "error",
                                            "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the Model after it has been saved.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 897,
                            "id": 92
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.unbind",
                            "parent": "can.Model.prototype",
                            "body": "<p><code>unbind(eventName, handler)</code> removes a listener\nattached with [can.Model::bind].</p>\n\n<pre><code>var handler = function(ev, createdTask){\n\n}\ntask.bind(\"created\", handler)\ntask.unbind(\"created\", handler)\n</code></pre>\n\n<p>You have to pass the same function to <code>unbind</code> that you\npassed to <code>bind</code>.</p>\n\n<p>Unbind will also remove the instance from the store\nif there are no other listeners.</p>",
                            "description": "<p>Stop listening to events on this Model. </p>",
                            "title": "unbind",
                            "signatures": [{
                                    "code": "unbind(eventName[, handler])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventName",
                                            "description": "<p>The event to unbind from.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "handler",
                                            "description": "<p>A handler previously bound with <code>bind</code>.\nIf <strong>handler</strong> is not passed, <code>unbind</code> will remove all handlers\nfor the given event.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>The Model, for chaining.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 1076,
                            "id": 95
                        }
                    ]
                }, {
                    "active": false,
                    "body": "",
                    "description": "",
                    "type": "static",
                    "name": "can.Model.static",
                    "parent": "can.Model",
                    "src": "can/model/model.js",
                    "line": 118,
                    "id": 79,
                    "children": [{
                            "active": false,
                            "body": "<p><code>bind(eventType, handler(event, instance))</code> listens to\n<strong>created</strong>, <strong>updated</strong>, <strong>destroyed</strong> events on all \ninstances of the model.</p>\n\n<pre><code>Task.bind(\"created\", function(ev, createdTask){\n     this //-&gt; Task\n  createdTask.attr(\"name\") //-&gt; \"Dishes\"\n})\n\nnew Task({name: \"Dishes\"}).save();\n</code></pre>",
                            "description": "<p>Listen for events on a Model class. </p>",
                            "title": "bind",
                            "name": "can.Model.bind",
                            "type": "function",
                            "parent": "can.Model.static",
                            "signatures": [{
                                    "code": "bind(eventType, handler)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventType",
                                            "description": "<p>The type of event.  It must be\n<code>\"created\"</code>, <code>\"udpated\"</code>, <code>\"destroyed\"</code>.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "handler",
                                            "description": "<p>A callback function\nthat gets called with the event and instance that was\ncreated, destroyed, or updated.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>The model constructor function.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 122,
                            "id": 80
                        }, {
                            "active": false,
                            "name": "can.Model.create",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>create(attributes) -&gt; Deferred</code> is used by [can.Model::save save] to create a \nmodel instance on the server. </p>\n\n<h2>Implement with a URL</h2>\n\n<p>The easiest way to implement create is to give it the url \nto post data to:</p>\n\n<pre><code>var Recipe = can.Model({\n  create: \"/recipes\"\n},{})\n</code></pre>\n\n<p>This lets you create a recipe like:</p>\n\n<pre><code>new Recipe({name: \"hot dog\"}).save();\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>You can also implement create by yourself. Create gets called \nwith <code>attrs</code>, which are the [can.Observe::serialize serialized] model \nattributes.  Create returns a <code>Deferred</code> \nthat contains the id of the new instance and any other \nproperties that should be set on the instance.</p>\n\n<p>For example, the following code makes a request \nto <code>POST /recipes.json {'name': 'hot+dog'}</code> and gets back\nsomething that looks like:</p>\n\n<pre><code>{ \n  \"id\": 5,\n  \"createdAt\": 2234234329\n}\n</code></pre>\n\n<p>The code looks like:</p>\n\n<pre><code>can.Model(\"Recipe\", {\n  create : function( attrs ){\n    return $.post(\"/recipes.json\",attrs, undefined ,\"json\");\n  }\n},{})\n</code></pre>",
                            "description": "<p>Create a new resource on the server. </p>",
                            "title": "create",
                            "signatures": [{
                                    "code": "[METHOD] /path/to/resource",
                                    "description": "<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or POST if none is specified) when saving a\nnew instance on the server. (See below for more details.)</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the created model.</p>"
                                    }
                                }, {
                                    "code": "function(serialized)",
                                    "description": "<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "serialized",
                                            "description": "<p>The [can.Observe::serialize serialized] properties of\nthe model to create.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the created model.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 209,
                            "id": 83
                        }, {
                            "active": false,
                            "name": "can.Model.destroy",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>destroy(id) -&gt; Deferred</code> is used by [can.Model::destroy] remove a model \ninstance from the server.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>You can implement destroy with a string like:</p>\n\n<pre><code>Recipe = can.Model({\n  destroy : \"/recipe/{id}\"\n},{})\n</code></pre>\n\n<p>And use [can.Model::destroy] to destroy it like:</p>\n\n<pre><code>Recipe.findOne({id: 1}, function(recipe){\n      recipe.destroy();\n});\n</code></pre>\n\n<p>This sends a <code>DELETE</code> request to <code>/thing/destroy/1</code>.</p>\n\n<p>If your server does not support <code>DELETE</code> you can override it like:</p>\n\n<pre><code>Recipe = can.Model({\n  destroy : \"POST /recipe/destroy/{id}\"\n},{})\n</code></pre>\n\n<h2>Implement with a function</h2>\n\n<p>Implement destroy with a function like:</p>\n\n<pre><code>Recipe = can.Model({\n  destroy : function(id){\n    return $.post(\"/recipe/destroy/\"+id,{});\n  }\n},{})\n</code></pre>\n\n<p>Destroy just needs to return a deferred that resolves.</p>",
                            "description": "<p>Destroy a resource on the server. </p>",
                            "title": "destroy",
                            "signatures": [{
                                    "code": "[METHOD] /path/to/resource",
                                    "description": "<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or DELETE if none is specified) when deleting an\ninstance on the server. (See below for more details.)</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the destroyed model.</p>"
                                    }
                                }, {
                                    "code": "function(id)",
                                    "description": "<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "id",
                                            "description": "<p>The ID of the resource to destroy.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the destroyed model.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 364,
                            "id": 85
                        }, {
                            "active": false,
                            "name": "can.Model.findAll",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>findAll( params, success(instances), error(xhr) ) -&gt; Deferred</code> is used to retrieve model \ninstances from the server. Before you can use <code>findAll</code>, you must implement it.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>Implement findAll with a url like:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : \"/recipes.json\"\n},{});\n</code></pre>\n\n<p>The server should return data that looks like:</p>\n\n<pre><code>[\n  {\"id\" : 57, \"name\": \"Ice Water\"},\n  {\"id\" : 58, \"name\": \"Toast\"}\n]\n</code></pre>\n\n<h2>Implement with an Object</h2>\n\n<p>Implement findAll with an object that specifies the parameters to\n<code>can.ajax</code> (jQuery.ajax) like:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : {\n    url: \"/recipes.xml\",\n    dataType: \"xml\"\n  }\n},{})\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>To implement with a function, <code>findAll</code> is passed <strong>params</strong> to filter\nthe instances retrieved from the server and it should return a\ndeferred that resolves to an array of model data. For example:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : function(params){\n    return $.ajax({\n      url: '/recipes.json',\n      type: 'get',\n      dataType: 'json'})\n  }\n},{})\n</code></pre>\n\n<h2>Use</h2>\n\n<p>After implementing <code>findAll</code>, you can use it to retrieve instances of the model\nlike:</p>\n\n<pre><code>Recipe.findAll({favorite: true}, function(recipes){\n  recipes[0].attr('name') //-&gt; \"Ice Water\"\n}, function( xhr ){\n  // called if an error\n}) //-&gt; Deferred\n</code></pre>",
                            "description": "<p>Retrieve multiple resources from a server. </p>",
                            "title": "findAll",
                            "signatures": [{
                                    "code": "findAll(params[, success[, error]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "params",
                                            "description": "<p>Values to filter the request or results with.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "success",
                                            "description": "<p>A callback to call on successful retrieval. The callback recieves\na can.Model.List of the retrieved resources.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "error",
                                            "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A deferred that resolves to a [can.Model.List] of retrieved models.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 425,
                            "id": 86
                        }, {
                            "active": false,
                            "name": "can.Model.findOne",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>findOne( params, success(instance), error(xhr) ) -&gt; Deferred</code> is used to retrieve a model \ninstance from the server. Before you can use <code>findOne</code>, you must implement it.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>Implement findAll with a url like:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : \"/recipes/{id}.json\"\n},{});\n</code></pre>\n\n<p>If <code>findOne</code> is called like:</p>\n\n<pre><code>Recipe.findOne({id: 57});\n</code></pre>\n\n<p>The server should return data that looks like:</p>\n\n<pre><code>{\"id\" : 57, \"name\": \"Ice Water\"}\n</code></pre>\n\n<h2>Implement with an Object</h2>\n\n<p>Implement <code>findOne</code> with an object that specifies the parameters to\n<code>can.ajax</code> (jQuery.ajax) like:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : {\n    url: \"/recipes/{id}.xml\",\n    dataType: \"xml\"\n  }\n},{})\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>To implement with a function, <code>findOne</code> is passed <strong>params</strong> to specify\nthe instance retrieved from the server and it should return a\ndeferred that resolves to the model data.  Also notice that you now need to\nbuild the URL manually. For example:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : function(params){\n    return $.ajax({\n      url: '/recipes/' + params.id,\n      type: 'get',\n      dataType: 'json'})\n  }\n},{})\n</code></pre>\n\n<h2>Use</h2>\n\n<p>After implementing <code>findOne</code>, you can use it to retrieve an instance of the model\nlike:</p>\n\n<pre><code>Recipe.findOne({id: 57}, function(recipe){\n     recipe.attr('name') //-&gt; \"Ice Water\"\n}, function( xhr ){\n     // called if an error\n}) //-&gt; Deferred\n</code></pre>",
                            "description": "<p>Retrieve a resource from a server. </p>",
                            "title": "findOne",
                            "signatures": [{
                                    "code": "findOne(params[, success[, error]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "params",
                                            "description": "<p>Values to filter the request or results with.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "success",
                                            "description": "<p>A callback to call on successful retrieval. The callback recieves\nthe retrieved resource as a can.Model.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "error",
                                            "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A deferred that resolves to a [can.Model.List] of retrieved models.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 498,
                            "id": 87
                        }, {
                            "active": false,
                            "body": "",
                            "description": "<p>The name of the id field.  Defaults to <code>'id'</code>. Change this if it is something different.</p>\n\n<p>For example, it's common in .NET to use <code>'Id'</code>.  Your model might look like:</p>\n\n<pre><code>Friend = can.Model({\n  id: \"Id\"\n},{});\n</code></pre>",
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "title": "id",
                            "name": "can.Model.id",
                            "type": "property",
                            "parent": "can.Model.static",
                            "src": "can/model/model.js",
                            "line": 174,
                            "id": 82
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.model",
                            "parent": "can.Model.static",
                            "body": "<p><code>can.Model.model(attributes)</code> is used to convert data from the server into\na model instance.  It is rarely called directly.  Instead it is invoked as \na result of [can.Model.findOne] or [can.Model.findAll].  </p>\n\n<p>If your server is returning data in non-standard way,\noverwriting <code>can.Model.model</code> is a good way to normalize it.</p>\n\n<h2>Example</h2>\n\n<p>The following uses <code>model</code> to convert to a model\ninstance.</p>\n\n<pre><code>Task = can.Model({},{})\nvar task = Task.model({id: 1, name : \"dishes\", complete : false})\n\ntasks.attr(\"complete\", true)\n</code></pre>\n\n<p><code>Task.model(attrs)</code> is very similar to simply calling <code>new Model(attrs)</code> except\nthat it checks the model's store if the instance has already been created.  The model's \nstore is a collection of instances that have event handlers.  </p>\n\n<p>This means that if the model's store already has an instance, you'll get the same instance\nback.  Example:</p>\n\n<pre><code>// create a task\nvar taskA = new Task({id: 5, complete: true});\n\n// bind to it, which puts it in the store\n   taskA.bind(\"complete\", function(){});\n\n// use model to create / retrieve a task\nvar taskB = Task.model({id: 5, complete: true});\n\ntaskA === taskB //-&gt; true\n</code></pre>\n\n<h2>Non-standard Services</h2>\n\n<p><code>can.Model.model</code> expects to retreive attributes of the model \ninstance like:</p>\n\n<pre><code>{id: 5, name : \"dishes\"}\n</code></pre>\n\n<p>If the service returns data formatted differently, like:</p>\n\n<pre><code>{todo: {name: \"dishes\", id: 5}}\n</code></pre>\n\n<p>Overwrite <code>model</code> like:</p>\n\n<pre><code>Task = can.Model({\n  model : function(data){\n    return can.Model.model.call(this,data.todo);\n  }\n},{});\n</code></pre>",
                            "description": "<p>Convert raw data into a can.Model instance. </p>",
                            "title": "model",
                            "signatures": [{
                                    "code": "model(data)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "data",
                                            "description": "<p>The data to convert to a can.Model instance.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>An instance of can.Model made with the given data.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 794,
                            "id": 89
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.models",
                            "parent": "can.Model.static",
                            "body": "<p><code>can.Model.models(data, xhr)</code> is used to \nconvert the raw response of a [can.Model.findAll] request \ninto a [can.Model.List] of model instances.  </p>\n\n<p>This method is rarely called directly. Instead the deferred returned\nby findAll is piped into <code>models</code>.  This creates a new deferred that\nresolves to a [can.Model.List] of instances instead of an array of\nsimple JS objects.</p>\n\n<p>If your server is returning data in non-standard way,\noverwriting <code>can.Model.models</code> is the best way to normalize it.</p>\n\n<h2>Quick Example</h2>\n\n<p>The following uses models to convert to a [can.Model.List] of model\ninstances.</p>\n\n<pre><code>Task = can.Model({},{})\nvar tasks = Task.models([\n  {id: 1, name : \"dishes\", complete : false},\n  {id: 2, name: \"laundry\", compelte: true}\n])\n\ntasks.attr(\"0.complete\", true)\n</code></pre>\n\n<h2>Non-standard Services</h2>\n\n<p><code>can.Model.models</code> expects data to be an array of name-value pair \nobjects like:</p>\n\n<pre><code>[{id: 1, name : \"dishes\"},{id:2, name: \"laundry\"}, ...]\n</code></pre>\n\n<p>It can also take an object with additional data about the array like:</p>\n\n<pre><code>{\n  count: 15000 //how many total items there might be\n  data: [{id: 1, name : \"justin\"},{id:2, name: \"brian\"}, ...]\n}\n</code></pre>\n\n<p>In this case, models will return a [can.Model.List] of instances found in \ndata, but with additional properties as expandos on the list:</p>\n\n<pre><code>var tasks = Task.models({\n  count : 1500,\n  data : [{id: 1, name: 'dishes'}, ...]\n})\ntasks.attr(\"name\") // -&gt; 'dishes'\ntasks.count // -&gt; 1500\n</code></pre>\n\n<h3>Overwriting Models</h3>\n\n<p>If your service returns data like:</p>\n\n<pre><code>{thingsToDo: [{name: \"dishes\", id: 5}]}\n</code></pre>\n\n<p>You will want to overwrite models to pass the base models what it expects like:</p>\n\n<pre><code>Task = can.Model({\n  models : function(data){\n    return can.Model.models.call(this,data.thingsToDo);\n  }\n},{})\n</code></pre>\n\n<p><code>can.Model.models</code> passes each intstance's data to <code>can.Model.model</code> to\ncreate the individual instances.</p>",
                            "description": "<p>Convert raw data into can.Model instances. </p>",
                            "title": "models",
                            "signatures": [{
                                    "code": "models(data[, oldList])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Array",
                                                    "template": [{
                                                            "types": [{
                                                                    "type": "Object"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "name": "data",
                                            "description": "<p>The raw data from a <code>[can.Model.findAll findAll()]</code> request.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "can.Model.List"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "oldList",
                                            "description": "<p>If supplied, this List will be updated with the data from\n<strong>data</strong>.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model.List"
                                            }
                                        ],
                                        "description": "<p>A List of Models made from the raw data.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 655,
                            "id": 88
                        }, {
                            "active": false,
                            "body": "<p><code>unbind(eventType, handler)</code> removes a listener\nattached with [can.Model.bind].</p>\n\n<pre><code>var handler = function(ev, createdTask){\n\n}\nTask.bind(\"created\", handler)\nTask.unbind(\"created\", handler)\n</code></pre>\n\n<p>You have to pass the same function to <code>unbind</code> that you\npassed to <code>bind</code>.</p>",
                            "description": "<p>Stop listening for events on a Model class. </p>",
                            "title": "unbind",
                            "name": "can.Model.unbind",
                            "type": "function",
                            "parent": "can.Model.static",
                            "signatures": [{
                                    "code": "unbind(eventType, handler)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventType",
                                            "description": "<p>The type of event. It must be\n<code>\"created\"</code>, <code>\"udpated\"</code>, <code>\"destroyed\"</code>.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "handler",
                                            "description": "<p>A callback function\nthat was passed to <code>bind</code>.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>The model constructor function.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 148,
                            "id": 81
                        }, {
                            "active": false,
                            "name": "can.Model.update",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>update( id, attrs ) -&gt; Deferred</code> is used by [can.Model::save save] to \nupdate a model instance on the server. </p>\n\n<h2>Implement with a URL</h2>\n\n<p>The easist way to implement update is to just give it the url to <code>PUT</code> data to:</p>\n\n<pre><code>Recipe = can.Model({\n  update: \"/recipes/{id}\"\n},{});\n</code></pre>\n\n<p>This lets you update a recipe like:</p>\n\n<pre><code>Recipe.findOne({id: 1}, function(recipe){\n  recipe.attr('name','salad');\n  recipe.save();\n})\n</code></pre>\n\n<p>This will make an XHR request like:</p>\n\n<pre><code>PUT /recipes/1 \nname=salad\n</code></pre>\n\n<p>If your server doesn't use PUT, you can change it to post like:</p>\n\n<pre><code>$.Model(\"Recipe\",{\n  update: \"POST /recipes/{id}\"\n},{});\n</code></pre>\n\n<p>The server should send back an object with any new attributes the model \nshould have.  For example if your server udpates the \"updatedAt\" property, it\nshould send back something like:</p>\n\n<pre><code>// PUT /recipes/4 {name: \"Food\"} -&gt;\n{\n  updatedAt : \"10-20-2011\"\n}\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>You can also implement update by yourself.  Update takes the <code>id</code> and\n<code>attributes</code> of the instance to be udpated.  Update must return\na [can.Deferred Deferred] that resolves to an object that contains any \nproperties that should be set on the instance.</p>\n\n<p>For example, the following code makes a request \nto '/recipes/5.json?name=hot+dog' and gets back\nsomething that looks like:</p>\n\n<pre><code>{ \n  updatedAt: \"10-20-2011\"\n}\n</code></pre>\n\n<p>The code looks like:</p>\n\n<pre><code>Recipe = can.Model({\n  update : function(id, attrs ) {\n    return $.post(\"/recipes/\"+id+\".json\",attrs, null,\"json\");\n  }\n},{});\n</code></pre>",
                            "description": "<p>Update a resource on the server. </p>",
                            "title": "update",
                            "signatures": [{
                                    "code": "[METHOD] /path/to/resource",
                                    "description": "<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or PUT if none is specified) when updating an\ninstance on the server. (See below for more details.)</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the updated model.</p>"
                                    }
                                }, {
                                    "code": "function(id, serialized)",
                                    "description": "<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "id",
                                            "description": "<p>The ID of the model to update.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "serialized",
                                            "description": "<p>The [can.Observe::serialize serialized] properties of\nthe model to update.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the updated model.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 272,
                            "id": 84
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "name": "can.Model.List",
            "type": "constructor",
            "parent": "canjs",
            "body": "",
            "description": "<p>Works exactly like [can.Observe.List] and has all of the same properties,\nevents, and functions as an observable list. The only difference is that \nwhen an item from the list is destroyed, it will automatically get removed\nfrom the list.</p>\n\n<h2>Creating a new Model List</h2>\n\n<p>To create a new model list, just use <code>new {model_name}.List(ARRAY)</code> like:</p>\n\n<pre><code>var todo1 = new Todo( { name: \"Do the dishes\" } ),\n    todo2 = new Todo( { name: \"Wash floors\" } )\nvar todos = new Todo.List( [todo1, todo2] );\n</code></pre>\n\n<h3>Model Lists in <code>can.Model</code></h3>\n\n<p>[can.Model.static.findAll can.Model.findAll] or [can.Model.models] will\nalmost always be used to return a <code>can.Model.List</code> object, even though it\nis possible to create new lists like below:</p>\n\n<pre><code>var todos = Todo.models([\n    new Todo( { name: \"Do the dishes\" } ),\n    new Todo( { name: \"Wash floors\" } )\n])\n\ntodos.constructor // -&gt; can.Model.List\n\n// the most correct way to get a can.Model.List\nTodo.findAll({}, function(todos) {\n    todos.constructor // -&gt; can.Model.List\n})\n</code></pre>\n\n<h3>Extending <code>can.Model.List</code></h3>\n\n<p>Creating custom <code>can.Model.Lists</code> allows you to extend lists with helper\nfunctions for a list of a specific type. So, if you wanted to be able to\nsee how many todos were completed and remaining something could be written\nlike:</p>\n\n<pre><code>Todo.List = can.Model.List({\n    completed: function() {\n        var completed = 0;\n        this.each(function(i, todo) {\n            completed += todo.attr('complete') ? 1 : 0\n        })\n        return completed;\n    },\n    remaining: function() {\n        return this.attr('length') - this.completed();\n    }\n})\n\nTodo.findAll({}, function(todos) {\n    todos.completed() // -&gt; 0\n    todos.remaining() // -&gt; 2\n});\n</code></pre>\n\n<h2>Removing models from model list</h2>\n\n<p>The advantage that <code>can.Model.List</code> has over a traditional <code>can.Observe.List</code>\nis that when you destroy a model, if it is in that list, it will automatically\nbe removed from the list. </p>\n\n<pre><code>// Listen for when something is removed from the todos list.\ntodos.bind(\"remove\", function( ev, oldVals, indx ) {\n    console.log(oldVals[indx].attr(\"name\") + \" removed\")\n})\n\ntodo1.destroy(); // console shows \"Do the dishes removed\"\n</code></pre>",
            "title": "",
            "inherits": "can.Observe.List",
            "download": "can/model",
            "test": "can/model/qunit.html",
            "src": "can/model/model.js",
            "line": 1185,
            "id": 99
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.Mustache",
            "body": "",
            "description": "<p>can.Mustache provides logic-less templates with live binding \nwhen used with <a href=\"#can_observe\">can.Observes</a>. It currently ships as a plugin,\nand you can view the <a href=\"http://canjs.us/release/latest/docs/can.view.mustache.html\">annotated source</a>.</p>\n\n<p><a href=\"https://github.com/janl/mustache.js/\">Mustache</a> and <a href=\"http://handlebarsjs.com/\">Handlebar</a> \ntemplates are compatible with can.Mustache, so you can import existing templates.</p>\n\n<h2>Getting Started</h2>\n\n<p>Mustache templates looks similar to normal HTML except\nthey contain contain keys for inserting data into the template\nand <a href=\"#Sections\">sections</a> to enumerate and/or filter the enclosed template blocks.</p>\n\n<p>For example, the following renders a welcome header for\na user and displays the number of messages.</p>\n\n<p><strong>Mustache Template</strong></p>\n\n<pre><code>&lt;script id=\"template\" type=\"text/mustache\"&gt;\n    &lt;h1&gt;Welcome {{user}}!&lt;/h1&gt;\n    &lt;p&gt;You have {{messages}} messages.&lt;/p&gt;\n&lt;/script&gt;\n</code></pre>\n\n<p>The Mustache sytax is the <code>{{  }}</code> magic tags above.</p>\n\n<p><strong>JavaScript</strong></p>\n\n<pre><code>var data = new can.Observe({\n    user: 'Tina Fey',\n    messages: 0\n});\n\nvar template = can.view(\"#template\", data)\ncan.$(document.body).append(template);\n</code></pre>\n\n<p><strong>HTML</strong></p>\n\n<pre><code>&lt;h1&gt;Welcome Tina Fey!&lt;/h1&gt;\n&lt;p&gt;You have 0 messages.&lt;/p&gt;\n</code></pre>\n\n<p>To update your template using live-binding:</p>\n\n<pre><code>data.attr('message', 5)\n</code></pre>\n\n<p>which will re-render the paragraph tag to say:</p>\n\n<pre><code>&lt;p&gt;You have 5 messages.&lt;/p&gt;\n</code></pre>\n\n<p>can.Mustache provides a lot more functionality such as:</p>\n\n<ul>\n<li><a href=\"#Basics\">Context and Path Basics</a></li>\n<li><a href=\"#Sections\">Sections</a></li>\n<li><a href=\"#Partials\">Partials</a></li>\n<li><a href=\"#Acquisition\">Acquiring Templates</a></li>\n<li><a href=\"#Helpers\">Helpers</a></li>\n<li><a href=\"#Binding\">Live Binding</a></li>\n</ul>\n\n<h2>Demos</h2>\n\n<ul>\n<li><a href=\"http://addyosmani.github.com/todomvc/architecture-examples/canjs/\">TodoMVC</a> is a project which offers the same Todo application implemented using MV* concepts in most of the popular JavaScript MV* frameworks of today. <a href=\"https://github.com/addyosmani/todomvc/tree/gh-pages/architecture-examples/canjs\">Source Code</a></li>\n</ul>",
            "title": "",
            "parent": "canjs",
            "comment": "undefined@group can.Mustache.pages Pages\n",
            "test": "can/view/mustache/test/qunit.html",
            "plugin": "can/view/mustache",
            "download": "http://canjs.us/release/latest/can.view.mustache.js",
            "src": "can/view/mustache/doc/mustache.md",
            "id": 155,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Mustache.prototype",
                    "parent": "can.Mustache",
                    "src": "can/view/mustache/mustache.js",
                    "line": 88,
                    "id": 161,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Mustache.prototype.Mustache.get",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "ref",
                                    "description": "<p>The reference to check for on the obj/context.</p>"
                                }, {
                                    "name": "contexts",
                                    "types": [{
                                            "type": "*"
                                        }
                                    ]
                                }, {
                                    "types": [{
                                            "type": "Boolean"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "isHelper",
                                    "description": "<p>Whether the reference is a helper.</p>"
                                }, {
                                    "name": "isArgument",
                                    "types": [{
                                            "type": "*"
                                        }
                                    ]
                                }, {
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "obj",
                                    "description": "<p>The object to use for checking for a reference.</p>"
                                }, {
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "context",
                                    "description": "<p>The context to use for checking for a reference if it doesn't exist in the object.</p>"
                                }
                            ],
                            "parent": "can.Mustache.prototype",
                            "body": "",
                            "description": "<p>Resolves a reference for a given object (and then a context if that fails).\nobj = this\ncontext = { a: true }\nref = 'a.b.c'\n    => obj.a.b.c || context.a.b.c || ''</p>\n\n<p>This implements the following Mustache specs:\n    Deeply Nested Contexts\nAll elements on the context stack should be accessible.\n    {{#bool}}B {{#bool}}C{{/bool}} D{{/bool}}\n    { bool: true }\n    => \"B C D\"\n    Basic Context Miss Interpolation\n    Failed context lookups should default to empty strings.\n     {{cannot}}\n    => \"\"\n    Dotted Names - Broken Chains\n    Any falsey value prior to the last part of the name should yield ''.\n    {{a.b.c}}\n    { a: { d: 1 } }\n    => \"\"</p>",
                            "hide": true,
                            "src": "can/view/mustache/mustache.js",
                            "line": 727,
                            "id": 164
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Mustache.prototype.Mustache.resolve",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "value",
                                    "description": "<p>The object to resolve.</p>"
                                }, {
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "lastValue",
                                    "description": "<p>Only used with Mustache.get.</p>"
                                }, {
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "name",
                                    "description": "<p>Only used with Mustache.get.</p>"
                                }, {
                                    "types": [{
                                            "type": "Boolean"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "isArgument",
                                    "description": "<p>Only used with Mustache.get.</p>"
                                }
                            ],
                            "parent": "can.Mustache.prototype",
                            "body": "",
                            "description": "<p>Resolves an object to its truthy equivalent.</p>",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p>The resolved object.</p>"
                            },
                            "src": "can/view/mustache/mustache.js",
                            "line": 855,
                            "id": 165
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Mustache.prototype.Mustache.txt",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }, {
                                            "type": "Array"
                                        }
                                    ],
                                    "name": "context",
                                    "description": "<p>The context stack to be used with evaluation.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "mode",
                                    "description": "<p>The mode to evaluate the section with: # for truthy, ^ for falsey</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }, {
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "name",
                                    "description": "<p>The string (or sometimes object) to pass to the given helper method.</p>"
                                }
                            ],
                            "parent": "can.Mustache.prototype",
                            "body": "",
                            "description": "<p>Evaluates the resulting string based on the context/name.</p>",
                            "hide": true,
                            "src": "can/view/mustache/mustache.js",
                            "line": 603,
                            "id": 163
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Mustache.prototype.render",
                            "parent": "can.Mustache.prototype",
                            "body": "<p>Renders an object with view helpers attached to the view.</p>\n\n<pre><code> new Mustache({text: \"&lt;%= message %&gt;\"}).render({\n     message: \"foo\"\n })\n</code></pre>",
                            "description": "",
                            "title": "render",
                            "signatures": [{
                                    "code": "render(data)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "data",
                                            "description": "<p>Data to interpolate into the template.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "String"
                                            }
                                        ],
                                        "description": "<p>The template with interpolated data, in string form.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/view/mustache/mustache.js",
                            "line": 92,
                            "id": 162
                        }
                    ]
                }, {
                    "active": false,
                    "type": "static",
                    "body": "",
                    "description": "",
                    "name": "can.Mustache.static",
                    "parent": "can.Mustache",
                    "src": "can/view/mustache/mustache.js",
                    "line": 896,
                    "id": 166,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Mustache.getHelper",
                            "parent": "can.Mustache.static",
                            "body": "<p>Returns a helper given the name.</p>",
                            "description": "<p>Retrieve a helper. </p>",
                            "title": "getHelper",
                            "signatures": [{
                                    "code": "Mustache.getHelper(name)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "name",
                                            "description": "<p>The name of the helper.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "function",
                                                "returns": {
                                                    "types": [{
                                                            "type": "undefined"
                                                        }
                                                    ]
                                                },
                                                "params": []
                                            }, {
                                                "type": "null"
                                            }
                                        ],
                                        "description": "<p>The helper, or <code>null</code> if\nno helper by that name is found.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/view/mustache/mustache.js",
                            "line": 937,
                            "id": 168
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Mustache.registerHelper",
                            "parent": "can.Mustache.static",
                            "body": "<p>Registers a helper with the Mustache system.\nPass the name of the helper followed by the\nfunction to which Mustache should invoke.\nThese are run at runtime.</p>",
                            "description": "<p>Register a helper. </p>",
                            "title": "registerHelper",
                            "signatures": [{
                                    "code": "Mustache.registerHelper(name, helper)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "name",
                                            "description": "<p>The name of the helper.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "helper",
                                            "description": "<p>The helper function.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/view/mustache/mustache.js",
                            "line": 920,
                            "id": 167
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Mustache.static.render",
                            "parent": "can.Mustache.static",
                            "body": "<p><code>Mustache.render</code> is a helper method that calls\ninto <code>can.view.render</code> passing the partial \nand the context object.  </p>\n\n<p>Its purpose is to determine if the partial object \nbeing passed represents a template like:</p>\n\n<pre><code>    partial === \"movember.mustache\"\n</code></pre>\n\n<p>or if the partial is a variable name that represents\na partial on the context object such as:</p>\n\n<pre><code>    context[partial] === \"movember.mustache\"\n</code></pre>",
                            "description": "",
                            "title": "render",
                            "signatures": [{
                                    "code": "Mustache.render(partial, context)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "partial",
                                            "description": ""
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "context",
                                            "description": ""
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/view/mustache/mustache.js",
                            "line": 961,
                            "id": 169
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.Observe",
            "body": "<h2>Working with Observes</h2>\n\n<p>To create an Observe, use <code>new can.Observe([props])</code>. This will return a\ncopy of <code>props</code> that emits events when its properties are changed with\n<code>[can.Observe.prototype.attr attr]</code>.</p>\n\n<p>You can read the values of properties on Observes directly, but you should\nnever set them directly. You can also read property values using <code>attr</code>.\nUsually, you will want to do this when creating a <code>[can.compute]</code> or when\nlive-binding properties in an [can.EJS EJS] template. (If you are using\n[can.Mustache Mustache], you don't need to use <code>attr</code>.)</p>\n\n<pre><code class=\"lang-javascript\">var aName = {a: 'Alexis'},\n    observe = can.Observe(aName);\n\n// Observes are copies of data:\naName === observe; // false\n\n// reading from an Observe:\nobserve.attr();    // {a: 'Alexis'}\nobserve.a;         // 'Alexis'\nobserve.attr('a'); // 'Alexis'\n\n// setting an Observe's property:\nobserve.attr('a, 'Alice');\nobserve.a; // Alice\n\n// removing an Observe's property;\nobserve.removeAttr('a');\nobserve.attr(); // {}\n\n// Don't do this!\nobserve.a = 'Adam'; // wrong!</code></pre>\n\n<p>Find out more about manipulating properties of Observes under\n[can.Observe.protoype.attr attr] and [can.Observe.protoype.removeAtt removeAttr].</p>\n\n<h2>Listening to changes</h2>\n\n<p>The real power of observable objects comes from being able to react to\nproperties being added, set, and removed. Observes emit events when\nproperties are changed that you can bind to.</p>\n\n<p><code>can.Observe</code> has two types of events that fire due to changes on an Observe:\n- the <em>change</em> event fires on every change to an Observe.\n- an event named after the property name fires on every change to that property.</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('change', function(ev, attr, how, newVal, oldVal) {\n    console.log('Something on o changed.');\n});\no.bind('a', function(ev, newVal, oldVal) {\n    console.log('a was changed.');\n});\n\no.attr('a', 'Alexis'); // 'Something on o changed.'\n                       // 'a was changed.'\no.attr({\n    'a': 'Alice',      // 'Something on o changed.' (for a's change)\n    'b': 'Bob'         // 'Something on o changed.' (for b's change)\n});                    // 'a was changed.'\n\no.removeAttr('a');     // 'Something on o changed.'\n                       // 'a was changed.'</code></pre>\n\n<p>For more detail on how to use these events, see [can.Observe.prototype.bind bind] and\n[can.Observe.prototype.unbind unbind]. There is also a plugin called [can.Observe.delegate]\nthat makes binding to specific types of events easier:</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.delegate('a', 'add' function(ev, newVal, oldVal) {\n    console.log('a was added.');\n});\no.delegate('a', 'set' function(ev, newVal, oldVal) {\n    console.log('a was set.');\n});\no.delegate('a', 'remove' function(ev, newVal, oldVal) {\n    console.log('a was removed.');\n});\no.delegate('a', 'change' function(ev, newVal, oldVal) {\n    console.log('a was changed.');\n});\n\no.attr('a', 'Alexis'); // 'a was added.'\n                       // 'a was changed.'\n\no.attr('a', 'Alice'); // 'a was set.'\n                      // 'a was changed.'\n\n\no.removeAttr('a'); // 'a was removed.'\n                   // 'a was changed.'</code></pre>",
            "description": "<p><code>can.Observe</code> provides a way for you to listen for and keep track of changes\nto objects. When you use the getters and setters provided by <code>can.Observe</code>,\nevents are fired that you can react to. <code>can.Observe</code> also has support for\nworking with deep properties. Observable arrays are also available with\n<code>[can.Observe.List]</code>, which is based on <code>can.Observe</code>.</p>",
            "title": "",
            "inherits": "can.Construct",
            "parent": "canjs",
            "comment": " ",
            "test": "can/observe/qunit.html",
            "download": "can/observe",
            "signatures": [{
                    "code": "can.Observe([props])",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "props",
                            "description": "<p>properties and values to seed the Observe with</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.Observe"
                            }
                        ],
                        "description": "<p>an instance of <code>can.Observe</code> with the properties from <em>props</em></p>"
                    }
                }
            ],
            "src": "can/observe/observe.md",
            "id": 15,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Observe.prototype",
                    "parent": "can.Observe",
                    "src": "can/observe/observe.js",
                    "line": 365,
                    "id": 21,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype._attrs",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "props",
                                    "description": ""
                                }, {
                                    "types": [{
                                            "type": "Boolean"
                                        }
                                    ],
                                    "name": "remove",
                                    "description": "<p>true if you should remove properties that are not in props</p>"
                                }
                            ],
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Set multiple properties on the observable</p>",
                            "hide": true,
                            "src": "can/observe/observe.js",
                            "line": 900,
                            "id": 29
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.attr",
                            "parent": "can.Observe.prototype",
                            "body": "<p><code>attr</code> gets or sets properties on the <code>can.Observe</code> it's called on. Here's a tour through\nhow all of its forms work:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({});\n\n// set a property:\npeople.attr('a', 'Alex');\n\n// get a property:\npeople.attr('a'); // 'Alex'\n\n// set and merge multiple properties:\npeople.attr({\n    a: 'Alice',\n    b: 'Bob'\n});\n\n// get all properties:\npeople.attr(); // {a: 'Alice', b: 'Bob'}\n\n// set properties while removing others:\npeople.attr({\n    b: 'Bill',\n    e: 'Eve'\n}, true);\n\npeople.attr(); // {b: 'Bill', e: 'Eve'}</code></pre>\n\n<h2>Deep properties</h2>\n\n<p><code>attr</code> can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using <code>attr</code>.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({names: {}});\n\n// set a property:\npeople.attr('names.a', 'Alice');\n\n// get a property:\npeople.attr('names.a'); // 'Alice'\npeople.names.attr('a'); // 'Alice'\n\n// get all properties:\npeople.attr(); // {names: {a: 'Alice'}}</code></pre>\n\n<p>Objects that are added to Observes become Observes themselves behind the scenes,\nso changes to deep properties fire events at each level, and you can bind at any\nlevel. As this example shows, all the same events are fired no matter what level\nyou call <code>attr</code> at:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({names: {}});\n\npeople.bind('change', function(ev, attr, how, newVal, oldVal) {\n  console.log('people change: ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\npeople.names.bind('change', function(ev, attr, how, newVal, oldVal) {\n   console.log('people.names change' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\npeople.bind('names', function(ev, newVal, oldVal) {\n    console.log('people names: ' + newVal + ', ' + oldVal);\n});\n\npeople.names.bind('a', function(ev, newVal, oldVal) {\n    console.log('people.names a: ' + newVal + ', ' + oldVal);\n});\n\npeople.bind('names.a', function(ev, newVal, oldVal) {\n    console.log('people names.a: ' + newVal + ', ' + oldVal);\n});\n\npeople.attr('names.a', 'Alice'); // people change: names.a, add, Alice, undefined\n                                 // people.names change: a, add, Alice, undefined\n                                 // people.names a: Alice, undefined\n                                 // people names.a: Alice, undefined\n\npeople.names.attr('b', 'Bob');   // people change: names.b, add, Bob, undefined\n                                 // people.names change: b, add, Bob, undefined\n                                 // people.names b: Bob, undefined\n                                 // people names.b: Bob, undefined</code></pre>\n\n<h2>See also</h2>\n\n<p>For information on the events that are fired on property changes and how\nto listen for those events, see [can.Observe.prototype.bind bind].</p>",
                            "description": "<p>Get or set properties on an Observe. </p>",
                            "title": "attr",
                            "signatures": [{
                                    "code": "attr()",
                                    "description": "<p>Gets a collection of all the properties in this <code>can.Observe</code>.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Object",
                                                "template": [{
                                                        "types": [{
                                                                "type": "String"
                                                            }
                                                        ]
                                                    }, {
                                                        "types": [{
                                                                "type": "*"
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }
                                        ],
                                        "description": "<p>an object with all the properties in this <code>can.Observe</code>.</p>"
                                    }
                                }, {
                                    "code": "attr(key)",
                                    "description": "<p>Reads a property from this <code>can.Observe</code>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "key",
                                            "description": "<p>the property to read</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the value assigned to <em>key</em>.</p>"
                                    }
                                }, {
                                    "code": "attr(key, value)",
                                    "description": "<p>Assigns <em>value</em> to a property on this <code>can.Observe</code> called <em>key</em>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "key",
                                            "description": "<p>the property to set</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "the",
                                            "description": "<p>value to assign to <em>key</em>.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe"
                                            }
                                        ],
                                        "description": "<p>this Observe, for chaining</p>"
                                    }
                                }, {
                                    "code": "attr(obj[, removeOthers])",
                                    "description": "<p>Assigns each value in <em>obj</em> to a property on this <code>can.Observe</code> named after the\ncorresponding key in <em>obj</em>, effectively merging <em>obj</em> into the Observe.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object",
                                                    "template": [{
                                                            "types": [{
                                                                    "type": "String"
                                                                }
                                                            ]
                                                        }, {
                                                            "types": [{
                                                                    "type": "*"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "name": "obj",
                                            "description": "<p>a collection of key-value pairs to set.\nIf any properties already exist on the <code>can.Observe</code>, they will be overwritten.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "bool"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "removeOthers",
                                            "defaultValue": "false",
                                            "description": "<p>whether to remove keys not present in <em>obj</em>.\nTo remove keys without setting other keys, use <code>[can.Observe::removeAttr removeAttr]</code>.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe"
                                            }
                                        ],
                                        "description": "<p>this Observe, for chaining</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 408,
                            "id": 23
                        }, {
                            "active": false,
                            "name": "can.Observe.prototype.bind",
                            "type": "function",
                            "parent": "can.Observe.prototype",
                            "body": "<p><code>bind</code> binds event handlers to property changes on <code>can.Observe</code>s. When you change\na property using <code>attr</code>, two events are fired on the Observe, allowing other parts\nof your application to observe the changes to the object.</p>\n\n<h2>The <em>change</em> event</h2>\n\n<p>The first event that is fired is the <em>change</em> event. The <em>change</em> event is useful\nif you want to react to all changes on an Observe.</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('change', function(ev, attr, how, newVal, oldVal) {\n    console.log('Something changed.');\n});</code></pre>\n\n<p>The parameters of the event handler for the <em>change</em> event are:</p>\n\n<ul>\n<li><em>ev</em> The event object.</li>\n<li><em>attr</em> Which property changed.</li>\n<li><em>how</em> Whether the property was added, removed, or set. Possible values are <code>'add'</code>, <code>'remove'</code>, or <code>'set'</code>.</li>\n<li><em>newVal</em> The value of the property after the change. <code>newVal</code> will be <code>undefined</code> if the property was removed.</li>\n<li><em>oldVal</em> Thishe value of the property before the change. <code>oldVal</code> will be <code>undefined</code> if the property was added.</li>\n</ul>\n\n<p>Here is a concrete tour through the <em>change</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('change', function(ev, attr, how, newVal, oldVal) {\n    console.log(ev + ', ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\no.attr('a', 'Alexis'); // [object Object], a, add, Alexis, undefined\no.attr('a', 'Adam');   // [object Object], a, set, Adam, Alexis\no.attr({\n    'a': 'Alice',      // [object Object], a, set, Alice, Adam\n    'b': 'Bob'         // [object Object], b, add, Bob, undefined\n});\no.removeAttr('a');     // [object Object], a, remove, undefined, Alice</code></pre>\n\n<p>(See also <code>[can.Observe::removeAttr removeAttr]</code>, which removes properties).</p>\n\n<h2>The <em>property name</em> event</h2>\n\n<p>The second event that is fired is an event whose type is the same as the changed\nproperty's name. This event is useful for noticing changes to a specific property.</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('a', function(ev, newVal, oldVal) {\n    console.log('The value of a changed.');\n});</code></pre>\n\n<p>The parameters of the event handler for the <em>property name</em> event are:</p>\n\n<ul>\n<li><em>ev</em> The event object.</li>\n<li><em>newVal</em> The value of the property after the change. <code>newVal</code> will be <code>undefined</code> if the property was removed.</li>\n<li><em>oldVal</em> The value of the property before the change. <code>oldVal</code> will be <code>undefined</code> if the property was added.</li>\n</ul>\n\n<p>Here is a concrete tour through the <em>property name</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('a', function(ev, newVal, oldVal) {\n    console.log(ev + ', ' + newVal + ', ' + oldVal);\n});\n\no.attr('a', 'Alexis'); // [object Object], Alexis, undefined\no.attr('a', 'Adam');   // [object Object], Adam, Alexis\no.attr({\n    'a': 'Alice',      // [object Object], Alice, Adam\n    'b': 'Bob' \n});\no.removeAttr('a');     // [object Object], undefined, Alice</code></pre>\n\n<h2>See also</h2>\n\n<p>More information about changing properties on Observes can be found under\n[can.Observe.prototype.attr attr].</p>\n\n<p>For a more specific way to changes on Observes, see the [can.Observe.delegate] plugin.</p>",
                            "description": "<p>Bind event handlers to an Observe. </p>",
                            "title": "bind",
                            "signatures": [{
                                    "code": "bind(eventType, handler)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventType",
                                            "description": "<p>the type of event to bind this handler to</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "handler",
                                            "description": "<p>the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe"
                                            }
                                        ],
                                        "description": "<p>this Observe, for chaining</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 749,
                            "id": 26
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.compute",
                            "parent": "can.Observe.prototype",
                            "body": "<p><code>compute</code> is a convenience method for making computes from properties\nof Observes. More information about computes can be found under [can.compute].</p>",
                            "description": "<p>Make a can.compute from an observable property. </p>",
                            "title": "compute",
                            "signatures": [{
                                    "code": "compute(attrName)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "attrName",
                                            "description": "<p>the property to bind to</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.compute"
                                            }
                                        ],
                                        "description": "<p>a [can.compute] bound to <em>attrName</em></p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 952,
                            "id": 30
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.each",
                            "parent": "can.Observe.prototype",
                            "body": "<pre><code class=\"lang-javascript\">var names = [];\nnew can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n    names.push(value);\n});\n\nnames; // ['Alice', 'Bob', 'Eve']\n\nnames = [];\nnew can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n    names.push(value);\n    if(key === 'b') {\n        return false;\n    }\n});\n\nnames; // ['Alice', 'Bob']\n</code></pre>     ",
                            "description": "<p>Call a function on each property of an Observe. </p>",
                            "title": "each",
                            "signatures": [{
                                    "code": "each(callback)",
                                    "description": "<p><code>each</code> iterates through the Observe, calling a function\nfor each property value and key.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "callback",
                                            "description": "<p>the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe"
                                            }
                                        ],
                                        "description": "<p>this Observe, for chaining</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 555,
                            "id": 24
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.removeAttr",
                            "parent": "can.Observe.prototype",
                            "body": "<p><code>removeAttr</code> removes a property by name from an Observe.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'});\n\npeople.removeAttr('b'); // 'Bob'\npeople.attr();          // {a: 'Alice', e: 'Eve'}</code></pre>\n\n<p>Removing an attribute will cause a <em>change</em> event to fire with <code>'remove'</code>\npassed as the <em>how</em> parameter and <code>undefined</code> passed as the <em>newVal</em> to\nhandlers. It will also cause a <em>property name</em> event to fire with <code>undefined</code>\npassed as <em>newVal</em>. An in-depth description at these events can be found\nunder <code>[can.Observe.prototype.attr attr]</code>.</p>",
                            "description": "<p>Remove a property from an Observe. </p>",
                            "title": "removeAttr",
                            "signatures": [{
                                    "code": "removeAttr(attrName)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "attrName",
                                            "description": "<p>the name of the property to remove</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the value of the property that was removed</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 595,
                            "id": 25
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.serialize",
                            "params": [],
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Get the serialized Object form of the observe.  Serialized\ndata is typically used to send back to a server.</p>\n\n<pre><code>o.serialize() //-&gt; { name: 'Justin' }\n</code></pre>\n\n<p>Serialize currently returns the same data \nas [can.Observe.prototype.attrs].  However, in future\nversions, serialize will be able to return serialized\ndata similar to [can.Model].  The following will work:</p>\n\n<pre><code>new Observe({time: new Date()})\n  .serialize() //-&gt; { time: 1319666613663 }\n</code></pre>",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p>a JavaScript Object that can be \nserialized with <code>JSON.stringify</code> or other methods. </p>"
                            },
                            "src": "can/observe/observe.js",
                            "line": 878,
                            "id": 28
                        }, {
                            "active": false,
                            "name": "can.Observe.prototype.unbind",
                            "type": "function",
                            "parent": "can.Observe.prototype",
                            "body": "<p><code>unbind</code> unbinds event handlers previously bound with [can.Observe.prototype.bind|<code>bind</code>].\nIf no <em>handler</em> is passed, all handlers for the given event type will be unbound.</p>\n\n<pre><code class=\"lang-javascript\">var i = 0,\n    increaseBy2 = function() { i += 2; },\n    increaseBy3 = function() { i += 3; },\n    o = new can.Observe();\n\no.bind('change', increaseBy2);\no.bind('change', increaseBy3);\no.attr('a', 'Alice');\ni; // 5\n\no.unbind('change', increaseBy2);\no.attr('b', 'Bob');\ni; // 8\n\no.unbind('change');\no.attr('e', 'Eve');\ni; // 8</code></pre>     ",
                            "description": "<p>Unbind event handlers from an Observe. </p>",
                            "title": "unbind",
                            "signatures": [{
                                    "code": "unbind(eventType[, handler])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventType",
                                            "description": "<p>the type of event to unbind, exactly as passed to <code>bind</code></p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "handler",
                                            "description": "<p>the handler to unbind</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 846,
                            "id": 27
                        }
                    ]
                }, {
                    "active": false,
                    "type": "static",
                    "body": "",
                    "description": "",
                    "name": "can.Observe.static",
                    "parent": "can.Observe",
                    "src": "can/observe/observe.js",
                    "line": 122,
                    "id": 16,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.keys",
                            "parent": "can.Observe.static",
                            "body": "<p><code>keys</code> iterates over an observe to get an array of its keys.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({\n    a: 'Alice',\n    b: 'Bob',\n    e: 'Eve'\n});\n\ncan.Observe.keys(people); // ['a', 'b', 'e']</code></pre>     ",
                            "description": "<p>Iterate over the keys of an Observe. </p>",
                            "title": "keys",
                            "signatures": [{
                                    "code": "can.Observe.keys(observe)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "can.Observe"
                                                }
                                            ],
                                            "name": "observe",
                                            "description": "<p>the <code>can.Observe</code> to get the keys from</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Array"
                                            }
                                        ],
                                        "description": "<p>array An array containing the keys from <em>observe</em>.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 335,
                            "id": 20
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.startBatch",
                            "parent": "can.Observe.static",
                            "body": "<p><code>startBatch</code> causes can.Observe to begin an event batch. Until <code>[can.Observe.stopBatch]</code> is called, any\nevents that would result from calls to <code>[can.Observe::attr attr]</code> are held back from firing. If you have\nlots of changes to make to can.Observes, batching them together can help performance &emdash; especially if\nthose can.Observes are live-bound to the DOM.</p>\n\n<p>In this example, you can see how the <em>first</em> and <em>change</em> events are not fired (and their handlers\nare not called) until <code>stopBatch</code> is called.</p>\n\n<pre><code class=\"lang-javascript\">var person = new can.Observe({\n    first: 'Alexis',\n    last: 'Abril'\n});\n\nperson.bind('first', function() {\n    console.log(\"First name changed.\"\");\n}).bind('change', function() {\n    console.log(\"Something changed.\");\n});\n\ncan.Observe.startBatch();\nperson.attr('first', 'Alex');\nconsole.log('Still in the batch.');\ncan.Observe.stopBatch();\n\n// the log has:\n// Still in the batch.\n// First name changed.\n// Something changed.</code></pre>\n\n<p>You can also pass a callback to <code>startBatch</code> which will be called after all the events have\nbeen fired:</p>\n\n<pre><code class=\"lang-javascript\">can.Observe.startBatch(function() {\n    console.log('The batch is over.');\n});\nperson.attr('first', 'Izzy');\nconsole.log('Still in the batch.');\ncan.Observe.stopBatch();\n\n// The console has:\n// Still in the batch.\n// First name changed.\n// Something changed.\n// The batch is over.</code></pre>\n\n<h2>Calling <code>startBatch</code> multiple times</h2>\n\n<p>If you call <code>startBatch</code> more than once, <code>stopBatch</code> needs to be called\nthe same number of times before any batched events will fire. For ways\nto circumvent this process, see [can.Observe.stopBatch].</p>\n\n<p>Here is an example that demonstrates how events are affected by calling\n<code>startBatch</code> multiple times.</p>\n\n<pre><code class=\"lang-javascript\">var addPeople = function(observable) {\n    can.Observe.startBatch();\n    observable.attr('a', 'Alice');\n    observable.attr('b', 'Bob');\n    observable.attr('e', 'Eve');\n    can.Observe.stopBatch();\n};\n\n// In a completely different place:\nvar list = new can.Observe();\nlist.bind('change', function() {\n    console.log('The list changed.');\n});\n\ncan.Observe.startBatch();\naddPeople(list);\nconsole.log('Still in the batch.');\n\n// Here, the console has:\n// Still in the batch.\n\ncan.Observe.stopBatch();\n\n// Here, the console has:\n// Still in the batch.\n// The list changed.\n// The list changed.\n// The list changed.</code></pre>     ",
                            "description": "<p>Begin an event batch. </p>",
                            "title": "startBatch",
                            "signatures": [{
                                    "code": "startBatch([batchStopHandler])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "batchStopHandler",
                                            "description": "<p>a callback that gets called after all batched events have been called</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 133,
                            "id": 17
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.stopBatch",
                            "parent": "can.Observe.static",
                            "body": "<p><code>stopBatch</code> matches an earlier <code>[can.Observe.startBatch]</code> call. If <code>stopBatch</code> has been\ncalled as many times as <code>startBatch</code> (or if <em>force</em> is true), all batched events will be\nfired and any callbacks passed to <code>startBatch</code> since the beginning of the batch will be\ncalled. If <em>force and _callStart</em> are both true, a new batch will be started when all\nthe events and callbacks have been fired.</p>\n\n<p>See <code>[can.Observe.startBatch]</code> for examples of <code>startBatch</code> and <code>stopBatch</code> in normal use.</p>\n\n<p>In this example, the batch is forceably ended in the <code>addPeople</code> function.</p>\n\n<pre><code class=\"lang-javascript\">var addPeople = function(observable) {\n    can.Observe.startBatch();\n    observable.attr('a', 'Alice');\n    observable.attr('b', 'Bob');\n    observable.attr('e', 'Eve');\n    can.Observe.stopBatch(true);\n};\n\n// In a completely different place:\nvar list = new can.Observe();\nlist.bind('change', function() {\n    console.log('The list changed.');\n});\n\ncan.Observe.startBatch();\naddPeople(list);\nconsole.log('Still in the batch.');\n\n// Here, the console has:\n// Still in the batch.\n\ncan.Observe.stopBatch();\n\n// Here, the console has:\n// The list changed.\n// The list changed.\n// The list changed.\n// Still in the batch.</code></pre>     ",
                            "description": "<p>End an event batch. </p>",
                            "title": "stopBatch",
                            "signatures": [{
                                    "code": "stopBatch([force[, callStart]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "bool"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "force",
                                            "defaultValue": "false",
                                            "description": "<p>whether to stop batching events immediately</p>"
                                        }, {
                                            "types": [{
                                                    "type": "bool"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "callStart",
                                            "defaultValue": "false",
                                            "description": "<p>whether to call <code>[can.Observe.startBatch startBatch]</code> after firing batched events</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 233,
                            "id": 18
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.triggerBatch",
                            "parent": "can.Observe.static",
                            "body": "<p>If events are currently being batched, calling <code>triggerBatch</code> adds an event\nto the batch. If events are not currently being batched, the event is triggered\nimmediately.</p>",
                            "description": "<p>Trigger an event to be added to the current batch. </p>",
                            "title": "triggerBatch",
                            "signatures": [{
                                    "code": "can.Observe.triggerBatch(item, event [, args])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "can.Observe"
                                                }
                                            ],
                                            "name": "item",
                                            "description": "<p>the target of the event</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }, {
                                                    "type": "Object",
                                                    "options": [{
                                                            "name": "type",
                                                            "types": [{
                                                                    "type": "String"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "name": "event",
                                            "description": "<p>the type of event, or an event object with a type given</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Array"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "args",
                                            "description": "<p>the parameters to trigger the event with.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 304,
                            "id": 19
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "name": "can.Observe.List",
            "type": "constructor",
            "parent": "canjs",
            "body": "<h2>Working with Lists</h2>\n\n<p><code>can.Observe.List</code> extends <code>[can.Observe]</code>, so all the ways that you're used to working with\nObserves also work here, including [can.Observe.prototype.bind bind], [can.Observe.prototype.unbind unbind],\nand [can.Observe.prototype.each each]. And just as you can directly read properties normally\noff of an Observe, you can use array accessors ([]) to read elements directly off of a List.</p>\n\n<p>The one function of <code>can.Observe</code> that works slightly differently is <code>attr</code>. As expected when working with\narrays, top-level keys passed into <code>attr</code> are required to be numeric. (Strings may still be used when getting\nor modifying deep properties). Any top-level keys that are non-numeric are ignored. In addition, as might be\nexpected, a call to argument-less <code>attr</code> returns an array instead of an object.</p>\n\n<p>Just as you shouldn't set properties of an Observe directly, you shouldn't change elements\nof a List directly. Always use <code>attr</code> to set the elements of a List, or use [can.Observe.List.push push],\n[can.Observe.List.pop pop], [can.Observe.List.shift shift], [can.Observe.List.unshift unshift], or [can.Observe.List.splice splice].</p>\n\n<p>Here is a tour through the forms of <code>can.Observe.List</code>'s <code>attr</code> that parallels the one found under [can.Observe.prototype.attr attr]:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe.List(['Alex', 'Bill']);\n\n// set an element:\npeople.attr(0, 'Adam');\npeople[0] = 'Adam'; // don't do this!\n\n// get an element:\npeople.attr(0); // 'Adam'\npeople[0]; // 'Adam'\n\n// get all elements:\npeople.attr(); // ['Adam', 'Bill']\n\n// extend the array:\npeople.attr(4, 'Charlie');\npeople.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n// merge the elements:\npeople.attr(['Alice', 'Bob', 'Eve']);\npeople.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']</code></pre>\n\n<h2>Listening to changes</h2>\n\n<p>As with <code>can.Observe</code>s, the real power of observable arrays comes from being able to\nreact to changes in the member elements of the array. Lists emit five types of events:\n- the <em>change</em> event fires on every change to a List.\n- the <em>set</em> event is fired when an element is set.\n- the <em>add</em> event is fired when an element is added to the List.\n- the <em>remove</em> event is fired when an element is removed from the List.\n- the <em>length</em> event is fired when the length of the List changes.</p>\n\n<p>This example presents a brief concrete survey of the times these events are fired:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\n\nlist.bind('change', function() { console.log('An element changed.'); });\nlist.bind('set', function() { console.log('An element was set.'); });\nlist.bind('add', function() { console.log('An element was added.'); });\nlist.bind('remove', function() { console.log('An element was removed.'); });\nlist.bind('length', function() { console.log('The length of the list changed.'); });\n\nlist.attr(0, 'Alexis'); // 'An element changed.'\n                        // 'An element was set.'\n\nlist.attr(3, 'Xerxes'); // 'An element changed.'\n                        // 'An element was added.'\n                        // 'The length of the list was changed.'\n\nlist.attr(['Adam', 'Bill']); // 'An element changed.'\n                             // 'An element was set.'\n                             // 'An element was changed.'\n                             // 'An element was set.'\n\nlist.pop(); // 'An element changed.'\n            // 'An element was removed.'\n            // 'The length of the list was changed.'</code></pre>\n\n<p>More information about binding to these events can be found under [can.Observe.List.attr attr].</p>",
            "description": "<p><code>can.Observe.List</code> provides a way for you to use <code>can.Observe</code>s with arrays. Much like <code>can.Observe</code>,\nwhen you use the getters and setters on <code>can.Observe.List</code>, events are fired that you can listen for\nand react to.</p>",
            "inherits": "can.Observe",
            "download": "can/observe",
            "test": "can/observe/qunit.html",
            "signatures": [{
                    "code": "can.Observe.List([elements])",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "Array"
                                }
                            ],
                            "optional": true,
                            "name": "elements",
                            "description": "<p>elements to seed the List with</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.Observe.List"
                            }
                        ],
                        "description": "<p>an instance of <code>can.Observe.List</code> with the elements from <em>elements</em></p>"
                    }
                }
            ],
            "comment": " ",
            "src": "can/observe/observe.js",
            "line": 984,
            "id": 31,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Observe.List.prototype",
                    "parent": "can.Observe.List",
                    "src": "can/observe/observe.js",
                    "line": 1084,
                    "id": 32,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.attr",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>attr</code> gets or sets elements on the <code>can.Observe.List</code> it's called on. Here's a tour through\n how all of its forms work:</p>\n\n<pre><code class=\"lang-javascript\"> var people = new can.Observe.List(['Alex', 'Bill']);\n\n // set an element:\n people.attr(0, 'Adam');\n\n // get an element:\n people.attr(0); // 'Adam'\n people[0]; // 'Adam'\n\n // get all elements:\n people.attr(); // ['Adam', 'Bill']\n\n // extend the array:\n people.attr(4, 'Charlie');\n people.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n // merge the elements:\n people.attr(['Alice', 'Bob', 'Eve']);\n people.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']</code></pre> \n\n<p>## Deep properties</p>\n\n<p><code>attr</code> can also set and read deep properties. All you have to do is specify\n the property name as you normally would if you weren't using <code>attr</code>.</p>\n\n<pre><code class=\"lang-javascript\"> var people = new can.Observe.List([{name: 'Alex'}, {name: 'Bob'}]);\n\n // set a property:\n people.attr('0.name', 'Alice');\n\n // get a property:\n people.attr('0.name');  // 'Alice'\n people[0].attr('name'); // 'Alice'\n\n // get all properties:\n people.attr(); // [{name: 'Alice'}, {name: 'Bob'}]</code></pre>\n\n<p>The discussion of deep properties under <code>[can.Observe.prototype.attr]</code> may also\n be enlightening.</p>\n\n<p>## Events</p>\n\n<p><code>can.Observe.List</code>s emit five types of events in response to changes. They are:\n - the <em>change</em> event fires on every change to a List.\n - the <em>set</em> event is fired when an element is set.\n - the <em>add</em> event is fired when an element is added to the List.\n - the <em>remove</em> event is fired when an element is removed from the List.\n - the <em>length</em> event is fired when the length of the List changes.</p>\n\n<ul>\n<li><h2>The <em>change</em> event</h2>\n\n<p>The first event that is fired is the <em>change</em> event. The <em>change</em> event is useful\nif you want to react to all changes on an List.</p></li>\n</ul>\n\n<pre><code class=\"lang-javascript\"> var list = new can.Observe.List([]);\n list.bind('change', function(ev, index, how, newVal, oldVal) {\n     console.log('Something changed.');\n });</code></pre> \n\n<p>The parameters of the event handler for the <em>change</em> event are:</p>\n\n<ul>\n<li><em>ev</em> The event object.</li>\n<li><em>index</em> Where the change took place.</li>\n<li><em>how</em> Whether elements were added, removed, or set.\nPossible values are <code>'add'</code>, <code>'remove'</code>, or <code>'set'</code>.</li>\n<li><em>newVal</em> The elements affected after the change\n<em>newVal</em> will be a single value when an index is set, an Array when elements\nwere added, and <code>undefined</code> if elements were removed.</li>\n<li><p><em>oldVal</em> The elements affected before the change.\n<em>newVal</em> will be a single value when an index is set, an Array when elements\nwere removed, and <code>undefined</code> if elements were added.</p>\n\n<p>Here is a concrete tour through the <em>change</em> event handler's arguments:</p></li>\n</ul>\n\n<pre><code class=\"lang-javascript\"> var list = new can.Observe.List();\n list.bind('change', function(ev, index, how, newVal, oldVal) {\n     console.log(ev + ', ' + index + ', ' + how + ', ' + newVal + ', ' + oldVal);\n });\n\n list.attr(['Alexis', 'Bill']); // [object Object], 0, add, ['Alexis', 'Bill'], undefined\n list.attr(2, 'Eve');           // [object Object], 2, add, Eve, undefined\n list.attr(0, 'Adam');          // [object Object], 0, set, Adam, Alexis\n list.attr(['Alice', 'Bob']);   // [object Object], 0, set, Alice, Adam\n                                // [object Object], 1, set, Bob, Bill\n list.removeAttr(1);            // [object Object], 1, remove, undefined, Bob</code></pre>\n\n<p>## The <em>set</em> event</p>\n\n<p><em>set</em> events are fired when an element at an index that already exists in the List is\n modified. Actions can cause <em>set</em> events to fire never also cause <em>length</em> events\n to fire (although some functions, such as <code>[can.Observe.List.prototype.splice splice]</code>\n may cause unrelated sets of events to fire after being batched).</p>\n\n<p>The parameters of the event handler for the <em>set</em> event are:</p>\n\n<ul>\n<li><em>ev</em> The event object.</li>\n<li><em>newVal</em> The new value of the element.</li>\n<li><p><em>index</em> where the set took place.</p>\n\n<p>Here is a concrete tour through the <em>set</em> event handler's arguments:</p></li>\n</ul>\n\n<pre><code class=\"lang-javascript\"> var list = new can.Observe.List();\n list.bind('set', function(ev, newVal, index) {\n     console.log(newVal + ', ' + index);\n });\n\n list.attr(['Alexis', 'Bill']);\n list.attr(2, 'Eve');          \n list.attr(0, 'Adam');          // Adam, 0\n list.attr(['Alice', 'Bob']);   // Alice, 0\n                                // Bob, 1\n list.removeAttr(1);            </code></pre>\n\n<p>## The <em>add</em> event</p>\n\n<p><em>add</em> events are fired when elements are added or inserted\n into the List.</p>\n\n<p>The parameters of the event handler for the <em>add</em> event are:</p>\n\n<ul>\n<li><em>ev</em> The event object.</li>\n<li><em>newElements</em> The new elements.\nIf more than one element is added, <em>newElements</em> will be an array.\nOtherwise, it is simply the new element itself.</li>\n<li><p><em>index</em> Where the add or insert took place.</p>\n\n<p>Here is a concrete tour through the <em>add</em> event handler's arguments:</p></li>\n</ul>\n\n<pre><code class=\"lang-javascript\"> var list = new can.Observe.List();\n list.bind('add', function(ev, newElements, index) {\n     console.log(newElements + ', ' + index);\n });\n\n list.attr(['Alexis', 'Bill']); // ['Alexis', 'Bill'], 0\n list.attr(2, 'Eve');           // Eve, 2\n list.attr(0, 'Adam');          \n list.attr(['Alice', 'Bob']);   \n\n list.removeAttr(1);            </code></pre>\n\n<p>## The <em>remove</em> event</p>\n\n<p><em>remove</em> events are fired when elements are removed from the list.</p>\n\n<p>The parameters of the event handler for the <em>remove</em> event are:</p>\n\n<ul>\n<li><em>ev</em> The event object.</li>\n<li><em>removedElements</em> The removed elements.\nIf more than one element was removed, <em>removedElements</em> will be an array.\nOtherwise, it is simply the element itself.</li>\n<li><p><em>index</em> Where the removal took place.</p>\n\n<p>Here is a concrete tour through the <em>remove</em> event handler's arguments:</p></li>\n</ul>\n\n<pre><code class=\"lang-javascript\"> var list = new can.Observe.List();\n list.bind('remove', function(ev, removedElements, index) {\n     console.log(removedElements + ', ' + index);\n });\n\n list.attr(['Alexis', 'Bill']); \n list.attr(2, 'Eve');           \n list.attr(0, 'Adam');          \n list.attr(['Alice', 'Bob']);   \n\n list.removeAttr(1);            // Bob, 1</code></pre>\n\n<p>## The <em>length</em> event</p>\n\n<p><em>length</em> events are fired whenever the list changes.</p>\n\n<p>The parameters of the event handler for the <em>length</em> event are:</p>\n\n<ul>\n<li><p><em>ev</em> The event object.</p>\n\n<ul><li><em>length</em> The current length of the list.\nIf events were batched when the <em>length</em> event was triggered, <em>length</em>\nwill have the length of the list when <code>stopBatch</code> was called. Because\nof this, you may recieve multiple <em>length</em> events with the same\n<em>length</em> parameter.</li></ul>\n\n<p>Here is a concrete tour through the <em>length</em> event handler's arguments:</p></li>\n</ul>\n\n<pre><code class=\"lang-javascript\"> var list = new can.Observe.List();\n list.bind('length', function(ev, length) {\n     console.log(length);\n });\n\n list.attr(['Alexis', 'Bill']); // 2\n list.attr(2, 'Eve');           // 3\n list.attr(0, 'Adam');          \n list.attr(['Alice', 'Bob']);   \n\n list.removeAttr(1);            // 2</code></pre>         ",
                            "description": "<p>Get or set elements in a List. </p>",
                            "title": "attr",
                            "signatures": [{
                                    "code": "attr()",
                                    "description": "<p>Gets a collection of all the elements in this <code>can.Observe.List</code>.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Array"
                                            }
                                        ],
                                        "description": "<p>array with all the elements in this List.</p>"
                                    }
                                }, {
                                    "code": "attr(index)",
                                    "description": "<p>Reads a element from this <code>can.Observe.List</code>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>the element to read</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the value at <em>index</em>.</p>"
                                    }
                                }, {
                                    "code": "attr(index, value)",
                                    "description": "<p>Assigns <em>value</em> to the index <em>index</em> on this <code>can.Observe.List</code>, expanding the list if necessary.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>the element to set</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "the",
                                            "description": "<p>value to assign at <em>index</em></p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe.List"
                                            }
                                        ],
                                        "description": "<p>this List, for chaining</p>"
                                    }
                                }, {
                                    "code": "attr(elements[, replaceCompletely])",
                                    "description": "<p>Merges the members of <em>elements</em> into this List, replacing each from the beginning in order. If\n <em>elements</em> is longer than the current List, the current List will be expanded. If <em>elements</em>\n is shorter than the current List, the extra existing members are not affected (unless\n <em>replaceCompletely</em> is <code>true</code>). To remove elements without replacing them, use <code>[can.Observe.List.prototype.removeAttr removeAttr]</code>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Array"
                                                }
                                            ],
                                            "name": "elements",
                                            "description": "<p>an array of elements to merge in</p>"
                                        }, {
                                            "types": [{
                                                    "type": "bool"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "replaceCompletely",
                                            "defaultValue": "false",
                                            "description": "<p>whether to completely replace the elements of List\n If <em>replaceCompletely</em> is <code>true</code> and <em>elements</em> is shorter than the List, the existing\n extra members of the List will be removed.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe.List"
                                            }
                                        ],
                                        "description": "<p>this List, for chaining</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1270,
                            "id": 36
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.concat",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>concat</code> makes a new List with the elements of the List followed by the elements of the parameters.</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new can.Observe.List(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]</code></pre>     ",
                            "description": "<p>Merge many collections together into a List. </p>",
                            "title": "concat",
                            "signatures": [{
                                    "code": "concat(...args)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Array"
                                                }, {
                                                    "type": "can.Observe.List"
                                                }, {
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "args",
                                            "description": "<p>Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1895,
                            "id": 45
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.forEach",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>forEach</code> calls a callback for each element in the List.</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.attr(index, element * element);\n});\nlist.attr(); // [1, 4, 9]</code></pre>     ",
                            "description": "<p>Call a function for each element of a List. </p>",
                            "title": "forEach",
                            "signatures": [{
                                    "code": "forEach(callback[, thisArg])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": [{
                                                            "types": [{
                                                                    "type": "element"
                                                                }
                                                            ]
                                                        }, {
                                                            "types": [{
                                                                    "type": "index"
                                                                }
                                                            ]
                                                        }, {
                                                            "types": [{
                                                                    "type": "list"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "name": "callback",
                                            "description": "<p>a function to call with each element of the List\nThe three parameters that <em>callback</em> gets passed are <em>element</em>, the element at <em>index</em>, <em>index</em> the\ncurrent element of the list, and <em>list</em> the List the elements are coming from.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "thisArg",
                                            "description": "<p>the object to use as <code>this</code> inside the callback</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1925,
                            "id": 46
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.indexOf",
                            "parent": "can.Observe.List.prototype",
                            "body": "<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1</code></pre>\n\n<p>It is trivial to make a <code>contains</code>-type function using <code>indexOf</code>:</p>\n\n<pre><code class=\"lang-javascript\">function(list, item) {\n    return list.indexOf(item) >= 0;\n}</code></pre>     ",
                            "description": "<p>Look for an item in a List. </p>",
                            "title": "indexOf",
                            "signatures": [{
                                    "code": "indexOf(item)",
                                    "description": "<p><code>indexOf</code> finds the position of a given item in the List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "item",
                                            "description": "<p>the item to find</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>the position of the item in the List, or -1 if the item is not found.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1785,
                            "id": 41
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.join",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n\nvar beatles = new can.Observe.List(['John', 'Paul', 'Ringo', 'George']);\nbeatles.join('&'); // 'John&Paul&Ringo&George'</code></pre>     ",
                            "description": "<p>Join a List's elements into a string. </p>",
                            "title": "join",
                            "signatures": [{
                                    "code": "join(separator)",
                                    "description": "<p><code>join</code> turns a List into a string by inserting <em>separator</em> between the string representations\nof all the elements of the List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "separator",
                                            "description": "<p>the string to seperate elements with</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "String"
                                            }
                                        ],
                                        "description": "<p>the joined string</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1816,
                            "id": 42
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.pop",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>pop</code> is the opposite action from <code>[can.Observe.List.push push]</code>:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined</code></pre>\n\n<h2>Events</h2>\n\n<p><code>pop</code> causes <em>change</em>, <em>remove</em>, and <em>length</em> events to be fired if the List is not empty\nwhen it is called.</p>\n\n<h2>See also</h2>\n\n<p><code>pop</code> has its counterpart in [can.Observe.List.push push], or you may be\nlooking for [can.Observe.List.unshift unshift] and its counterpart [can.Observe.List.shift shift].</p>",
                            "description": "<p>Remove an element from the end of a List. </p>",
                            "title": "pop",
                            "signatures": [{
                                    "code": "pop()",
                                    "description": "<p><code>push</code> removes an element from the end of a List.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the element just popped off the List, or <code>undefined</code> if the List was empty</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1689,
                            "id": 39
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.push",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>push</code> is fairly straightforward:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']</code></pre>\n\n<p>If you have an array you want to concatenate to the end\nof the List, you can use <code>apply</code>:</p>\n\n<pre><code class=\"lang-javascript\">var names = ['Bob', 'Eve'],\n    list = new can.Observe.List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Alice', 'Bob', 'Eve']</code></pre>\n\n<h2>Events</h2>\n\n<p><code>push</code> causes <em>change</em>, <em>add</em>, and <em>length</em> events to be fired.</p>\n\n<h2>See also</h2>\n\n<p><code>push</code> has a counterpart in [can.Observe.List.pop pop], or you may be\nlooking for [can.Observe.List.unshift unshift] and its counterpart [can.Observe.List.shift shift].</p>",
                            "description": "<p>Add elements to the end of a list. </p>",
                            "title": "push",
                            "signatures": [{
                                    "code": "push(...elements)",
                                    "description": "<p><code>push</code> adds elements onto the end of a List.]</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "elements",
                                            "description": "<p>the elements to add to the List</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>the new length of the List</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1568,
                            "id": 37
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.replace",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>replace</code> replaces all the elements of this List with new ones.</p>\n\n<p><code>replace</code> is especially useful when <code>can.Observe.List</code>s are live-bound into <code>[can.Control]</code>s,\nand you intend to populate them with the results of a <code>[can.Model]</code> call:</p>\n\n<pre><code class=\"lang-javascript\">can.Control({\n    init: function() {\n        this.list = new Todo.List();\n        // live-bind the list into the DOM\n        this.element.html(can.view('list.mustache', this.list));\n        // when this AJAX call returns, the live-bound DOM will be updated\n        this.list.replace(Todo.findAll());\n    }\n});</code></pre>\n\n<p>Learn more about [can.Model.List making Lists of models].</p>\n\n<h2>Events</h2>\n\n<p>A major difference between <code>replace</code> and <code>attr(newElements, true)</code> is that <code>replace</code> always emits\nan<em>add</em> event and a <em>remove</em> event, whereas <code>attr</code> will cause <em>set</em> events along an <em>add</em> or <em>remove</em>\nevent if needed. Corresponding <em>change</em> and <em>length</em> events will be fired as well.</p>\n\n<p>The differences in the events fired by <code>attr</code> and <code>replace</code> are demonstrated concretely by this example:</p>\n\n<pre><code class=\"lang-javascript\">var attrList = new can.Observe.List(['Alexis', 'Bill']);\nattrList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nvar replaceList = new can.Observe.List(['Alexis', 'Bill']);\nreplaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nattrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n                                              // 1, set, Ben, Bill\nreplaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n                                              // 0, add, undefined, ['Adam', 'Ben']\n\nattrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n                                              // 1, remove, undefined, Ben\nreplaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n                                              // 0, add, Amber, ['Adam', 'Ben']\n\nattrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n                                              // 1, add, ['Bob', 'Eve'], undefined\nreplaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n                                              // 0, add, ['Alice', 'Bob', 'Eve'], Amber</code></pre>     ",
                            "description": "<p>Replace all the elements of a List. </p>",
                            "title": "replace",
                            "signatures": [{
                                    "code": "replace(collection)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Array"
                                                }, {
                                                    "type": "can.Observe.List"
                                                }, {
                                                    "type": "can.Deferred"
                                                }
                                            ],
                                            "name": "collection",
                                            "description": "<p>the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an <code>Array</code> or <code>can.Observe.List</code>.\nThe elements of the list are not actually removed until the Deferred resolves.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1949,
                            "id": 47
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.reverse",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true</code></pre>     ",
                            "description": "<p>Reverse the order of a List. </p>",
                            "title": "reverse",
                            "signatures": [{
                                    "code": "reverse()",
                                    "description": "<p><code>reverse</code> reverses the elements of the List in place.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe.List"
                                            }
                                        ],
                                        "description": "<p>the List, for chaining</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1839,
                            "id": 43
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.serialize",
                            "params": [],
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Returns the serialized form of this list.</p>",
                            "hide": true,
                            "src": "can/observe/observe.js",
                            "line": 1138,
                            "id": 33
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.shift",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>shift</code> is the opposite action from <code>[can.Observe.List.unshift unshift]</code>:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n\nlist.shift(); // 'Bob'\nlist.shift(); // 'Eve'\nlist.shift(); // 'Alice'\nlist.shift(); // undefined</code></pre>\n\n<h2>Events</h2>\n\n<p><code>pop</code> causes <em>change</em>, <em>remove</em>, and <em>length</em> events to be fired if the List is not empty\nwhen it is called.</p>\n\n<h2>See also</h2>\n\n<p><code>shift</code> has a counterpart in [can.Observe.List.unshift unshift], or you may be\nlooking for [can.Observe.List.push push] and its counterpart [can.Observe.List.pop pop].</p>",
                            "description": "<p>Remove en element from the front of a list. </p>",
                            "title": "shift",
                            "signatures": [{
                                    "code": "shift()",
                                    "description": "<p><code>shift</code> removes an element from the beginning of a List.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the element just shifted off the List, or <code>undefined</code> if the List is empty</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1724,
                            "id": 40
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.slice",
                            "parent": "can.Observe.List.prototype",
                            "body": "<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList.attr(); // ['Bob', 'Charlie', 'Daniel']</code></pre>\n\n<p><code>slice</code> is the simplest way to copy a List:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy.attr();   // ['Alice', 'Bob', 'Eve']\nlist === copy; // false</code></pre>     ",
                            "description": "<p>Make a copy of a part of a List. </p>",
                            "title": "slice",
                            "signatures": [{
                                    "code": "slice([start[, end]])",
                                    "description": "<p><code>slice</code> creates a copy of a portion of the List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "start",
                                            "defaultValue": "0",
                                            "description": "<p>the index to start copying from</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "end",
                                            "description": "<p>the first index not to include in the copy\nIf <em>end</em> is not supplied, <code>slice</code> will copy until the end of the list.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe.List"
                                            }
                                        ],
                                        "description": "<p>a new <code>can.Observe.List</code> with the extracted elements</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1859,
                            "id": 44
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.splice",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>splice</code> lets you remove elements from and insert elements into a List.</p>\n\n<p>This example demonstrates how to do surgery on a list of numbers:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.attr(); // [0, 1, 'Alice', 'Bob', 3]</code></pre>\n\n<h2>Events</h2>\n\n<p><code>splice</code> causes the List it's called on to emit <em>change</em> events,\n<em>add</em> events, <em>remove</em> events, and <em>length</em> events. If there are\nany elements to remove, a <em>change</em> event, a <em>remove</em> event, and a\n<em>length</em> event will be fired. If there are any elements to insert, a\nseparate <em>change</em> event, an <em>add</em> event, and a separate <em>length</em> event\nwill be fired. </p>\n\n<p>This slightly-modified version of the above example should help\nmake it clear how <code>splice</code> causes events to be emitted:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['a', 'b', 'c', 'd']);\nlist.bind('change', function(ev, attr, how, newVals, oldVals) {\n    console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\nlist.bind('add', function(ev, newVals, where) {\n    console.log('add: ' + newVals + ', ' + where);\n});\nlist.bind('remove', function(ev, oldVals, where) {\n    console.log('remove: ' + oldVals + ', ' + where);\n});\nlist.bind('length', function(ev, length) {\n    console.log('length: ' + length + ', ' + this.attr());\n});\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                   // remove: ['c'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                   // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                   // add: ['Alice', 'Bob'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']</code></pre>\n\n<p>More information about binding to these events can be found under [can.Observe.List.attr attr].</p>",
                            "description": "<p>Insert and remove elements from a List. </p>",
                            "title": "splice",
                            "signatures": [{
                                    "code": "splice(index[, howMany[, ...newElements]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>where to start removing or inserting elements</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "howMany",
                                            "description": "<p>the number of elements to remove\nIf <em>howMany</em> is not provided, <code>splice</code> will all elements from <code>index</code> to the end of the List.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "newElements",
                                            "description": "<p>elements to insert into the List</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Array"
                                            }
                                        ],
                                        "description": "<p>the elements removed by <code>splice</code></p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1181,
                            "id": 35
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.unshift",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>unshift</code> adds elements to the front of the list in bulk in the order specified:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']</code></pre>\n\n<p>If you have an array you want to concatenate to the beginning\nof the List, you can use <code>apply</code>:</p>\n\n<pre><code class=\"lang-javascript\">var names = ['Bob', 'Eve'],\n    list = new can.Observe.List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Bob', 'Eve', 'Alice']</code></pre>\n\n<h2>Events</h2>\n\n<p><code>unshift</code> causes <em>change</em>, <em>add</em>, and <em>length</em> events to be fired.</p>\n\n<h2>See also</h2>\n\n<p><code>unshift</code> has a counterpart in [can.Observe.List.shift shift], or you may be\nlooking for [can.Observe.List.push push] and its counterpart [can.Observe.List.pop pop].</p>",
                            "description": "<p>Add elements to the beginning of a List. </p>",
                            "title": "unshift",
                            "signatures": [{
                                    "code": "unshift(...elements)",
                                    "description": "<p><code>unshift</code> adds elements onto the beginning of a List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "elements",
                                            "description": "<p>the elements to add to the List</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>the new length of the List</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1610,
                            "id": 38
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "name": "can.compute",
            "type": "constructor",
            "body": "<p><code>can.compute</code> lets you make observable values. A compute is actually a function that returns\nthe computed value, but you can also use the compute to set the value and you can use\n<code>bind</code> to listen to changes in the compute's return value. In this way, computes are similar\nto [can.Observe Observes], but they represent a single value rather than a collection of values.</p>\n\n<h2>Working with computes</h2>\n\n<p>The simplest way to use a compute is to have it store a single value, and to set it when\nthat value needs to change:</p>\n\n<pre><code class=\"lang-javascript\">var tally = can.compute(12);\ntally(); // 12\n\ntally(13);\ntally(); // 13</code></pre>\n\n<p>This is useful for making observable values, but the real power of <code>can.compute</code> reveals\nitself when you combine it with <code>[can.Observe]</code>. If you use a compute that derives its\nvalue from properties of an Observe, the compute will listen for changes in those\nproperties and automatically recalculate itself, emitting a <em>change</em> event if its value\nchanges.</p>\n\n<p>As this example shows, this kind of compute rarely has need to be set directly:</p>\n\n<pre><code class=\"lang-javascript\">var person = new can.Observe({\n    firstName: 'Alice',\n    lastName: 'Liddell'\n});\n\nvar fullName = can.compute(function() {\n    return person.attr('firstName') + ' ' + person.attr('lastName');\n});\nfullName.bind('change', function(ev, newVal, oldVal) {\n    console.log(\"This person's full name is now \" + newVal + '.');\n});\n\nperson.attr('firstName', 'Allison'); // The log reads:\n                                     // \"This person's full name is now Allison Liddell.\"</code></pre>\n\n<p>Take special notice of how the definition of the compute uses <code>[can.Observe.prototype.attr attr]</code>\nto read the values of the properties of <code>person</code>. This is how the compute knows to listen\nfor changes. and is similar to the need to use <code>attr</code> when live-binding properties of Observes into\n<code>[can.EJS EJS]</code> templates.</p>\n\n<p>A specific use for bound computes like this is to provide a way to work with values of Observable\nproperties in different units:</p>\n\n<pre><code class=\"lang-javascript\">var wall = new can.Observe({\n    material: 'brick',\n    length: 10 // in feet\n});\n\nvar wallLengthInMeters = can.compute(function(lengthInM) {\n    if(lengthInM !== undefined) {\n        wall.attr('length', lengthInM / 3.28084);\n    } else {\n        return wall.attr('length') * 3.28084;\n    }\n});\n\nwallLengthInMeters(); // 3.048\n\n// When you set the compute...\nwallLengthInMeters(5);\nwallLengthInMeters(); // 5\n// ...the original Observe changes too.\nwall.length;          // 16.4042</code></pre>\n\n<h2>Events</h2>\n\n<p>When a compute's value is changed, it emits a <em>change</em> event. You can listen for this change\nevent by using <code>[can.compute.bind bind]</code> to bind an event handler to the compute:</p>\n\n<pre><code class=\"lang-javascript\">var tally = can.compute(0);\ntally.bind('change', function(ev, newVal, oldVal) {\n    console.log('The tally is now at ' + newVal + '.');\n});\n\ntally(tally() + 5); // The log reads:\n                    // 'The tally is now at 5.'</code></pre>\n\n<h2>Using computes to build Controls</h2>\n\n<p>It's a piece of cake to build a <code>[can.Control]</code> off of the value of a compute. And since computes\nare observable, it means that the view of that Control will update itself whenever the value\nof the compute updates. Here's a simple slider that works off of a compute:</p>\n\n<pre><code class=\"lang-javascript\">var project = new Observe({\n    name: 'A Very Important Project',\n    percentDone: .35\n});\n\ncan.Control('SimpleSlider', { }, {\n    init: function() {\n        this.element.html(can.view(this.options.view, this.options));\n    },\n    '.handle dragend': function(el, ev) {\n        var percent = this.calculateSliderPercent();\n        // set the compute's value\n        this.options.percentDone(percent);\n    },\n    '{percentDone} change': function(ev, newVal, oldVal) {\n       // react to the percentage changing some other way\n        this.moveSliderTo(newVal);\n    }\n    // Implementing calculateSliderPercent and moveSliderTo\n    // has been left as an exercise for the reader.\n});\n\nnew SimpleSlider('#slider', {percentDone: project.compute('percentDone')});</code></pre>\n\n<p>Now that's some delicious cake. More information on Controls can be found under <code>[can.Control]</code>.\nThere is also a full explanation of can.Observe's <code>[can.Observe.prototype.compute compute]</code>,\nwhich is used in the last line of the example above.</p>",
            "description": "",
            "parent": "canjs",
            "comment": " ",
            "signatures": [{
                    "code": "can.compute(getterSetter[, context])",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "function",
                                    "returns": {
                                        "types": [{
                                                "type": "undefined"
                                            }
                                        ]
                                    },
                                    "params": []
                                }
                            ],
                            "name": "getterSetter",
                            "description": "<p>A function that gets and optionally sets the value of the compute.\nWhen called with no parameters, <em>getterSetter</em> should return the current value of the compute. When\ncalled with a single parameter, <em>getterSetter</em> should arrange things so that the next read of the compute\nproduces that value.</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "context",
                            "description": "<p>The context to use when evaluating the compute.</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.compute"
                            }
                        ],
                        "description": "<p>A new compute.</p>"
                    }
                }
            ],
            "src": "can/observe/compute/compute.js",
            "line": 132,
            "id": 74
        }, {
            "active": false,
            "type": "page",
            "name": "can.fixture",
            "body": "",
            "description": "<p><code>can.util.fixture</code> intercepts an AJAX request and simulates\nthe response with a file or function. They are a great technique\nwhen you want to develop JavaScript\nindependently of the backend.</p>\n\n<h2>Types of Fixtures</h2>\n\n<p>There are two common ways of using fixtures.  The first is to\nmap Ajax requests to another file.  The following\nintercepts requests to <code>/tasks.json</code> and directs them\nto <code>fixtures/tasks.json</code>:</p>\n\n<pre><code>can.fixture(\"/tasks.json\", \"fixtures/tasks.json\");\n</code></pre>\n\n<p>The other common option is to generate the Ajax response with\na function.  The following intercepts updating tasks at\n<code>/tasks/ID.json</code> and responds with updated data:</p>\n\n<pre><code>can.fixture(\"PUT /tasks/{id}.json\",\n  function(original, respondWith, settings){\n     respondWith({ updatedAt : new Date().getTime() });\n  })\n</code></pre>\n\n<p>We categorize fixtures into the following types:</p>\n\n<ul>\n<li><strong>Static</strong> - the response is in a file.</li>\n<li><strong>Dynamic</strong> - the response is generated by a function.</li>\n</ul>\n\n<p>There are different ways to lookup static and dynamic fixtures.</p>\n\n<h2>Static Fixtures</h2>\n\n<p>Static fixtures use an alternate url as the response of the Ajax request.</p>\n\n<pre><code>// looks in fixtures/tasks1.json relative to page\ncan.fixture(\"tasks\", \"fixtures/tasks.json\");\n\n// looks absolute to the page\ncan.fixture(\"tasks\", \"//fixtures/tasks.json\");\n</code></pre>\n\n<p>Static fixtures can also be templated, which means that parameters will be\nused in the fixture filename:</p>\n\n<pre><code>// looks in fixtures/tasks1.json relative to page\ncan.fixture(\"tasks/{id}\", \"fixtures/tasks.{id}.json\");\n</code></pre>\n\n<p>A request to <code>tasks/42</code> will look for a <code>fixtures/tasks.42.json</code> file.</p>\n\n<h2>Dynamic Fixtures</h2>\n\n<p>Dynamic Fixtures are functions that get the details of the Ajax request and return the result of the mocked service\nrequest from your server.</p>\n\n<p>For example, the following returns a successful response with JSON data from the server:</p>\n\n<pre><code>can.fixture(\"/foobar.json\",\n  function(original, respondWith, settings){\n    respondWith(200, \"success\", { json: {foo: \"bar\" } }, {})\n  })\n</code></pre>\n\n<p>The fixture function has the following signature:</p>\n\n<pre><code>function( originalOptions, respondWith, options) {\n  respond(status, statusText, responses, responseHeaders);\n}\n</code></pre>\n\n<p>where the fixture function is called with:</p>\n\n<ul>\n<li><code>originalOptions</code> - are the options provided to the ajax method, unmodified,\nand thus, without defaults from ajaxSettings</li>\n<li><code>respondWith</code> - the response callback. It can be called with:\n<ul><li><code>status</code> - the HTTP status code of the response.</li>\n<li><code>statusText</code> - the status text of the response</li>\n<li><code>responses</code> - a map of dataType/value that contains the responses for each data format supported</li>\n<li><code>responseHeaders</code> - response headers</li></ul></li>\n<li><code>options</code> - are the request options</li>\n<li><code>headers</code> - a map of key/value request headers</li>\n</ul>\n\n<p>However, can.fixture handles the common case where you want a successful response with JSON data.\nThe previous can be written like:</p>\n\n<pre><code>can.fixture(\"/foobar.json\",\n  function(original, respondWith, settings){\n    respondWith({ foo: \"bar\" });\n  })\n</code></pre>\n\n<p>Since <code>respondWith</code> is called asynchronously you can also set a custom fixture timeout like this:</p>\n\n<pre><code>can.fixture(\"/foobar.json\",\nfunction(original, respondWith, settings){\n    setTimeout(function() {\n      respondWith({ foo: \"bar\" });\n    }, 1000);\n  })\n</code></pre>\n\n<p>If you want to return an array of data respond like this:</p>\n\n<pre><code>can.fixture(\"/tasks.json\",\n  function(original, respondWith, settings){\n    respondWith([ \"first\", \"second\", \"third\"]);\n  })\n</code></pre>\n\n<p><strong>Note:</strong> A fixture function can also return its response directly like this:</p>\n\n<pre><code>can.fixture(\"/foobar.json\", function() {\n  return { foo: \"bar\" };\n})\n</code></pre>\n\n<p>This is kept for backwards compatibility and should not be used.</p>\n\n<p>can.fixture works closesly with <a href=\"http://api.jquery.com/extending-ajax/\">jQuery's ajaxTransport</a> system.</p>\n\n<h3>Templated Urls</h3>\n\n<p>Often, you want a dynamic fixture to handle urls for multiple resources (for example a REST url scheme).\ncan.fixture's templated urls allow you to match urls with a wildcard.</p>\n\n<p>The following example simulates services that get and update 100 todos.</p>\n\n<pre><code>// create todos\nvar todos = {};\nfor(var i = 0; i &lt; 100; i++) {\n  todos[i] = {\n    id: i,\n    name: \"Todo \"+i\n  }\n}\ncan.fixture(\"GET /todos/{id}\",\n  function(original, respondWith, settings){\n    // return the JSON data\n    // notice that id is pulled from the url and added to data\n    respondWith(todos[orig.data.id]);\n  })\n\ncan.fixture(\"PUT /todos/{id}\",\n  function(original, respondWith, settings){\n    // update the todo's data\n    can.extend(todos[orig.data.id], orig.data );\n    respondWith({});\n  })\n</code></pre>\n\n<p>Notice that data found in templated urls (ex: <code>{id}</code>) is added to the original data object.</p>\n\n<h2>Simulating Errors</h2>\n\n<p>The following simulates an unauthorized request\nto <code>/foo</code>.</p>\n\n<pre><code>can.fixture(\"/foo\",\n  function(original, respondWith, settings) {\n    respondWith(401,\"{type: 'unauthorized'}\");\n  });\n</code></pre>\n\n<p>This could be received by the following Ajax request:</p>\n\n<pre><code>can.ajax({\n  url: '/foo',\n  error : function(jqXhr, status, statusText){\n    // status === 'error'\n    // statusText === \"{type: 'unauthorized'}\"\n  }\n})\n</code></pre>\n\n<h2>Turning off Fixtures</h2>\n\n<p>You can remove a fixture by passing <code>null</code> for the fixture option:</p>\n\n<pre><code>// add a fixture\ncan.fixture(\"GET todos.json\",\"//fixtures/todos.json\");\n\n// remove the fixture\ncan.fixture(\"GET todos.json\", null)\n</code></pre>\n\n<p>You can also set [can.fixture.on] to false:</p>\n\n<pre><code>can.fixture.on = false;\n</code></pre>\n\n<h2>Make</h2>\n\n<p>[can.fixture.store] makes a CRUD service layer that handles sorting, grouping, filtering and more. Use\nit with a [can.Model] like this:</p>\n\n<pre><code>var Todo = can.Model({\n  findAll : 'GET /todos',\n  findOne : 'GET /todos/{id}',\n  create  : 'POST /todos',\n  update  : 'PUT /todos/{id}',\n  destroy : 'DELETE /todos/{id}'\n  }, {});\n\nvar store = can.fixture.store(100, function(i) {\n  return {\n    id : i,\n    name : 'Todo ' + i\n  }\n});\n\ncan.fixture('GET /todos', store.findAll);\ncan.fixture('GET /todos/{id}', store.findOne);\ncan.fixture('POST /todos', store.create);\ncan.fixture('PUT /todos/{id}', store.update);\ncan.fixture('DELETE /todos/{id}', store.destroy);\n</code></pre>\n\n<h2>Testing Performance</h2>\n\n<p>Dynamic fixtures are awesome for performance testing.  Want to see what\n10000 files does to your app's performance?  Make a fixture that returns 10000 items.</p>\n\n<p>What to see what the app feels like when a request takes 5 seconds to return?  Set\n[can.fixture.delay] to 5000.</p>\n\n<h2>Organizing fixture</h2>\n\n<p>The <strong>best</strong> way of organizing fixtures is to have a 'fixtures.js' file that steals\n<code>can/util/fixture</code> and defines all your fixtures.  For example,\nif you have a 'todo' application, you might\nhave <code>todo/fixtures/fixtures.js</code> look like:</p>\n\n<pre><code>steal({\n        path: '//can/util/fixture.js',\n        ignore: true\n      })\n      .then(function(){\n\n  can.fixture({\n      type: 'get',\n      url: '/services/todos.json'\n    },\n    '//todo/fixtures/todos.json');\n\n  can.fixture({\n      type: 'post',\n      url: '/services/todos.json'\n    },\n    function(original, respondWith, settings){\n        respondWith({\n            id: Math.random(),\n            name: settings.data.name\n        })\n    });\n\n})\n</code></pre>\n\n<p><strong>Notice</strong>: We used steal's ignore option to prevent\nloading the fixture plugin in production.</p>\n\n<p>Finally, we steal <code>todo/fixtures/fixtures.js</code> in the\napp file (<code>todo/todo.js</code>) like:</p>\n\n<pre><code>steal({path: '//todo/fixtures/fixtures.js',ignore: true});\n\n//start of your app's steals\nsteal( ... )\n</code></pre>\n\n<p>We typically keep it a one liner so it's easy to comment out.</p>\n\n<h3>Switching Between Sets of Fixtures</h3>\n\n<p>If you are using fixtures for testing, you often want to use different\nsets of fixtures.  You can add something like the following to your fixtures.js file:</p>\n\n<pre><code>if( /fixtureSet1/.test( window.location.search) ){\n  can.fixture(\"/foo\",\"//foo/fixtures/foo1.json');\n} else if(/fixtureSet2/.test( window.location.search)){\n  can.fixture(\"/foo\",\"//foo/fixtures/foo1.json');\n} else {\n  // default fixtures (maybe no fixtures)\n}\n</code></pre>",
            "title": "can.fixture",
            "parent": "canjs",
            "test": "can/util/fixture/qunit.html",
            "src": "can/util/fixture/fixture.md",
            "id": 218
        }, {
            "active": false,
            "type": "function",
            "name": "can.route",
            "body": "<h2>Background Information</h2>\n\n<p>To support the browser's back button and bookmarking\nin an Ajax application, most applications use\nthe <code>window.location.hash</code>.  By\nchanging the hash (via a link or JavaScript), \none is able to add to the browser's history \nwithout changing the page.</p>\n\n<p>This provides the basics needed to\ncreate history enabled Ajax websites.  However,\n<code>can.route</code> addresses several other needs such as:</p>\n\n<ul>\n<li>Pretty urls (actually hashes)</li>\n<li>Keeping routes independent of application code</li>\n<li>Listening to specific parts of the history changing</li>\n<li>Setup / Teardown of widgets.</li>\n</ul>\n\n<h2>How it works</h2>\n\n<p><code>can.route</code> is a [can.Observe] that represents the\n<code>window.location.hash</code> as an \nobject.  For example, if the hash looks like:</p>\n\n<pre><code>#!type=videos&amp;id=5\n</code></pre>\n\n<p>the data in <code>can.route</code> looks like:</p>\n\n<pre><code>{ type: 'videos', id: 5 }\n</code></pre>\n\n<p><code>can.route</code> keeps the state of the hash in-sync with the <code>data</code> contained within \n<code>can.route</code>.</p>\n\n<h2>can.Observe</h2>\n\n<p><code>can.route</code> is a [can.Observe]. Understanding\n<code>can.Observe</code> is essential for using <code>can.route</code> correctly.</p>\n\n<p>You can listen to changes in an Observe with <code>bind(eventName, handler(ev, args...))</code> and\nchange can.route's properties with \n[can.Observe.prototype.attr attr].</p>\n\n<h3>Listening to changes in an Observable</h3>\n\n<p>Listen to changes in history \nby [can.Observe.prototype.bind bind]ing to\nchanges in <code>can.route</code> like:</p>\n\n<pre><code>can.route.bind('change', function(ev, attr, how, newVal, oldVal) {\n\n})\n</code></pre>\n\n<ul>\n<li><code>attr</code> - the name of the changed attribute</li>\n<li><code>how</code> - the type of Observe change event (add, set or remove)</li>\n<li><code>newVal</code>/<code>oldVal</code> - the new and old values of the attribute</li>\n</ul>\n\n<p>You can also listen to specific changes \nwith [can.Observe.delegate delegate]:</p>\n\n<pre><code>can.route.delegate('id','change', function(){ ... })\n</code></pre>\n\n<p>Observe lets you listen to the following events:</p>\n\n<ul>\n<li>change - any change to the object</li>\n<li>add - a property is added</li>\n<li>set - a property value is added or changed</li>\n<li>remove - a property is removed</li>\n</ul>\n\n<p>Listening for <code>add</code> is useful for widget setup\nbehavior, <code>remove</code> is useful for teardown.</p>\n\n<h3>Updating an observable</h3>\n\n<p>Create changes in the route data with [can.Observe.prototype.attr attr] like:</p>\n\n<pre><code>can.route.attr('type','images');\n</code></pre>\n\n<p>Or change multiple properties at once like:</p>\n\n<pre><code>can.route.attr({type: 'pages', id: 5}, true)\n</code></pre>\n\n<p>When you make changes to can.route, they will automatically\nchange the <code>hash</code>.</p>\n\n<h2>Creating a Route</h2>\n\n<p>Use <code>can.route(url, defaults)</code> to create a \nroute. A route is a mapping from a url to \nan object (that is the can.route's state). \nIn order to map to a specific properties in the url,\nprepend a colon to the name of the property like:</p>\n\n<pre><code>can.route( \"!#content/:type\" )\n</code></pre>\n\n<p>If no routes are added, or no route is matched, \ncan.route's data is updated with the [can.deparam deparamed]\nhash.</p>\n\n<pre><code>location.hash = \"#!type=videos\";\n// can.route -&gt; {type : \"videos\"}\n</code></pre>\n\n<p>Once routes are added and the hash changes,\ncan.route looks for matching routes and uses them\nto update can.route's data.</p>\n\n<pre><code>can.route( \"!#content/:type\" );\nlocation.hash = \"#!content/images\";\n// can.route -&gt; {type : \"images\"}\ncan.route.attr( \"type\", \"songs\" )\n// location.hash -&gt; \"#!content/songs\"\n</code></pre>\n\n<p>Default values can also be added:</p>\n\n<pre><code>can.route(\"content/:type\",{type: \"videos\" });\nlocation.hash = \"#!content/\"\n// can.route -&gt; {type : \"videos\"}\n</code></pre>\n\n<h2>Delay setting can.route</h2>\n\n<p>By default, <code>can.route</code> sets its initial data\non document ready.  Sometimes, you want to wait to set \nthis data.  To wait, call:</p>\n\n<pre><code>can.route.ready(false);\n</code></pre>\n\n<p>and when ready, call:</p>\n\n<pre><code>can.route.ready(true);\n</code></pre>\n\n<h2>Changing the route.</h2>\n\n<p>Typically, you never want to set <code>location.hash</code>\ndirectly.  Instead, you can change properties on <code>can.route</code>\nlike:</p>\n\n<pre><code>can.route.attr('type', 'videos')\n</code></pre>\n\n<p>This will automatically look up the appropriate \nroute and update the hash.</p>\n\n<p>Often, you want to create links.  <code>can.route</code> provides\nthe [can.route.link] and [can.route.url] helpers to make this \neasy:</p>\n\n<pre><code>can.route.link(\"Videos\", {type: 'videos'})\n</code></pre>\n\n<h2>Demo</h2>\n\n<p>The following demo shows the relationship between <code>window.location.hash</code>,\nroutes given to <code>can.data</code>,\n<code>can.route</code>'s data, and events on <code>can.data</code>.  Most properties \nare editable so experiment!</p>\n\n<div class='iframe_wrapper' data-iframe-src='can/route/demo.html' data-iframe-height='980'></div>\n\n<h2>IE Compatibility</h2>\n\n<p>Internet Explorer 6 and 7 does not support <code>window.onhashchange</code>. \nEven Internet Explorer 8 running in IE7 compatibility mode reports <code>true</code> \nfor <code>onhashchange</code> in window, even though the event isn't supported.</p>\n\n<p>If you are using jQuery, you can include Ben Alman's [HashChange Plugin http://benalman.com/projects/jquery-hashchange-plugin/]\nto support the event in the unsupported browser(s).  Include <code>can/route/hashchange.js</code>\nin your file to support those browsers.</p>\n\n<h2>Using routes with <code>can.Control</code></h2>\n\n<p>Using templated event handlers, it is possible to listen to changes to\n<code>can.route</code> within <code>can.Control</code>. This is convenient as it allows the\ncontrol to listen to and make changes whenever the route is modified, \neven outside of the control itself.</p>\n\n<pre><code>// create the route\ncan.route(\"!#content/:type\")\n\n// the route has changed\n\"{can.route} change\": function(ev, attr, how, newVal, oldVal) {\n    if (attr === \"type\") {\n        // the route has a type\n    }\n}\n</code></pre>\n\n<h3>Creating and binding routes with <code>can.Control.route</code></h3>\n\n<p>Using [can.Control.route], a builtin plugin to CanJS, cuts down on the amount\nof code needed to work with <code>can.route</code> in <code>can.Control</code>. With this plugin, it is possible\nto both create routes and bind to <code>can.route</code> at the same time. Instead of creating\nseveral routes to handle changes to <strong>type</strong> and <strong>id</strong>, write something like this\nin a control:</p>\n\n<pre><code>// the route is empty\n\"route\": function(data) {\n\n},\n// the route has a type\n\":type route\": function(data) {\n\n}, \n// the route has a type and id\n\":type/:id route\": function(data) {\n\n}\n</code></pre>\n\n<h3>Getting more specific with the <code>can.Observe.delegate</code> plugin</h3>\n\n<p>Sometimes, you might only want to trigger a function when the route changes\nonly once, even if the route change gets called multiple times. By using the \n[can.Observe.delegate] plugin, this is extremely easy. This plugin allows you to \nlisten to change, set, add, and remove on <code>can.route</code>.</p>\n\n<p>If you wanted to, say, show a list of recipes when  <strong>type</strong> was set to recipe\nand show a specific recipe when <strong>id</strong> was set, you could do something like:</p>\n\n<pre><code>\"{can.route} type=recipe set\": \n        function( ev, prop, how, newVal, oldVal ) {\n    // show list of recipes\n},\n\"recipe/:id\": function(data) {\n    // show a single recipe\n}\n</code></pre>\n\n<p>If we didn't only listen to when recipe is set, then every time we chose to\nshow a single recipe, we would create and show the list of recipes again which \nwould not very efficient.</p>",
            "description": "<p>can.route is a plugin that helps manage browser history and\nclient state by synchronizing the window.location.hash with\nan [can.Observe].</p>",
            "title": "can.route",
            "comment": " ",
            "inherits": "can.Observe",
            "download": "can/route",
            "test": "can/route/qunit.html",
            "parent": "canjs",
            "signatures": [{
                    "code": "can.route(template[, defaults])",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "name": "template",
                            "description": "<p>the fragment identifier to match.  The fragment identifier\nshould start with either a character (a-Z) or colon (:).  Examples:</p>\n\n<pre><code>can.route(\":foo\")\ncan.route(\"foo/:bar\")\n</code></pre>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "defaults",
                            "description": "<p>an object of default values</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.route"
                            }
                        ],
                        "description": ""
                    }
                }
            ],
            "src": "can/route/route.md",
            "id": 121
        }, {
            "active": false,
            "type": "page",
            "name": "can.util",
            "body": "",
            "description": "<p>Utility methods supported by CanJS</p>",
            "title": "can.util",
            "parent": "canjs",
            "comment": "undefined@group can.util.functions functions\n",
            "src": "can/util/util.md",
            "id": 183
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.view",
            "body": "",
            "description": "",
            "title": "",
            "parent": "canjs",
            "comment": " ",
            "signatures": [{
                    "code": "can.view(view, data, helpers)",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "name": "view",
                            "description": "<p>The URL to a template or the ID of a template.</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "data",
                            "description": "<p>Data to populate the template with.</p>"
                        }, {
                            "types": [{
                                    "type": "Object",
                                    "template": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ]
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ],
                            "name": "helpers",
                            "description": "<p>Helpers referenced in the template.</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "description": "<p>The template with the data interpolated into it.</p>"
                    }
                }
            ],
            "src": "can/view/view.md",
            "id": 130,
            "children": [{
                    "active": false,
                    "name": "can.view.cached",
                    "type": "property",
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>Cached are put in this object</p>",
                    "hide": true,
                    "types": [{
                            "type": "Object"
                        }
                    ],
                    "title": "view",
                    "src": "can/view/view.js",
                    "line": 206,
                    "id": 135
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.view.preload",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "name": "id",
                            "description": ""
                        }, {
                            "types": [{
                                    "type": "function",
                                    "returns": {
                                        "types": [{
                                                "type": "undefined"
                                            }
                                        ]
                                    },
                                    "params": []
                                }
                            ],
                            "name": "renderer",
                            "description": ""
                        }
                    ],
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>Called by a production script to pre-load a renderer function\ninto the view cache.</p>",
                    "hide": true,
                    "src": "can/view/view.js",
                    "line": 291,
                    "id": 140
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.view.registerScript",
                    "params": [{
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "type",
                            "description": ""
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "id",
                            "description": ""
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "src",
                            "description": ""
                        }
                    ],
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>Returns the text that </p>",
                    "hide": true,
                    "src": "can/view/view.js",
                    "line": 282,
                    "id": 139
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.view.registerView",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "name": "id",
                            "description": ""
                        }, {
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "name": "text",
                            "description": ""
                        }, {
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "name": "type",
                            "description": ""
                        }, {
                            "types": [{
                                    "type": "can.Deferred"
                                }
                            ],
                            "name": "def",
                            "description": ""
                        }
                    ],
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>Registers a view with <code>cached</code> object.  This is used\ninternally by this class and Mustache to hookup views.</p>",
                    "hide": true,
                    "src": "can/view/view.js",
                    "line": 453,
                    "id": 142
                }, {
                    "active": false,
                    "name": "can.view.text",
                    "type": "property",
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>should return something like steal(\"dependencies\",function(EJS){\n     return can.view.preload(\"ID\", options.text)\n})</p>",
                    "hide": true,
                    "src": "can/view/view.js",
                    "line": 598,
                    "id": 143
                }, {
                    "active": false,
                    "name": "hookups",
                    "type": "property",
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>A list of pending 'hookups'</p>",
                    "title": "",
                    "hide": true,
                    "src": "can/view/view.js",
                    "line": 176,
                    "id": 133
                }
            ]
        }
    ]
}