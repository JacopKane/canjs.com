{
    "active": false,
    "type": "page",
    "name": "canjs",
    "body": "",
    "description": "<p>CanJS API Documentation. </p>\n\n<h2>CanJS API Documentation</h2>\n\n<h3>What is CanJS?</h3>\n\n<p>CanJS makes building rich web applications easy. It provides a lightweight inheritance system,\nbookmark and back-button support, a powerful MVC core with live templates, and more &mdash;\nall for about 8k (minified and gzipped).</p>\n\n<p>CanJS is built to work with jQuery, Zepto, Dojo, YUI and Mootools right out of the box.</p>\n\n<p><a href=\"http://canjs.us/\">CanJS.us</a> is an overview and getting started guide to CanJS. Get up to\nspeed on CanJS, then come back here for a more detailed reference.</p>",
    "title": "CanJS",
    "parent": "index",
    "order": 0,
    "src": "can/can.md",
    "id": 0,
    "children": [{
            "active": false,
            "type": "constructor",
            "name": "can.Construct",
            "body": "",
            "description": "",
            "title": "",
            "plugin": "can/construct",
            "test": "can/construct/qunit.html",
            "parent": "canjs",
            "signatures": [{
                    "code": "can.Construct([name, [staticProperties,]] instanceProperties)",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "optional": true,
                            "name": "name",
                            "description": "<p>the namespace and name of the constructor</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "staticProperties",
                            "description": "<p>properties that will belong to the constructor</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "instanceProperties",
                            "description": "<p>properties that will belong to instances made with the constructor</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "description": "<p>The constructor.</p>\n\n<p>In the example below, <code>Animal</code> is a constructor function. All instances of <code>Animal</code> will have a <code>breathe</code>\nmethod, and the <code>Animal</code> constructor itself has a <code>legs</code> property.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('Animal', {\n    legs: 4\n}, {\n    init: function(sound) {\n        this.sound = sound;\n    }\n    speak: function() {\n        console.log(this.sound);\n    }\n});</code></pre>\n\n<p>You don't have to pass in a name. If you do, the constructor is assigned to that name globally. If not,\nyou'll want to make sure you save your constructor to use later:</p>\n\n<pre><code class=\"lang-javascript\">var Robot = can.Construct({\n    beep: function() {\n        console.log('Beep boop.');\n    }\n});</code></pre>\n\n<p>You can make instances by calling your constructor with the <code>new</code> keyword. When you do, the [can.Construct::init|init]\nmethod gets called (if you supplied one):</p>\n\n<pre><code class=\"lang-javascript\">var panther = new Animal({sound: 'growl'});\npanther.speak(); // \"growl\"\npanther instanceof Animal; // true</code></pre>\n\n<p>This becomes much more powerful when you add inheritance.</p>\n\n<h2>Inheritance</h2>\n\n<p>Subclasses with <code>can.Construct</code> are simple. All you need to do is call the base constructor\nwith the new function's static and instance properties. For example, we want our <code>Snake</code> to\nbe an <code>Animal</code>, but there are some differences:</p>\n\n<pre><code class=\"lang-javascript\">Animal('Snake', {\n    legs: 0\n}, {\n    init: function() {\n        this.sound = 'ssssss';\n    },\n    slither: function() {\n        console.log('slithering...');\n    }\n});\n\nvar baslisk = new Snake();\nbaslisk.speak();   // \"ssssss\"\nbaslisk.slither(); // \"slithering...\"\nbaslisk instanceof Snake;  // true\nbaslisk instanceof Animal; // true</code></pre>\n\n<p>Note that <code>Animal</code>'s <code>init</code> does not get called.</p>\n\n<h2>Static properties and inheritance</h2>\n\n<p>If you pass all three arguments to can.Construct, the second one will be attached directy to the\nconstructor, allowing you to imitate static properties and functions. You can access these\nproperties through the <code>[can.Construct::constructor|this.constructor]</code> property.</p>\n\n<p>Static properties can get overridden through inheritance just like instance properties. Let's see\nhow this works with <code>Animal</code> and <code>Snake</code>:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('Animal', {\n    legs: 4\n}, {\n    init: function(sound) {\n        this.sound = sound;\n    }\n    speak: function() {\n        console.log(this.sound);\n    }\n});\n\nAnimal('Snake', {\n    legs: 0\n}, {\n    init: function() {\n        this.sound = 'ssssss';\n    },\n    slither: function() {\n        console.log('slithering...');\n    }\n});\n\nAnimal.legs; // 4\nSnake.legs; // 0</code></pre>\n\n<h2>Plugins</h2>\n\n<p>There are two plugins available to help make using <code>can.Construct</code> even simpler.\n* [can.Construct.super] allows you to easily call base methods by making <code>this._super</code> available in inherited methods.\n* [can.Construct.proxy] helps you keep your scope straight when creating callbacks inside constructors.</p>"
                    }
                }
            ],
            "src": "can/construct/construct.md",
            "id": 1,
            "children": [{
                    "active": false,
                    "type": "static",
                    "body": "",
                    "description": "",
                    "name": "can.Construct.static",
                    "parent": "can.Construct",
                    "src": "can/construct/construct.js",
                    "line": 22,
                    "id": 2,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Construct.static.newInstance",
                            "parent": "can.Construct.static",
                            "body": "<p>Creates a new instance of the constructor function. This method is useful for creating new instances\nwith arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n<strong>new</strong> operator.</p>\n\n<h2>Example</h2>\n\n<p>The following creates a <code>Person</code> Construct and then creates a new instance of Person,\nusing <code>apply</code> on newInstance to pass arbitrary parameters.</p>\n\n<pre><code class=\"lang-javascript\">var Person = can.Construct({\n  init : function(first, middle, last) {\n    this.first = first;\n    this.middle = middle;\n    this.last = last;\n  }\n});\n\nvar args = [\"Justin\",\"Barry\",\"Meyer\"],\n    justin = new Person.newInstance.apply(null, args);</code></pre>     ",
                            "description": "<p>Create a new instance of a Construct. </p>",
                            "title": "newInstance",
                            "signatures": [{
                                    "code": "newInstance([...args])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "args",
                                            "description": "<p>arguments that get passed to [can.Construct::setup] and [can.Construct::init]. Note\nthat if [can.Construct::setup] returns an array, those arguments will be passed to [can.Construct::init]\ninstead.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "class"
                                            }
                                        ],
                                        "description": "<p>instance of the class</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/construct/construct.js",
                            "line": 26,
                            "id": 3
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Construct.static.setup",
                            "parent": "can.Construct.static",
                            "body": "<p>The static <code>setup</code> method is called immediately after a constructor function is created and \nset to inherit from its base constructor. It is useful for setting up additional inheritance work.\nDo not confuse this with the prototype <code>[can.Construct::setup]</code> method.</p>\n\n<h2>Setup Extends Defaults</h2>\n\n<p>Setup deeply extends the static <code>defaults</code> property of the base constructor with \nproperties of the inheriting constructor.  For example:</p>\n\n<pre><code class=\"lang-javascript\">Parent = can.Construct({\n  defaults : {\n    parentProp: 'foo'\n  }\n},{})\n\nChild = Parent({\n  defaults : {\n    childProp : 'bar'\n  }\n},{}\n\nChild.defaults // {parentProp: 'foo', 'childProp': 'bar'}</code></pre>\n\n<h2>Example</h2>\n\n<p>This <code>Parent</code> class adds a reference to its base class to itself, and\nso do all the classes that inherit from it.</p>\n\n<pre><code class=\"lang-javascript\">Parent = can.Construct({\n  setup : function(base, fullName, staticProps, protoProps){\n    this.base = base;\n\n    // call base functionality\n    can.Construct.setup.apply(this, arguments)\n  }\n},{});\n\nParent.base; // can.Construct\n\nChild = Parent({});\n\nChild.base; // Parent</code></pre>     ",
                            "description": "<p>Perform initialization logic for a constructor function. </p>",
                            "title": "setup",
                            "signatures": [{
                                    "code": "setup(base, fullName, staticProps, protoProps)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "constructor"
                                                }
                                            ],
                                            "name": "base",
                                            "description": "<p>The base constructor that is being inherited from.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "fullName",
                                            "description": "<p>The name of the new constructor.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "staticProps",
                                            "description": "<p>The static properties of the new constructor.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "protoProps",
                                            "description": "<p>The prototype properties of the new constructor.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/construct/construct.js",
                            "line": 93,
                            "id": 4
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Construct.static.extend",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "fullName",
                                    "description": "<p>the class's name (used for classes w/ introspection)</p>"
                                }, {
                                    "types": [{
                                            "type": "Object",
                                            "template": [{
                                                    "types": [{
                                                            "type": "string"
                                                        }
                                                    ]
                                                }, {
                                                    "types": [{
                                                            "type": "function",
                                                            "returns": {
                                                                "types": [{
                                                                        "type": "undefined"
                                                                    }
                                                                ]
                                                            },
                                                            "params": []
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ],
                                    "optional": true,
                                    "name": "klass",
                                    "description": "<p>the new class's static functions</p>"
                                }, {
                                    "types": [{
                                            "type": "Object",
                                            "template": [{
                                                    "types": [{
                                                            "type": "string"
                                                        }
                                                    ]
                                                }, {
                                                    "types": [{
                                                            "type": "function",
                                                            "returns": {
                                                                "types": [{
                                                                        "type": "undefined"
                                                                    }
                                                                ]
                                                            },
                                                            "params": []
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ],
                                    "optional": true,
                                    "name": "proto",
                                    "description": "<p>the new class's prototype functions</p>"
                                }
                            ],
                            "parent": "can.Construct.static",
                            "body": "",
                            "description": "<p>Extends a class with new static and prototype functions.  There are a variety of ways\nto use extend:</p>\n\n<pre><code>// with className, static and prototype functions\ncan.Construct('Task',{ STATIC },{ PROTOTYPE })\n// with just classname and prototype functions\ncan.Construct('Task',{ PROTOTYPE })\n// with just a className\ncan.Construct('Task')\n</code></pre>\n\n<p>You no longer have to use <code>extend</code>.  Instead, you can pass those options directly to\ncan.Construct (and any inheriting classes):</p>\n\n<pre><code>// with className, static and prototype functions\ncan.Construct('Task',{ STATIC },{ PROTOTYPE })\n// with just classname and prototype functions\ncan.Construct('Task',{ PROTOTYPE })\n// with just a className\ncan.Construct('Task')\n</code></pre>",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "can.Construct"
                                    }
                                ],
                                "description": "<p>returns the new class</p>"
                            },
                            "src": "can/construct/construct.js",
                            "line": 169,
                            "id": 5
                        }, {
                            "active": false,
                            "name": "can.Construct.static.namespace",
                            "type": "property",
                            "parent": "can.Construct.static",
                            "body": "",
                            "description": "<p>The <code>namespace</code> property returns the namespace your constructor is in.\nThis provides a way organize code and ensure globally unique types.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"</code></pre>             ",
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "title": "namespace",
                            "src": "can/construct/construct.js",
                            "line": 267,
                            "id": 6
                        }, {
                            "active": false,
                            "name": "can.Construct.static.shortName",
                            "type": "property",
                            "parent": "can.Construct.static",
                            "body": "",
                            "description": "<p>If you pass a name when creating a Construct, the <code>shortName</code> property will be set to the\nname you passed without the namespace.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"</code></pre>             ",
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "title": "shortName",
                            "src": "can/construct/construct.js",
                            "line": 281,
                            "id": 7
                        }, {
                            "active": false,
                            "name": "can.Construct.static.fullName",
                            "type": "property",
                            "parent": "can.Construct.static",
                            "body": "",
                            "description": "<p>If you pass a name when creating a Construct, the <code>fullName</code> property will be set to\nthe name you passed.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"</code></pre>             ",
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "title": "fullName",
                            "src": "can/construct/construct.js",
                            "line": 296,
                            "id": 8
                        }
                    ]
                }, {
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Construct.prototype",
                    "parent": "can.Construct",
                    "src": "can/construct/construct.js",
                    "line": 325,
                    "id": 9,
                    "children": [{
                            "active": false,
                            "body": "<p>If a prototype <code>setup</code> method is provided, it is called when a new \ninstance is created. It is passed the same arguments that were passed\nto the constructor.</p>\n\n<p>Because <code>setup</code> is not defined on <code>can.Construct</code> itself, calling super from\ndirectly-inheriting classes will break. In other words, don't do this:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('Snowflake', {\n    setup: function() {\n        this._super(); // this will break!\n    }\n});</code></pre>\n\n<h2><code>setup</code> vs. <code>init</code></h2>\n\n<p>Usually, you should use [can.Construct::init] to do your class's initialization.\nUse <code>setup</code> instead for:</p>\n\n<ul>\n<li>initialization code that you want to run before the inheriting constructor's \n<code>init</code> method is called.</li>\n<li>initialization code that should run whether or not inheriting constructors\ncall their base's <code>init</code> methods.</li>\n<li>modifying the arguments that will get passed to <code>init</code>.</li>\n</ul>\n\n<h2>Example</h2>\n\n<p>This code is a simplified version of the code in [can.Control]'s setup\nmethod. It converts the first argument to a jQuery collection and\nextends the controller's defaults with the options that were passed.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"can.Control\", {\n    setup: function(domElement, rawOptions) {\n        // set up this.element\n        this.element = $(domElement);\n\n        // set up this.options\n        this.options = can.extend({},\n                                  this.constructor.defaults,\n                                  rawOptions\n                                 );\n\n        // pass this.element and this.options to init.\n        return [this.element, this.options];        \n    }\n});</code></pre>         ",
                            "description": "",
                            "title": "setup",
                            "name": "can.Construct.prototype.setup",
                            "type": "function",
                            "parent": "can.Construct.prototype",
                            "signatures": [{
                                    "code": "setup(...args)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "args",
                                            "description": "<p>the arguments passed to the constructor.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Array"
                                            }, {
                                                "type": "undefined"
                                            }
                                        ],
                                        "description": "<p>if an array is returned, the elements of that array are passed as\narguments to [can.Construct::init]. Otherwise, the arguments to the\nconstructor are passed to [can.Construct::init] and the return value of <code>setup</code> is discarded.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/construct/construct.js",
                            "line": 329,
                            "id": 10
                        }, {
                            "active": false,
                            "body": "<p>If a prototype <code>init</code> method is provided, it is called when a new Construct is created,\nafter [can.Construct::setup]. The <code>init</code> method is where the bulk of your initialization code\nshould go, and a common thing to do in <code>init</code> is to save the arguments passed into the constructor.</p>\n\n<h2>Examples</h2>\n\n<p>First, we'll make a Person constructor that has a first and last name:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"Person\", {\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar justin = new Person(\"Justin\", \"Meyer\");\njustin.first; // \"Justin\"\njustin.last; // \"Meyer\"</code></pre>\n\n<p>Then we'll extend Person into Programmer and add a favorite language:</p>\n\n<pre><code class=\"lang-javascript\">Person(\"Programmer\", {\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return 'Hi! I'm ' + this.first + ' ' + this.last +\n            ' and I write ' + this.language + '.';\n    }\n});\n\nvar brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\nbrian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";</code></pre>\n\n<h2>Be Aware</h2>\n\n<p>[can.Construct::setup] is able to modify the arguments passed to <code>init</code>.\nIf you aren't receiving the right arguments to <code>init</code>, check to make sure\nthat they aren't being changed by <code>setup</code> somewhere along the inheritance chain.</p>",
                            "description": "",
                            "title": "init",
                            "name": "can.Construct.prototype.init",
                            "type": "function",
                            "parent": "can.Construct.prototype",
                            "signatures": [{
                                    "code": "init(...args)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "args",
                                            "description": "<p>the arguments passed to the constructor (or the elements of the array returned from [can.Construct::setup])</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/construct/construct.js",
                            "line": 389,
                            "id": 11
                        }, {
                            "active": false,
                            "type": "property",
                            "body": "",
                            "description": "<p>A reference to the constructor function that created the instance. This allows you to access\nthe constructor's static properties from an instance.</p>\n\n<h2>Example</h2>\n\n<p>This class has a static counter that counts how mane instances have been created:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"Counter\", {\n    count: 0\n}, {\n    init: function() {\n        this.constructor.count++;\n    }\n});\n\nnew Counter();\nCounter.count; // 1</code></pre>         ",
                            "types": [{
                                    "type": "function",
                                    "returns": {
                                        "types": [{
                                                "type": "undefined"
                                            }
                                        ]
                                    },
                                    "params": []
                                }
                            ],
                            "title": "constructor",
                            "name": "can.Construct.prototype.constructor",
                            "parent": "can.Construct.prototype",
                            "src": "can/construct/construct.js",
                            "line": 445,
                            "id": 12
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.Observe",
            "body": "",
            "description": "<p><code>can.Observe</code> provides a way for you to listen for and keep track of changes\nto objects. When you use the getters and setters provided by <code>can.Observe</code>,\nevents are fired that you can react to. <code>can.Observe</code> also has support for\nworking with deep properties. Observable arrays are also available with\n<code>[can.Observe.List]</code>, which is based on <code>can.Observe</code>.</p>",
            "parent": "canjs",
            "test": "can/observe/qunit.html",
            "signatures": [{
                    "code": "can.Observe([props])",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "props",
                            "description": "<p>properties and values to seed the Observe with</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.Observe"
                            }
                        ],
                        "description": "<p>an instance of <code>can.Observe</code> with the properties from <em>props</em></p>\n\n<h2>Working with Observes</h2>\n\n<p>To create an Observe, use <code>new can.Observe([props])</code>. This will return a\ncopy of <code>props</code> that emits events when its properties are changed with\n<code>[can.Observe.prototype.attr attr]</code>.</p>\n\n<p>You can read the values of properties on Observes directly, but you should\nnever set them directly. You can also read property values using <code>attr</code>.\nUsually, you will want to do this when creating a <code>[can.compute]</code> or when\nlive-binding properties in an [can.EJS EJS] template. (If you are using\n[can.Mustache Mustache], you don't need to use <code>attr</code>.)</p>\n\n<pre><code class=\"lang-javascript\">var aName = {a: 'Alexis'},\n    observe = can.Observe(aName);\n\n// Observes are copies of data:\naName === observe; // false\n\n// reading from an Observe:\nobserve.attr();    // {a: 'Alexis'}\nobserve.a;         // 'Alexis'\nobserve.attr('a'); // 'Alexis'\n\n// setting an Observe's property:\nobserve.attr('a, 'Alice');\nobserve.a; // Alice\n\n// removing an Observe's property;\nobserve.removeAttr('a');\nobserve.attr(); // {}\n\n// Don't do this!\nobserve.a = 'Adam'; // wrong!</code></pre>\n\n<p>Find out more about manipulating properties of Observes under\n[can.Observe.protoype.attr attr] and [can.Observe.protoype.removeAtt removeAttr].</p>\n\n<h2>Listening to changes</h2>\n\n<p>The real power of observable objects comes from being able to react to\nproperties being added, set, and removed. Observes emit events when\nproperties are changed that you can bind to.</p>\n\n<p><code>can.Observe</code> has two types of events that fire due to changes on an Observe:\n- the <em>change</em> event fires on every change to an Observe.\n- an event named after the property name fires on every change to that property.</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('change', function(ev, attr, how, newVal, oldVal) {\n    console.log('Something on o changed.');\n});\no.bind('a', function(ev, newVal, oldVal) {\n    console.log('a was changed.');\n});\n\no.attr('a', 'Alexis'); // 'Something on o changed.'\n                       // 'a was changed.'\no.attr({\n    'a': 'Alice',      // 'Something on o changed.' (for a's change)\n    'b': 'Bob'         // 'Something on o changed.' (for b's change)\n});                    // 'a was changed.'\n\no.removeAttr('a');     // 'Something on o changed.'\n                       // 'a was changed.'</code></pre>\n\n<p>For more detail on how to use these events, see [can.Observe.prototype.bind bind] and\n[can.Observe.prototype.unbind unbind]. There is also a plugin called [can.Observe.delegate]\nthat makes binding to specific types of events easier:</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.delegate('a', 'add' function(ev, newVal, oldVal) {\n    console.log('a was added.');\n});\no.delegate('a', 'set' function(ev, newVal, oldVal) {\n    console.log('a was set.');\n});\no.delegate('a', 'remove' function(ev, newVal, oldVal) {\n    console.log('a was removed.');\n});\no.delegate('a', 'change' function(ev, newVal, oldVal) {\n    console.log('a was changed.');\n});\n\no.attr('a', 'Alexis'); // 'a was added.'\n                       // 'a was changed.'\n\no.attr('a', 'Alice'); // 'a was set.'\n                      // 'a was changed.'\n\n\no.removeAttr('a'); // 'a was removed.'\n                   // 'a was changed.'</code></pre>"
                    }
                }
            ],
            "src": "can/observe/observe.md",
            "id": 13,
            "children": [{
                    "active": false,
                    "type": "static",
                    "body": "",
                    "description": "",
                    "name": "can.Observe.static",
                    "parent": "can.Observe",
                    "src": "can/observe/observe.js",
                    "line": 113,
                    "id": 15,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.static.startBatch",
                            "params": [{
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": []
                                        }
                                    ],
                                    "optional": true,
                                    "name": "batchStopHandler",
                                    "description": "<p>a callback that gets called after all batched events have been called</p>\n\n<p><code>startBatch</code> causes can.Observe to begin an event batch. Until <code>[can.Observe.stopBatch]</code> is called, any\nevents that would result from calls to <code>[can.Observe::attr|attr]</code> are held back from firing. If you have\nlots of changes to make to can.Observes, batching them together can help performance &emdash; especially if\nthose can.Observes are live-bound to the DOM.</p>\n\n<p>In this example, you can see how the <em>first</em> and <em>change</em> events are not fired (and their handlers\nare not called) until <code>stopBatch</code> is called.</p>\n\n<pre><code class=\"lang-javascript\">var person = new can.Observe({\n    first: 'Alexis',\n    last: 'Abril'\n});\n\nperson.bind('first', function() {\n    console.log(\"First name changed.\"\");\n}).bind('change', function() {\n    console.log(\"Something changed.\");\n});\n\ncan.Observe.startBatch();\nperson.attr('first', 'Alex');\nconsole.log('Still in the batch.');\ncan.Observe.stopBatch();\n\n// the log has:\n// Still in the batch.\n// First name changed.\n// Something changed.</code></pre>\n\n<p>You can also pass a callback to <code>startBatch</code> which will be called after all the events have\nbeen fired:</p>\n\n<pre><code class=\"lang-javascript\">can.Observe.startBatch(function() {\n    console.log('The batch is over.');\n});\nperson.attr('first', 'Izzy');\nconsole.log('Still in the batch.');\ncan.Observe.stopBatch();\n\n// The console has:\n// Still in the batch.\n// First name changed.\n// Something changed.\n// The batch is over.</code></pre>\n\n<h2>Calling <code>startBatch</code> multiple times</h2>\n\n<p>If you call <code>startBatch</code> more than once, <code>stopBatch</code> needs to be called\nthe same number of times before any batched events will fire. For ways\nto circumvent this process, see [can.Observe.stopBatch].</p>\n\n<p>Here is an example that demonstrates how events are affected by calling\n<code>startBatch</code> multiple times.</p>\n\n<pre><code class=\"lang-javascript\">var addPeople = function(observable) {\n    can.Observe.startBatch();\n    observable.attr('a', 'Alice');\n    observable.attr('b', 'Bob');\n    observable.attr('e', 'Eve');\n    can.Observe.stopBatch();\n};\n\n// In a completely different place:\nvar list = new can.Observe();\nlist.bind('change', function() {\n    console.log('The list changed.');\n});\n\ncan.Observe.startBatch();\naddPeople(list);\nconsole.log('Still in the batch.');\n\n// Here, the console has:\n// Still in the batch.\n\ncan.Observe.stopBatch();\n\n// Here, the console has:\n// Still in the batch.\n// The list changed.\n// The list changed.\n// The list changed.</code></pre>"
                                }
                            ],
                            "parent": "can.Observe.static",
                            "body": "",
                            "description": "<p>Begin an event batch. </p>",
                            "title": "startBatch",
                            "src": "can/observe/observe.js",
                            "line": 124,
                            "id": 16
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.static.stopBatch",
                            "params": [{
                                    "types": [{
                                            "type": "bool"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "force",
                                    "defaultValue": "false",
                                    "description": "<p>whether to stop batching events immediately</p>"
                                }, {
                                    "types": [{
                                            "type": "bool"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "callStart",
                                    "defaultValue": "false",
                                    "description": "<p>whether to call <code>[can.Observe.startBatch startBatch]</code> after firing batched events</p>\n\n<p><code>stopBatch</code> matches an earlier <code>[can.Observe.startBatch]</code> call. If <code>stopBatch</code> has been\ncalled as many times as <code>startBatch</code> (or if <em>force</em> is true), all batched events will be\nfired and any callbacks passed to <code>startBatch</code> since the beginning of the batch will be\ncalled. If <em>force and _callStart</em> are both true, a new batch will be started when all\nthe events and callbacks have been fired.</p>\n\n<p>See <code>[can.Observe.startBatch]</code> for examples of <code>startBatch</code> and <code>stopBatch</code> in normal use.</p>\n\n<p>In this example, the batch is forceably ended in the <code>addPeople</code> function.</p>\n\n<pre><code class=\"lang-javascript\">var addPeople = function(observable) {\n    can.Observe.startBatch();\n    observable.attr('a', 'Alice');\n    observable.attr('b', 'Bob');\n    observable.attr('e', 'Eve');\n    can.Observe.stopBatch(true);\n};\n\n// In a completely different place:\nvar list = new can.Observe();\nlist.bind('change', function() {\n    console.log('The list changed.');\n});\n\ncan.Observe.startBatch();\naddPeople(list);\nconsole.log('Still in the batch.');\n\n// Here, the console has:\n// Still in the batch.\n\ncan.Observe.stopBatch();\n\n// Here, the console has:\n// The list changed.\n// The list changed.\n// The list changed.\n// Still in the batch.</code></pre>"
                                }
                            ],
                            "parent": "can.Observe.static",
                            "body": "",
                            "description": "<p>End an event batch. </p>",
                            "title": "stopBatch",
                            "src": "can/observe/observe.js",
                            "line": 221,
                            "id": 17
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.static.triggerBatch",
                            "parent": "can.Observe.static",
                            "body": "",
                            "description": "<p>Trigger an event to be added to the current batch. </p>",
                            "title": "triggerBatch",
                            "signatures": [{
                                    "code": "can.Observe.triggerBatch(item, event [, args])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "can.Observe"
                                                }
                                            ],
                                            "name": "item",
                                            "description": "<p>the target of the event</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }, {
                                                    "type": "Object",
                                                    "options": [{
                                                            "name": "type",
                                                            "types": [{
                                                                    "type": "String"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "name": "event",
                                            "description": "<p>the type of event, or an event object with a type given</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Array"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "args",
                                            "description": "<p>the parameters to trigger the event with.</p>\n\n<p>If events are currently being batched, calling <code>triggerBatch</code> adds an event\nto the batch. If events are not currently being batched, the event is triggered\nimmediately.</p>"
                                        }
                                    ]
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 289,
                            "id": 18
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.static.keys",
                            "parent": "can.Observe.static",
                            "body": "<p><code>keys</code> iterates over an observe to get an array of its keys.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({\n    a: 'Alice',\n    b: 'Bob',\n    e: 'Eve'\n});\n\ncan.Observe.keys(people); // ['a', 'b', 'e']</code></pre>     ",
                            "description": "<p>Iterate over the keys of an Observe. </p>",
                            "title": "keys",
                            "signatures": [{
                                    "code": "can.Observe.keys(observe)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "can.Observe"
                                                }
                                            ],
                                            "name": "observe",
                                            "description": "<p>the <code>can.Observe</code> to get the keys from</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Array"
                                            }
                                        ],
                                        "description": "<p>array An array containing the keys from <em>observe</em>.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 318,
                            "id": 19
                        }
                    ]
                }, {
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Observe.prototype",
                    "parent": "can.Observe",
                    "src": "can/observe/observe.js",
                    "line": 347,
                    "id": 20,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.attr",
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Get or set properties on an Observe. </p>",
                            "title": "attr",
                            "signatures": [{
                                    "code": "attr()",
                                    "description": "<p>Gets a collection of all the properties in this <code>can.Observe</code>.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Object",
                                                "template": [{
                                                        "types": [{
                                                                "type": "String"
                                                            }
                                                        ]
                                                    }, {
                                                        "types": [{
                                                                "type": "*"
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }
                                        ],
                                        "description": "<p>an object with all the properties in this <code>can.Observe</code>.</p>"
                                    }
                                }, {
                                    "code": "attr(key)",
                                    "description": "<p>Reads a property from this <code>can.Observe</code>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "key",
                                            "description": "<p>the property to read</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the value assigned to <em>key</em>.</p>"
                                    }
                                }, {
                                    "code": "attr(key, value)",
                                    "description": "<p>Assigns <em>value</em> to a property on this <code>can.Observe</code> called <em>key</em>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "key",
                                            "description": "<p>the property to set</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "the",
                                            "description": "<p>value to assign to <em>key</em>.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe"
                                            }
                                        ],
                                        "description": "<p>this Observe, for chaining</p>"
                                    }
                                }, {
                                    "code": "attr(obj[, removeOthers])",
                                    "description": "<p>Assigns each value in <em>obj</em> to a property on this <code>can.Observe</code> named after the corresponding key in <em>obj</em>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object",
                                                    "template": [{
                                                            "types": [{
                                                                    "type": "String"
                                                                }
                                                            ]
                                                        }, {
                                                            "types": [{
                                                                    "type": "*"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "name": "obj",
                                            "description": "<p>a collection of key-value pairs to set.\nIf any properties already exist on the <code>can.Observe</code>, they will be overwritten.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "bool"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "removeOthers",
                                            "defaultValue": "false",
                                            "description": "<p>whether to remove keys not present in <em>obj</em>.\nTo remove keys without setting other keys, use <code>[can.Observe::removeAttr|removeAttr]</code>.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe"
                                            }
                                        ],
                                        "description": "<p>this Observe, for chaining</p>\n\n<p><code>attr</code> gets or sets properties on the <code>can.Observe</code> it's called on. Here's a tour through\nhow all of its forms work:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({});\n\n// set a property:\npeople.attr('a', 'Alex');\n\n// get a property:\npeople.attr('a'); // 'Alex'\n\n// set and merge multiple properties:\npeople.attr({\n    a: 'Alice',\n    b: 'Bob'\n});\n\n// get all properties:\npeople.attr(); // {a: 'Alice', b: 'Bob'}\n\n// set properties while removing others:\npeople.attr({\n    b: 'Bill',\n    e: 'Eve'\n}, true);\n\npeople.attr(); // {b: 'Bill', e: 'Eve'}</code></pre>\n\n<h2>Deep properties</h2>\n\n<p><code>attr</code> can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using <code>attr</code>.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({names: {}});\n\n// set a property:\npeople.attr('names.a', 'Alice');\n\n// get a property:\npeople.attr('names.a'); // 'Alice'\npeople.names.attr('a'); // 'Alice'\n\n// get all properties:\npeople.attr(); // {names: {a: 'Alice'}}</code></pre>\n\n<p>Objects that are added to Observes become Observes themselves behind the scenes,\nso changes to deep properties fire events at each level, and you can bind at any\nlevel. As this example shows, all the same events are fired no matter what level\nyou call <code>attr</code> at:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({names: {}});\n\npeople.bind('change', function(ev, attr, how, newVal, oldVal) {\n  console.log('people change: ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\npeople.names.bind('change', function(ev, attr, how, newVal, oldVal) {\n   console.log('people.names change' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\npeople.bind('names', function(ev, newVal, oldVal) {\n    console.log('people names: ' + newVal + ', ' + oldVal);\n});\n\npeople.names.bind('a', function(ev, newVal, oldVal) {\n    console.log('people.names a: ' + newVal + ', ' + oldVal);\n});\n\npeople.bind('names.a', function(ev, newVal, oldVal) {\n    console.log('people names.a: ' + newVal + ', ' + oldVal);\n});\n\npeople.attr('names.a', 'Alice'); // people change: names.a, add, Alice, undefined\n                                 // people.names change: a, add, Alice, undefined\n                                 // people.names a: Alice, undefined\n                                 // people names.a: Alice, undefined\n\npeople.names.attr('b', 'Bob');   // people change: names.b, add, Bob, undefined\n                                 // people.names change: b, add, Bob, undefined\n                                 // people.names b: Bob, undefined\n                                 // people names.b: Bob, undefined</code></pre>\n\n<h2>See also</h2>\n\n<p>For information on the events that are fired on property changes and how\nto listen for those events, see [can.Observe.prototype.bind bind].</p>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 374,
                            "id": 22
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.each",
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Call a function on each property of an Observe. </p>",
                            "title": "each",
                            "signatures": [{
                                    "code": "each(callback)",
                                    "description": "<p><code>each</code> iterates through the Observe, calling a function\nfor each property value and key.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "callback",
                                            "description": "<p>the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe"
                                            }
                                        ],
                                        "description": "<p>this Observe, for chaining</p>\n\n<pre><code class=\"lang-javascript\">var names = [];\nnew can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n    names.push(value);\n});\n\nnames; // ['Alice', 'Bob', 'Eve']\n\nnames = [];\nnew can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n    names.push(value);\n    if(key === 'b') {\n        return false;\n    }\n});\n\nnames; // ['Alice', 'Bob']\n</code></pre>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 519,
                            "id": 23
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.removeAttr",
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Remove a property from an Observe. </p>",
                            "title": "removeAttr",
                            "signatures": [{
                                    "code": "removeAttr(attrName)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "attrName",
                                            "description": "<p>the name of the property to remove</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the value of the property that was removed</p>\n\n<p><code>removeAttr</code> removes a property by name from an Observe.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'});\n\npeople.removeAttr('b'); // 'Bob'\npeople.attr();          // {a: 'Alice', e: 'Eve'}</code></pre>\n\n<p>Removing an attribute will cause a <em>change</em> event to fire with <code>'remove'</code>\npassed as the <em>how</em> parameter and <code>undefined</code> passed as the <em>newVal</em> to\nhandlers. It will also cause a <em>property name</em> event to fire with <code>undefined</code>\npassed as <em>newVal</em>. An in-depth description at these events can be found\nunder <code>[can.Observe.prototype.attr attr]</code>.</p>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 558,
                            "id": 24
                        }, {
                            "active": false,
                            "name": "can.Observe.prototype.bind",
                            "type": "function",
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Bind event handlers to an Observe. </p>",
                            "title": "bind",
                            "signatures": [{
                                    "code": "bind(eventType, handler)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventType",
                                            "description": "<p>the type of event to bind this handler to</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "handler",
                                            "description": "<p>the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "attr",
                                            "description": "<p>which property changed</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "how",
                                            "description": "<p>whether the property was added, removed, or set\nPossible values are <code>'add'</code>, <code>'remove'</code>, or <code>'set'</code>.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "newVal",
                                            "description": "<p>the value of the property after the change\n<code>newVal</code> will be <code>undefined</code> if the property was removed.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "oldVal",
                                            "description": "<p>the value of the property before the change\n<code>oldVal</code> will be <code>undefined</code> if the property was added.</p>\n\n<p>Here is a concrete tour through the <em>change</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('change', function(ev, attr, how, newVal, oldVal) {\n    console.log(ev + ', ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\no.attr('a', 'Alexis'); // [object Object], a, add, Alexis, undefined\no.attr('a', 'Adam');   // [object Object], a, set, Adam, Alexis\no.attr({\n    'a': 'Alice',      // [object Object], a, set, Alice, Adam\n    'b': 'Bob'         // [object Object], b, add, Bob, undefined\n});\no.removeAttr('a');     // [object Object], a, remove, undefined, Alice</code></pre>\n\n<p>(See also <code>[can.Observe::removeAttr|removeAttr]</code>, which removes properties).</p>\n\n<h2>The <em>property name</em> event</h2>\n\n<p>The second event that is fired is an event whose type is the same as the changed\nproperty's name. This event is useful for noticing changes to a specific property.</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('a', function(ev, newVal, oldVal) {\n    console.log('The value of a changed.');\n});</code></pre>\n\n<p>The parameters of the event handler for the <em>property name</em> event are:</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "newVal",
                                            "description": "<p>the value of the property after the change\n<code>newVal</code> will be <code>undefined</code> if the property was removed.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "oldVal",
                                            "description": "<p>the value of the property before the change\n<code>oldVal</code> will be <code>undefined</code> if the property was added.</p>\n\n<p>Here is a concrete tour through the <em>property name</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('a', function(ev, newVal, oldVal) {\n    console.log(ev + ', ' + newVal + ', ' + oldVal);\n});\n\no.attr('a', 'Alexis'); // [object Object], Alexis, undefined\no.attr('a', 'Adam');   // [object Object], Adam, Alexis\no.attr({\n    'a': 'Alice',      // [object Object], Alice, Adam\n    'b': 'Bob' \n});\no.removeAttr('a');     // [object Object], undefined, Alice</code></pre>\n\n<h2>See also</h2>\n\n<p>More information about changing properties on Observes can be found under\n[can.Observe.prototype.attr attr].</p>\n\n<p>For a more specific way to changes on Observes, see the [can.Observe.delegate] plugin.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe"
                                            }
                                        ],
                                        "description": "<p>this Observe, for chaining</p>\n\n<p><code>bind</code> binds event handlers to property changes on <code>can.Observe</code>s. When you change\na property using <code>attr</code>, two events are fired on the Observe, allowing other parts\nof your application to observe the changes to the object.</p>\n\n<h2>The <em>change</em> event</h2>\n\n<p>The first event that is fired is the <em>change</em> event. The <em>change</em> event is useful\nif you want to react to all changes on an Observe.</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('change', function(ev, attr, how, newVal, oldVal) {\n    console.log('Something changed.');\n});</code></pre>\n\n<p>The parameters of the event handler for the <em>change</em> event are:</p>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 711,
                            "id": 25
                        }, {
                            "active": false,
                            "name": "can.Observe.prototype.unbind",
                            "type": "function",
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Unbind event handlers from an Observe. </p>",
                            "title": "unbind",
                            "signatures": [{
                                    "code": "unbind(eventType[, handler])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventType",
                                            "description": "<p>the type of event to unbind, exactly as passed to <code>bind</code></p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "handler",
                                            "description": "<p>the handler to unbind</p>\n\n<p><code>unbind</code> unbinds event handlers previously bound with [can.Observe.prototype.bind|<code>bind</code>].\nIf no <em>handler</em> is passed, all handlers for the given event type will be unbound.</p>\n\n<pre><code class=\"lang-javascript\">var i = 0,\n    increaseBy2 = function() { i += 2; },\n    increaseBy3 = function() { i += 3; },\n    o = new can.Observe();\n\no.bind('change', increaseBy2);\no.bind('change', increaseBy3);\no.attr('a', 'Alice');\ni; // 5\n\no.unbind('change', increaseBy2);\no.attr('b', 'Bob');\ni; // 8\n\no.unbind('change');\no.attr('e', 'Eve');\ni; // 8</code></pre>"
                                        }
                                    ]
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 818,
                            "id": 26
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.serialize",
                            "params": [],
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Get the serialized Object form of the observe.  Serialized\ndata is typically used to send back to a server.</p>\n\n<pre><code>o.serialize() //-&gt; { name: 'Justin' }\n</code></pre>\n\n<p>Serialize currently returns the same data \nas [can.Observe.prototype.attrs].  However, in future\nversions, serialize will be able to return serialized\ndata similar to [can.Model].  The following will work:</p>\n\n<pre><code>new Observe({time: new Date()})\n  .serialize() //-&gt; { time: 1319666613663 }\n</code></pre>",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p>a JavaScript Object that can be \nserialized with <code>JSON.stringify</code> or other methods. </p>"
                            },
                            "src": "can/observe/observe.js",
                            "line": 849,
                            "id": 27
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype._attrs",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "props",
                                    "description": ""
                                }, {
                                    "types": [{
                                            "type": "Boolean"
                                        }
                                    ],
                                    "name": "remove",
                                    "description": "<p>true if you should remove properties that are not in props</p>"
                                }
                            ],
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Set multiple properties on the observable</p>",
                            "hide": true,
                            "src": "can/observe/observe.js",
                            "line": 871,
                            "id": 28
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.compute",
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Make a can.compute from an observable property. </p>",
                            "title": "compute",
                            "signatures": [{
                                    "code": "compute(attrName)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "attrName",
                                            "description": "<p>the property to bind to</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.compute"
                                            }
                                        ],
                                        "description": "<p>a [can.compute] bound to <em>attrName</em></p>\n\n<p><code>compute</code> is a convenience method for making computes from properties\nof Observes. More information about computes can be found under [can.compute].</p>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 923,
                            "id": 29
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "name": "can.Observe.List",
            "type": "constructor",
            "parent": "canjs",
            "body": "",
            "description": "<p><code>can.Observe.List</code> provides a way for you to use <code>can.Observe</code>s with arrays. Much like <code>can.Observe</code>,\nwhen you use the getters and setters on <code>can.Observe.List</code>, events are fired that you can listen for\nand react to.</p>",
            "inherits": "can.Observe",
            "signatures": [{
                    "code": "can.Observe.List([elements])",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "Array"
                                }
                            ],
                            "optional": true,
                            "name": "elements",
                            "description": "<p>elements to seed the List with</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.Observe.List"
                            }
                        ],
                        "description": "<p>an instance of <code>can.Observe.List</code> with the elements from <em>elements</em></p>\n\n<h2>Working with Lists</h2>\n\n<p><code>can.Observe.List</code> extends <code>[can.Observe]</code>, so all the ways that you're used to working with\nObserves also work here, including [can.Observe.prototype.bind bind], [can.Observe.prototype.unbind unbind],\nand [can.Observe.prototype.each each]. And just as you can directly read properties normally\noff of an Observe, you can use array accessors ([]) to read elements directly off of a List.</p>\n\n<p>The one function of <code>can.Observe</code> that works slightly differently is <code>attr</code>. As expected when working with\narrays, top-level keys passed into <code>attr</code> are required to be numeric. (Strings may still be used when getting\nor modifying deep properties). Any top-level keys that are non-numeric are ignored. In addition, as might be\nexpected, a call to argument-less <code>attr</code> returns an array instead of an object.</p>\n\n<p>Just as you shouldn't set properties of an Observe directly, you shouldn't change elements\nof a List directly. Always use <code>attr</code> to set the elements of a List, or use [can.Observe.List.push push],\n[can.Observe.List.pop pop], [can.Observe.List.shift shift], [can.Observe.List.unshift unshift], or [can.Observe.List.splice splice].</p>\n\n<p>Here is a tour through the forms of <code>can.Observe.List</code>'s <code>attr</code> that parallels the one found under [can.Observe.prototype.attr attr]:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe.List(['Alex', 'Bill']);\n\n// set an element:\npeople.attr(0, 'Adam');\npeople[0] = 'Adam'; // don't do this!\n\n// get an element:\npeople.attr(0); // 'Adam'\npeople[0]; // 'Adam'\n\n// get all elements:\npeople.attr(); // ['Adam', 'Bill']\n\n// extend the array:\npeople.attr(4, 'Charlie');\npeople.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n// merge the elements:\npeople.attr(['Alice', 'Bob', 'Eve']);\npeople.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']</code></pre>\n\n<h2>Listening to changes</h2>\n\n<p>As with <code>can.Observe</code>s, the real power of observable arrays comes from being able to\nreact to changes in the member elements of the array. Lists emit five types of events:\n- the <em>change</em> event fires on every change to a List.\n- the <em>set</em> event is fired when an element is set.\n- the <em>add</em> event is fired when an element is added to the List.\n- the <em>remove</em> event is fired when an element is removed from the List.\n- the <em>length</em> event is fired when the length of the List changes.</p>\n\n<p>This example presents a brief concrete survey of the times these events are fired:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\n\nlist.bind('change', function() { console.log('An element changed.'); });\nlist.bind('set', function() { console.log('An element was set.'); });\nlist.bind('add', function() { console.log('An element was added.'); });\nlist.bind('remove', function() { console.log('An element was removed.'); });\nlist.bind('length', function() { console.log('The length of the list changed.'); });\n\nlist.attr(0, 'Alexis'); // 'An element changed.'\n                        // 'An element was set.'\n\nlist.attr(3, 'Xerxes'); // 'An element changed.'\n                        // 'An element was added.'\n                        // 'The length of the list was changed.'\n\nlist.attr(['Adam', 'Bill']); // 'An element changed.'\n                             // 'An element was set.'\n                             // 'An element was changed.'\n                             // 'An element was set.'\n\nlist.pop(); // 'An element changed.'\n            // 'An element was removed.'\n            // 'The length of the list was changed.'</code></pre>\n\n<p>More information about binding to these events can be found under [can.Observe.List.attr attr].</p>"
                    }
                }
            ],
            "src": "can/observe/observe.js",
            "line": 958,
            "id": 30,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Observe.List.prototype",
                    "parent": "can.Observe.List",
                    "src": "can/observe/observe.js",
                    "line": 1056,
                    "id": 31,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.serialize",
                            "params": [],
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Returns the serialized form of this list.</p>",
                            "hide": true,
                            "src": "can/observe/observe.js",
                            "line": 1102,
                            "id": 32
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.splice",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Insert and remove elements from a List. </p>",
                            "title": "splice",
                            "signatures": [{
                                    "code": "splice(index[, howMany[, ...newElements]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>where to start removing or inserting elements</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "howMany",
                                            "description": "<p>the number of elements to remove\nIf <em>howMany</em> is not provided, <code>splice</code> will all elements from <code>index</code> to the end of the List.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "newElements",
                                            "description": "<p>elements to insert into the List</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Array"
                                            }
                                        ],
                                        "description": "<p>the elements removed by <code>splice</code></p>\n\n<p><code>splice</code> lets you remove elements from and insert elements into a List.</p>\n\n<p>This example demonstrates how to do surgery on a list of numbers:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.attr(); // [0, 1, 'Alice', 'Bob', 3]</code></pre>\n\n<h2>Events</h2>\n\n<p><code>splice</code> causes the List it's called on to emit <em>change</em> events,\n<em>add</em> events, <em>remove</em> events, and <em>length</em> events. If there are\nany elements to remove, a <em>change</em> event, a <em>remove</em> event, and a\n<em>length</em> event will be fired. If there are any elements to insert, a\nseparate <em>change</em> event, an <em>add</em> event, and a separate <em>length</em> event\nwill be fired. </p>\n\n<p>This slightly-modified version of the above example should help\nmake it clear how <code>splice</code> causes events to be emitted:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['a', 'b', 'c', 'd']);\nlist.bind('change', function(ev, attr, how, newVals, oldVals) {\n    console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\nlist.bind('add', function(ev, newVals, where) {\n    console.log('add: ' + newVals + ', ' + where);\n});\nlist.bind('remove', function(ev, oldVals, where) {\n    console.log('remove: ' + oldVals + ', ' + where);\n});\nlist.bind('length', function(ev, length) {\n    console.log('length: ' + length + ', ' + this.attr());\n});\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                   // remove: ['c'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                   // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                   // add: ['Alice', 'Bob'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']</code></pre>\n\n<p>More information about binding to these events can be found under [can.Observe.List.attr attr].</p>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1144,
                            "id": 34
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.attr",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Get or set elements in a List. </p>",
                            "title": "attr",
                            "signatures": [{
                                    "code": "attr()",
                                    "description": "<p>Gets a collection of all the elements in this <code>can.Observe.List</code>.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Array"
                                            }
                                        ],
                                        "description": "<p>array with all the elements in this List.</p>"
                                    }
                                }, {
                                    "code": "attr(index)",
                                    "description": "<p>Reads a element from this <code>can.Observe.List</code>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>the element to read</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the value at <em>index</em>.</p>"
                                    }
                                }, {
                                    "code": "attr(index, value)",
                                    "description": "<p>Assigns <em>value</em> to the index <em>index</em> on this <code>can.Observe.List</code>, expanding the list if necessary.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>the element to set</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "the",
                                            "description": "<p>value to assign at <em>index</em></p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe.List"
                                            }
                                        ],
                                        "description": "<p>this List, for chaining</p>"
                                    }
                                }, {
                                    "code": "attr(elements[, replaceCompletely])",
                                    "description": "<p>Merges the members of <em>elements</em> into this List, replacing each from the beginning in order. If\n<em>elements</em> is longer than the current List, the current List will be expanded. If <em>elements</em>\nis shorter than the current List, the extra existing members are not affected (unless\n<em>replaceCompletely</em> is <code>true</code>). To remove elements without replacing them, use <code>[can.Observe.List.prototype.removeAttr removeAttr]</code>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Array"
                                                }
                                            ],
                                            "name": "elements",
                                            "description": "<p>an array of elements to merge in</p>"
                                        }, {
                                            "types": [{
                                                    "type": "bool"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "replaceCompletely",
                                            "defaultValue": "false",
                                            "description": "<p>whether to completely replace the elements of List\nIf <em>replaceCompletely</em> is <code>true</code> and <em>elements</em> is shorter than the List, the existing\nextra members of the List will be removed.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Index"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>where the change took place</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "how",
                                            "description": "<p>whether elements were added, removed, or set\nPossible values are <code>'add'</code>, <code>'remove'</code>, or <code>'set'</code>.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }, {
                                                    "type": "Array"
                                                }, {
                                                    "type": "undefined"
                                                }
                                            ],
                                            "name": "newVal",
                                            "description": "<p>the elements affected after the change\n<em>newVal</em> will be a single value when an index is set, an Array when elements\nwere added, and <code>undefined</code> if elements were removed.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }, {
                                                    "type": "Array"
                                                }, {
                                                    "type": "undefined"
                                                }
                                            ],
                                            "name": "oldVal",
                                            "description": "<p>the elements affected before the change\n<em>newVal</em> will be a single value when an index is set, an Array when elements\nwere removed, and <code>undefined</code> if elements were added.</p>\n\n<p>Here is a concrete tour through the <em>change</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log(ev + ', ' + index + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\nlist.attr(['Alexis', 'Bill']); // [object Object], 0, add, ['Alexis', 'Bill'], undefined\nlist.attr(2, 'Eve');           // [object Object], 2, add, Eve, undefined\nlist.attr(0, 'Adam');          // [object Object], 0, set, Adam, Alexis\nlist.attr(['Alice', 'Bob']);   // [object Object], 0, set, Alice, Adam\n                               // [object Object], 1, set, Bob, Bill\nlist.removeAttr(1);            // [object Object], 1, remove, undefined, Bob</code></pre>\n\n<h2>The <em>set</em> event</h2>\n\n<p><em>set</em> events are fired when an element at an index that already exists in the List is\nmodified. Actions can cause <em>set</em> events to fire never also cause <em>length</em> events\nto fire (although some functions, such as <code>[can.Observe.List.prototype.splice splice]</code>\nmay cause unrelated sets of events to fire after being batched).</p>\n\n<p>The parameters of the event handler for the <em>set</em> event are:</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "newVal",
                                            "description": "<p>the new value of the element</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Index"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>where the set took place</p>\n\n<p>Here is a concrete tour through the <em>set</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nlist.bind('set', function(ev, newVal, index) {\n    console.log(newVal + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');          \nlist.attr(0, 'Adam');          // Adam, 0\nlist.attr(['Alice', 'Bob']);   // Alice, 0\n                               // Bob, 1\nlist.removeAttr(1);            </code></pre>\n\n<h2>The <em>add</em> event</h2>\n\n<p><em>add</em> events are fired when elements are added or inserted\ninto the List.</p>\n\n<p>The parameters of the event handler for the <em>add</em> event are:</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Array"
                                                }, {
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "newElements",
                                            "description": "<p>the new elements\nIf more than one element is added, <em>newElements</em> will be an array.\nOtherwise, it is simply the new element itself.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Index"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>where the add or insert took place</p>\n\n<p>Here is a concrete tour through the <em>add</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nlist.bind('add', function(ev, newElements, index) {\n    console.log(newElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']); // ['Alexis', 'Bill'], 0\nlist.attr(2, 'Eve');           // Eve, 2\nlist.attr(0, 'Adam');          \nlist.attr(['Alice', 'Bob']);   \n\nlist.removeAttr(1);            </code></pre>\n\n<h2>The <em>remove</em> event</h2>\n\n<p><em>remove</em> events are fired when elements are removed from the list.</p>\n\n<p>The parameters of the event handler for the <em>remove</em> event are:</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Array"
                                                }, {
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "removedElements",
                                            "description": "<p>the removed elements\nIf more than one element was removed, <em>removedElements</em> will be an array.\nOtherwise, it is simply the element itself.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Index"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>where the removal took place</p>\n\n<p>Here is a concrete tour through the <em>remove</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nlist.bind('remove', function(ev, removedElements, index) {\n    console.log(removedElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']); \nlist.attr(2, 'Eve');           \nlist.attr(0, 'Adam');          \nlist.attr(['Alice', 'Bob']);   \n\nlist.removeAttr(1);            // Bob, 1</code></pre>\n\n<h2>The <em>length</em> event</h2>\n\n<p><em>length</em> events are fired whenever the list changes.</p>\n\n<p>The parameters of the event handler for the <em>length</em> event are:</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "name": "length",
                                            "description": "<p>the current length of the list\nIf events were batched when the <em>length</em> event was triggered, <em>length</em>\nwill have the length of the list when <code>stopBatch</code> was called. Because\nof this, you may recieve multiple <em>length</em> events with the same\n<em>length</em> parameter.</p>\n\n<p>Here is a concrete tour through the <em>length</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nlist.bind('length', function(ev, length) {\n    console.log(length);\n});\n\nlist.attr(['Alexis', 'Bill']); // 2\nlist.attr(2, 'Eve');           // 3\nlist.attr(0, 'Adam');          \nlist.attr(['Alice', 'Bob']);   \n\nlist.removeAttr(1);            // 2</code></pre>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe.List"
                                            }
                                        ],
                                        "description": "<p>this List, for chaining</p>\n\n<p><code>attr</code> gets or sets elements on the <code>can.Observe.List</code> it's called on. Here's a tour through\nhow all of its forms work:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe.List(['Alex', 'Bill']);\n\n// set an element:\npeople.attr(0, 'Adam');\n\n// get an element:\npeople.attr(0); // 'Adam'\npeople[0]; // 'Adam'\n\n// get all elements:\npeople.attr(); // ['Adam', 'Bill']\n\n// extend the array:\npeople.attr(4, 'Charlie');\npeople.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n// merge the elements:\npeople.attr(['Alice', 'Bob', 'Eve']);\npeople.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']</code></pre>\n\n<h2>Deep properties</h2>\n\n<p><code>attr</code> can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using <code>attr</code>.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe.List([{name: 'Alex'}, {name: 'Bob'}]);\n\n// set a property:\npeople.attr('0.name', 'Alice');\n\n// get a property:\npeople.attr('0.name');  // 'Alice'\npeople[0].attr('name'); // 'Alice'\n\n// get all properties:\npeople.attr(); // [{name: 'Alice'}, {name: 'Bob'}]</code></pre>\n\n<p>The discussion of deep properties under <code>[can.Observe.prototype.attr]</code> may also\nbe enlightening.</p>\n\n<h2>Events</h2>\n\n<p><code>can.Observe.List</code>s emit five types of events in response to changes. They are:\n- the <em>change</em> event fires on every change to a List.\n- the <em>set</em> event is fired when an element is set.\n- the <em>add</em> event is fired when an element is added to the List.\n- the <em>remove</em> event is fired when an element is removed from the List.\n- the <em>length</em> event is fired when the length of the List changes.</p>\n\n<ul>\n<li>## The <em>change</em> event</li>\n</ul>\n\n<p>The first event that is fired is the <em>change</em> event. The <em>change</em> event is useful\nif you want to react to all changes on an List.</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List([]);\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log('Something changed.');\n});</code></pre>\n\n<p>The parameters of the event handler for the <em>change</em> event are:</p>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1232,
                            "id": 35
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.push",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Add elements to the end of a list. </p>",
                            "title": "push",
                            "signatures": [{
                                    "code": "push(...elements)",
                                    "description": "<p><code>push</code> adds elements onto the end of a List.]</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "elements",
                                            "description": "<p>the elements to add to the List</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>the new length of the List</p>\n\n<p><code>push</code> is fairly straightforward:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']</code></pre>\n\n<p>If you have an array you want to concatenate to the end\nof the List, you can use <code>apply</code>:</p>\n\n<pre><code class=\"lang-javascript\">var names = ['Bob', 'Eve'],\n    list = new can.Observe.List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Alice', 'Bob', 'Eve']</code></pre>\n\n<h2>Events</h2>\n\n<p><code>push</code> causes <em>change</em>, <em>add</em>, and <em>length</em> events to be fired.</p>\n\n<h2>See also</h2>\n\n<p><code>push</code> has a counterpart in [can.Observe.List.pop pop], or you may be\nlooking for [can.Observe.List.unshift unshift] and its counterpart [can.Observe.List.shift shift].</p>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1540,
                            "id": 36
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.unshift",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Add elements to the beginning of a List. </p>",
                            "title": "unshift",
                            "signatures": [{
                                    "code": "unshift(...elements)",
                                    "description": "<p><code>unshift</code> adds elements onto the beginning of a List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "elements",
                                            "description": "<p>the elements to add to the List</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>the new length of the List</p>\n\n<p><code>unshift</code> adds elements to the front of the list in bulk in the order specified:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']</code></pre>\n\n<p>If you have an array you want to concatenate to the beginning\nof the List, you can use <code>apply</code>:</p>\n\n<pre><code class=\"lang-javascript\">var names = ['Bob', 'Eve'],\n    list = new can.Observe.List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Bob', 'Eve', 'Alice']</code></pre>\n\n<h2>Events</h2>\n\n<p><code>unshift</code> causes <em>change</em>, <em>add</em>, and <em>length</em> events to be fired.</p>\n\n<h2>See also</h2>\n\n<p><code>unshift</code> has a counterpart in [can.Observe.List.shift shift], or you may be\nlooking for [can.Observe.List.push push] and its counterpart [can.Observe.List.pop pop].</p>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1581,
                            "id": 37
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.pop",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Remove an element from the end of a List. </p>",
                            "title": "pop",
                            "signatures": [{
                                    "code": "pop()",
                                    "description": "<p><code>push</code> removes an element from the end of a List.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the element just popped off the List, or <code>undefined</code> if the List was empty</p>\n\n<p><code>pop</code> is the opposite action from <code>[can.Observe.List.push push]</code>:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined</code></pre>\n\n<h2>Events</h2>\n\n<p><code>pop</code> causes <em>change</em>, <em>remove</em>, and <em>length</em> events to be fired if the List is not empty\nwhen it is called.</p>\n\n<h2>See also</h2>\n\n<p><code>pop</code> has its counterpart in [can.Observe.List.push push], or you may be\nlooking for [can.Observe.List.unshift unshift] and its counterpart [can.Observe.List.shift shift].</p>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1659,
                            "id": 38
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.shift",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Remove en element from the front of a list. </p>",
                            "title": "shift",
                            "signatures": [{
                                    "code": "shift()",
                                    "description": "<p><code>shift</code> removes an element from the beginning of a List.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the element just shifted off the List, or <code>undefined</code> if the List is empty</p>\n\n<p><code>shift</code> is the opposite action from <code>[can.Observe.List.unshift unshift]</code>:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n\nlist.shift(); // 'Bob'\nlist.shift(); // 'Eve'\nlist.shift(); // 'Alice'\nlist.shift(); // undefined</code></pre>\n\n<h2>Events</h2>\n\n<p><code>pop</code> causes <em>change</em>, <em>remove</em>, and <em>length</em> events to be fired if the List is not empty\nwhen it is called.</p>\n\n<h2>See also</h2>\n\n<p><code>shift</code> has a counterpart in [can.Observe.List.unshift unshift], or you may be\nlooking for [can.Observe.List.push push] and its counterpart [can.Observe.List.pop pop].</p>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1693,
                            "id": 39
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.indexOf",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Look for an item in a List. </p>",
                            "title": "indexOf",
                            "signatures": [{
                                    "code": "indexOf(item)",
                                    "description": "<p><code>indexOf</code> finds the position of a given item in the List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "item",
                                            "description": "<p>the item to find</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>the position of the item in the List, or -1 if the item is not found.</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1</code></pre>\n\n<p>It is trivial to make a <code>contains</code>-type function using <code>indexOf</code>:</p>\n\n<pre><code class=\"lang-javascript\">function(list, item) {\n    return list.indexOf(item) >= 0;\n}</code></pre>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1753,
                            "id": 40
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.join",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Join a List's elements into a string. </p>",
                            "title": "join",
                            "signatures": [{
                                    "code": "join(separator)",
                                    "description": "<p><code>join</code> turns a List into a string by inserting <em>separator</em> between the string representations\nof all the elements of the List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "separator",
                                            "description": "<p>the string to seperate elements with</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "String"
                                            }
                                        ],
                                        "description": "<p>the joined string</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n\nvar beatles = new can.Observe.List(['John', 'Paul', 'Ringo', 'George']);\nbeatles.join('&'); // 'John&Paul&Ringo&George'</code></pre>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1783,
                            "id": 41
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.reverse",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Reverse the order of a List. </p>",
                            "title": "reverse",
                            "signatures": [{
                                    "code": "reverse()",
                                    "description": "<p><code>reverse</code> reverses the elements of the List in place.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe.List"
                                            }
                                        ],
                                        "description": "<p>the List, for chaining</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true</code></pre>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1805,
                            "id": 42
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.slice",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Make a copy of a part of a List. </p>",
                            "title": "slice",
                            "signatures": [{
                                    "code": "slice([start[, end]])",
                                    "description": "<p><code>slice</code> creates a copy of a portion of the List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "start",
                                            "defaultValue": "0",
                                            "description": "<p>the index to start copying from</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "end",
                                            "description": "<p>the first index not to include in the copy\nIf <em>end</em> is not supplied, <code>slice</code> will copy until the end of the list.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe.List"
                                            }
                                        ],
                                        "description": "<p>a new <code>can.Observe.List</code> with the extracted elements</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList.attr(); // ['Bob', 'Charlie', 'Daniel']</code></pre>\n\n<p><code>slice</code> is the simplest way to copy a List:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy.attr();   // ['Alice', 'Bob', 'Eve']\nlist === copy; // false</code></pre>"
                                    }
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1824,
                            "id": 43
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.concat",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Merge many collections together into a List. </p>",
                            "title": "concat",
                            "signatures": [{
                                    "code": "concat(...args)",
                                    "description": "<p><code>concat</code> makes a new List with the elements of the List followed by the elements of the parameters.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Array"
                                                }, {
                                                    "type": "can.Observe.List"
                                                }, {
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "args",
                                            "description": "<p>Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new can.Observe.List(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]</code></pre>"
                                        }
                                    ]
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1859,
                            "id": 44
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.forEach",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Call a function for each element of a List. </p>",
                            "title": "forEach",
                            "signatures": [{
                                    "code": "forEach(callback[, thisArg])",
                                    "description": "<p><code>forEach</code> calls a callback for each element in the List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": [{
                                                            "types": [{
                                                                    "type": "element"
                                                                }
                                                            ]
                                                        }, {
                                                            "types": [{
                                                                    "type": "index"
                                                                }
                                                            ]
                                                        }, {
                                                            "types": [{
                                                                    "type": "list"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "name": "callback",
                                            "description": "<p>a function to call with each element of the List\nThe three parameters that <em>callback</em> gets passed are <em>element</em>, the element at <em>index</em>, <em>index</em> the\ncurrent element of the list, and <em>list</em> the List the elements are coming from.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "thisArg",
                                            "description": "<p>the object to use as <code>this</code> inside the callback</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.attr(index, element * element);\n});\nlist.attr(); // [1, 4, 9]</code></pre>"
                                        }
                                    ]
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1889,
                            "id": 45
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.replace",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Replace all the elements of a List. </p>",
                            "title": "replace",
                            "signatures": [{
                                    "code": "replace(collection)",
                                    "description": "<p><code>replace</code> replaces all the elements of this List with new ones.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Array"
                                                }, {
                                                    "type": "can.Observe.List"
                                                }, {
                                                    "type": "can.Deferred"
                                                }
                                            ],
                                            "name": "collection",
                                            "description": "<p>the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an <code>Array</code> or <code>can.Observe.List</code>.\nThe elements of the list are not actually removed until the Deferred resolves.</p>\n\n<p><code>replace</code> is especially useful when <code>can.Observe.List</code>s are live-bound into <code>[can.Control]</code>s,\nand you intend to populate them with the results of a <code>[can.Model]</code> call:</p>\n\n<pre><code class=\"lang-javascript\">can.Control({\n    init: function() {\n        this.list = new Todo.List();\n        // live-bind the list into the DOM\n        this.element.html(can.view('list.mustache', this.list));\n        // when this AJAX call returns, the live-bound DOM will be updated\n        this.list.replace(Todo.findAll());\n    }\n});</code></pre>\n\n<p>Learn more about [can.Model.List making Lists of models].</p>\n\n<h2>Events</h2>\n\n<p>A major difference between <code>replace</code> and <code>attr(newElements, true)</code> is that <code>replace</code> always emits\nan<em>add</em> event and a <em>remove</em> event, whereas <code>attr</code> will cause <em>set</em> events along an <em>add</em> or <em>remove</em>\nevent if needed. Corresponding <em>change</em> and <em>length</em> events will be fired as well.</p>\n\n<p>The differences in the events fired by <code>attr</code> and <code>replace</code> are demonstrated concretely by this example:</p>\n\n<pre><code class=\"lang-javascript\">var attrList = new can.Observe.List(['Alexis', 'Bill']);\nattrList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nvar replaceList = new can.Observe.List(['Alexis', 'Bill']);\nreplaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nattrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n                                              // 1, set, Ben, Bill\nreplaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n                                              // 0, add, undefined, ['Adam', 'Ben']\n\nattrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n                                              // 1, remove, undefined, Ben\nreplaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n                                              // 0, add, Amber, ['Adam', 'Ben']\n\nattrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n                                              // 1, add, ['Bob', 'Eve'], undefined\nreplaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n                                              // 0, add, ['Alice', 'Bob', 'Eve'], Amber</code></pre>"
                                        }
                                    ]
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1914,
                            "id": 46
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.Model",
            "body": "",
            "description": "",
            "title": "",
            "parent": "canjs",
            "signatures": [{
                    "code": "can.Model([name,] staticProperties, instanceProperties)",
                    "description": "<p>Creates a can.Model class constructor. (See [can.Construct] for more details on this syntax.)</p>",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "optional": true,
                            "name": "name",
                            "description": "<p>If given, this will be the globally-available name of the constructor function.</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "staticProperties",
                            "description": "<p>The static properties of the class. See below for properties with\nspecial meanings to <code>can.Model</code>.</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "instanceProperties",
                            "description": "<p>The instance properties of instances of the class. These will usually\nbe functions.</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "description": "<p>A can.Model constructor.</p>"
                    }
                }, {
                    "code": "new ModelConstructor([options])",
                    "description": "<p>Creates a new instance of <em>ModelConstructor</em>.</p>",
                    "params": [{
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "options",
                            "description": "<p>Options to pass to <code>setup</code> or <code>init</code>.</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.Model"
                            }
                        ],
                        "description": "<p>A new instance of <em>ModelConstructor</em>.</p>"
                    }
                }
            ],
            "comment": " ",
            "src": "can/model/model.md",
            "id": 47,
            "children": [{
                    "active": false,
                    "body": "",
                    "description": "",
                    "type": "static",
                    "name": "can.Model.static",
                    "parent": "can.Model",
                    "src": "can/model/model.js",
                    "line": 118,
                    "id": 48,
                    "children": [{
                            "active": false,
                            "body": "<p><code>bind(eventType, handler(event, instance))</code> listens to\n<strong>created</strong>, <strong>updated</strong>, <strong>destroyed</strong> events on all \ninstances of the model.</p>\n\n<pre><code>Task.bind(\"created\", function(ev, createdTask){\n     this //-&gt; Task\n  createdTask.attr(\"name\") //-&gt; \"Dishes\"\n})\n\nnew Task({name: \"Dishes\"}).save();\n</code></pre>",
                            "description": "<p>Listen for events on a Model class. </p>",
                            "title": "bind",
                            "name": "can.Model.static.bind",
                            "type": "function",
                            "parent": "can.Model.static",
                            "signatures": [{
                                    "code": "bind(eventType, handler)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventType",
                                            "description": "<p>The type of event.  It must be\n<code>\"created\"</code>, <code>\"udpated\"</code>, <code>\"destroyed\"</code>.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "handler",
                                            "description": "<p>A callback function\nthat gets called with the event and instance that was\ncreated, destroyed, or updated.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>The model constructor function.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 122,
                            "id": 49
                        }, {
                            "active": false,
                            "body": "<p><code>unbind(eventType, handler)</code> removes a listener\nattached with [can.Model.bind].</p>\n\n<pre><code>var handler = function(ev, createdTask){\n\n}\nTask.bind(\"created\", handler)\nTask.unbind(\"created\", handler)\n</code></pre>\n\n<p>You have to pass the same function to <code>unbind</code> that you\npassed to <code>bind</code>.</p>",
                            "description": "<p>Stop listening for events on a Model class. </p>",
                            "title": "unbind",
                            "name": "can.Model.static.unbind",
                            "type": "function",
                            "parent": "can.Model.static",
                            "signatures": [{
                                    "code": "unbind(eventType, handler)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventType",
                                            "description": "<p>The type of event. It must be\n<code>\"created\"</code>, <code>\"udpated\"</code>, <code>\"destroyed\"</code>.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "handler",
                                            "description": "<p>A callback function\nthat was passed to <code>bind</code>.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>The model constructor function.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 148,
                            "id": 50
                        }, {
                            "active": false,
                            "body": "",
                            "description": "<p>The name of the id field.  Defaults to 'id'. Change this if it is something different.</p>\n\n<p>For example, it's common in .NET to use Id.  Your model might look like:</p>\n\n<pre><code>Friend = can.Model({\n  id: \"Id\"\n},{});\n</code></pre>",
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "title": "id",
                            "name": "can.Model.static.id",
                            "type": "property",
                            "parent": "can.Model.static",
                            "src": "can/model/model.js",
                            "line": 174,
                            "id": 51
                        }, {
                            "active": false,
                            "name": "can.Model.static.create",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>create(attributes) -&gt; Deferred</code> is used by [can.Model::save save] to create a \nmodel instance on the server. </p>\n\n<h2>Implement with a URL</h2>\n\n<p>The easiest way to implement create is to give it the url \nto post data to:</p>\n\n<pre><code>var Recipe = can.Model({\n  create: \"/recipes\"\n},{})\n</code></pre>\n\n<p>This lets you create a recipe like:</p>\n\n<pre><code>new Recipe({name: \"hot dog\"}).save();\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>You can also implement create by yourself. Create gets called \nwith <code>attrs</code>, which are the [can.Observe::serialize serialized] model \nattributes.  Create returns a <code>Deferred</code> \nthat contains the id of the new instance and any other \nproperties that should be set on the instance.</p>\n\n<p>For example, the following code makes a request \nto <code>POST /recipes.json {'name': 'hot+dog'}</code> and gets back\nsomething that looks like:</p>\n\n<pre><code>{ \n  \"id\": 5,\n  \"createdAt\": 2234234329\n}\n</code></pre>\n\n<p>The code looks like:</p>\n\n<pre><code>can.Model(\"Recipe\", {\n  create : function( attrs ){\n    return $.post(\"/recipes.json\",attrs, undefined ,\"json\");\n  }\n},{})\n</code></pre>",
                            "description": "<p>Create a new resource on the server. </p>",
                            "title": "create",
                            "signatures": [{
                                    "code": "[METHOD] /path/to/resource",
                                    "description": "<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or POST if none is specified) when saving a\nnew instance on the server. (See below for more details.)</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the created model.</p>"
                                    }
                                }, {
                                    "code": "function(serialized)",
                                    "description": "<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "serialized",
                                            "description": "<p>The [can.Observe::serialize serialized] properties of\nthe model to create.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the created model.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 209,
                            "id": 52
                        }, {
                            "active": false,
                            "name": "can.Model.static.update",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>update( id, attrs ) -&gt; Deferred</code> is used by [can.Model::save save] to \nupdate a model instance on the server. </p>\n\n<h2>Implement with a URL</h2>\n\n<p>The easist way to implement update is to just give it the url to <code>PUT</code> data to:</p>\n\n<pre><code>Recipe = can.Model({\n  update: \"/recipes/{id}\"\n},{});\n</code></pre>\n\n<p>This lets you update a recipe like:</p>\n\n<pre><code>Recipe.findOne({id: 1}, function(recipe){\n  recipe.attr('name','salad');\n  recipe.save();\n})\n</code></pre>\n\n<p>This will make an XHR request like:</p>\n\n<pre><code>PUT /recipes/1 \nname=salad\n</code></pre>\n\n<p>If your server doesn't use PUT, you can change it to post like:</p>\n\n<pre><code>$.Model(\"Recipe\",{\n  update: \"POST /recipes/{id}\"\n},{});\n</code></pre>\n\n<p>The server should send back an object with any new attributes the model \nshould have.  For example if your server udpates the \"updatedAt\" property, it\nshould send back something like:</p>\n\n<pre><code>// PUT /recipes/4 {name: \"Food\"} -&gt;\n{\n  updatedAt : \"10-20-2011\"\n}\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>You can also implement update by yourself.  Update takes the <code>id</code> and\n<code>attributes</code> of the instance to be udpated.  Update must return\na [can.Deferred Deferred] that resolves to an object that contains any \nproperties that should be set on the instance.</p>\n\n<p>For example, the following code makes a request \nto '/recipes/5.json?name=hot+dog' and gets back\nsomething that looks like:</p>\n\n<pre><code>{ \n  updatedAt: \"10-20-2011\"\n}\n</code></pre>\n\n<p>The code looks like:</p>\n\n<pre><code>Recipe = can.Model({\n  update : function(id, attrs ) {\n    return $.post(\"/recipes/\"+id+\".json\",attrs, null,\"json\");\n  }\n},{});\n</code></pre>",
                            "description": "<p>Update a resource on the server. </p>",
                            "title": "update",
                            "signatures": [{
                                    "code": "[METHOD] /path/to/resource",
                                    "description": "<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or PUT if none is specified) when updating an\ninstance on the server. (See below for more details.)</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the updated model.</p>"
                                    }
                                }, {
                                    "code": "function(id, serialized)",
                                    "description": "<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "id",
                                            "description": "<p>The ID of the model to update.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "serialized",
                                            "description": "<p>The [can.Observe::serialize serialized] properties of\nthe model to update.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the updated model.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 271,
                            "id": 53
                        }, {
                            "active": false,
                            "name": "can.Model.static.destroy",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>destroy(id) -&gt; Deferred</code> is used by [can.Model::destroy] remove a model \ninstance from the server.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>You can implement destroy with a string like:</p>\n\n<pre><code>Recipe = can.Model({\n  destroy : \"/recipe/{id}\"\n},{})\n</code></pre>\n\n<p>And use [can.Model::destroy] to destroy it like:</p>\n\n<pre><code>Recipe.findOne({id: 1}, function(recipe){\n      recipe.destroy();\n});\n</code></pre>\n\n<p>This sends a <code>DELETE</code> request to <code>/thing/destroy/1</code>.</p>\n\n<p>If your server does not support <code>DELETE</code> you can override it like:</p>\n\n<pre><code>Recipe = can.Model({\n  destroy : \"POST /recipe/destroy/{id}\"\n},{})\n</code></pre>\n\n<h2>Implement with a function</h2>\n\n<p>Implement destroy with a function like:</p>\n\n<pre><code>Recipe = can.Model({\n  destroy : function(id){\n    return $.post(\"/recipe/destroy/\"+id,{});\n  }\n},{})\n</code></pre>\n\n<p>Destroy just needs to return a deferred that resolves.</p>",
                            "description": "<p>Destroy a resource on the server. </p>",
                            "title": "destroy",
                            "signatures": [{
                                    "code": "[METHOD] /path/to/resource",
                                    "description": "<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or DELETE if none is specified) when deleting an\ninstance on the server. (See below for more details.)</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the destroyed model.</p>"
                                    }
                                }, {
                                    "code": "function(id)",
                                    "description": "<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "id",
                                            "description": "<p>The ID of the resource to destroy.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the destroyed model.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 362,
                            "id": 54
                        }, {
                            "active": false,
                            "name": "can.Model.static.findAll",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>findAll( params, success(instances), error(xhr) ) -&gt; Deferred</code> is used to retrieve model \ninstances from the server. Before you can use <code>findAll</code>, you must implement it.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>Implement findAll with a url like:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : \"/recipes.json\"\n},{});\n</code></pre>\n\n<p>The server should return data that looks like:</p>\n\n<pre><code>[\n  {\"id\" : 57, \"name\": \"Ice Water\"},\n  {\"id\" : 58, \"name\": \"Toast\"}\n]\n</code></pre>\n\n<h2>Implement with an Object</h2>\n\n<p>Implement findAll with an object that specifies the parameters to\n<code>can.ajax</code> (jQuery.ajax) like:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : {\n    url: \"/recipes.xml\",\n    dataType: \"xml\"\n  }\n},{})\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>To implement with a function, <code>findAll</code> is passed <strong>params</strong> to filter\nthe instances retrieved from the server and it should return a\ndeferred that resolves to an array of model data. For example:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : function(params){\n    return $.ajax({\n      url: '/recipes.json',\n      type: 'get',\n      dataType: 'json'})\n  }\n},{})\n</code></pre>\n\n<h2>Use</h2>\n\n<p>After implementing <code>findAll</code>, you can use it to retrieve instances of the model\nlike:</p>\n\n<pre><code>Recipe.findAll({favorite: true}, function(recipes){\n  recipes[0].attr('name') //-&gt; \"Ice Water\"\n}, function( xhr ){\n  // called if an error\n}) //-&gt; Deferred\n</code></pre>",
                            "description": "<p>Retrieve multiple resources from a server. </p>",
                            "title": "findAll",
                            "signatures": [{
                                    "code": "findAll(filters[, success[, error]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "filters",
                                            "description": "<p>Values to filter the request or results with.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "success",
                                            "description": "<p>A callback to call on successful retrieval. The callback recieves\na can.Model.List of the retrieved resources.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "error",
                                            "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A deferred that resolves to a [can.Model.List] of retrieved models.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 422,
                            "id": 55
                        }, {
                            "active": false,
                            "name": "can.Model.static.findOne",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>findOne( params, success(instance), error(xhr) ) -&gt; Deferred</code> is used to retrieve a model \ninstance from the server. Before you can use <code>findOne</code>, you must implement it.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>Implement findAll with a url like:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : \"/recipes/{id}.json\"\n},{});\n</code></pre>\n\n<p>If <code>findOne</code> is called like:</p>\n\n<pre><code>Recipe.findOne({id: 57});\n</code></pre>\n\n<p>The server should return data that looks like:</p>\n\n<pre><code>{\"id\" : 57, \"name\": \"Ice Water\"}\n</code></pre>\n\n<h2>Implement with an Object</h2>\n\n<p>Implement <code>findOne</code> with an object that specifies the parameters to\n<code>can.ajax</code> (jQuery.ajax) like:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : {\n    url: \"/recipes/{id}.xml\",\n    dataType: \"xml\"\n  }\n},{})\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>To implement with a function, <code>findOne</code> is passed <strong>params</strong> to specify\nthe instance retrieved from the server and it should return a\ndeferred that resolves to the model data.  Also notice that you now need to\nbuild the URL manually. For example:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : function(params){\n    return $.ajax({\n      url: '/recipes/' + params.id,\n      type: 'get',\n      dataType: 'json'})\n  }\n},{})\n</code></pre>\n\n<h2>Use</h2>\n\n<p>After implementing <code>findOne</code>, you can use it to retrieve an instance of the model\nlike:</p>\n\n<pre><code>Recipe.findOne({id: 57}, function(recipe){\n     recipe.attr('name') //-&gt; \"Ice Water\"\n}, function( xhr ){\n     // called if an error\n}) //-&gt; Deferred\n</code></pre>",
                            "description": "<p>Retrieve a resource from a server. </p>",
                            "title": "findOne",
                            "signatures": [{
                                    "code": "findOne(filters[, success[, error]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "filters",
                                            "description": "<p>Values to filter the request or results with.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "success",
                                            "description": "<p>A callback to call on successful retrieval. The callback recieves\nthe retrieved resource as a can.Model.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "error",
                                            "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A deferred that resolves to a [can.Model.List] of retrieved models.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 494,
                            "id": 56
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.static.models",
                            "parent": "can.Model.static",
                            "body": "<p><code>can.Model.models(data, xhr)</code> is used to \nconvert the raw response of a [can.Model.findAll] request \ninto a [can.Model.List] of model instances.  </p>\n\n<p>This method is rarely called directly. Instead the deferred returned\nby findAll is piped into <code>models</code>.  This creates a new deferred that\nresolves to a [can.Model.List] of instances instead of an array of\nsimple JS objects.</p>\n\n<p>If your server is returning data in non-standard way,\noverwriting <code>can.Model.models</code> is the best way to normalize it.</p>\n\n<h2>Quick Example</h2>\n\n<p>The following uses models to convert to a [can.Model.List] of model\ninstances.</p>\n\n<pre><code>Task = can.Model({},{})\nvar tasks = Task.models([\n  {id: 1, name : \"dishes\", complete : false},\n  {id: 2, name: \"laundry\", compelte: true}\n])\n\ntasks.attr(\"0.complete\", true)\n</code></pre>\n\n<h2>Non-standard Services</h2>\n\n<p><code>can.Model.models</code> expects data to be an array of name-value pair \nobjects like:</p>\n\n<pre><code>[{id: 1, name : \"dishes\"},{id:2, name: \"laundry\"}, ...]\n</code></pre>\n\n<p>It can also take an object with additional data about the array like:</p>\n\n<pre><code>{\n  count: 15000 //how many total items there might be\n  data: [{id: 1, name : \"justin\"},{id:2, name: \"brian\"}, ...]\n}\n</code></pre>\n\n<p>In this case, models will return a [can.Model.List] of instances found in \ndata, but with additional properties as expandos on the list:</p>\n\n<pre><code>var tasks = Task.models({\n  count : 1500,\n  data : [{id: 1, name: 'dishes'}, ...]\n})\ntasks.attr(\"name\") // -&gt; 'dishes'\ntasks.count // -&gt; 1500\n</code></pre>\n\n<h3>Overwriting Models</h3>\n\n<p>If your service returns data like:</p>\n\n<pre><code>{thingsToDo: [{name: \"dishes\", id: 5}]}\n</code></pre>\n\n<p>You will want to overwrite models to pass the base models what it expects like:</p>\n\n<pre><code>Task = can.Model({\n  models : function(data){\n    return can.Model.models.call(this,data.thingsToDo);\n  }\n},{})\n</code></pre>\n\n<p><code>can.Model.models</code> passes each intstance's data to <code>can.Model.model</code> to\ncreate the individual instances.</p>",
                            "description": "<p>Convert raw data into can.Model instances. </p>",
                            "title": "models",
                            "signatures": [{
                                    "code": "models(data[, oldList])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Array",
                                                    "template": [{
                                                            "types": [{
                                                                    "type": "Object"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "name": "data",
                                            "description": "<p>The raw data from a <code>[can.Model.findAll findAll()]</code> request.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "can.Model.List"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "oldList",
                                            "description": "<p>If supplied, this List will be updated with the data from\n<strong>data</strong>.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model.List"
                                            }
                                        ],
                                        "description": "<p>A List of Models made from the raw data.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 650,
                            "id": 57
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.static.model",
                            "parent": "can.Model.static",
                            "body": "<p><code>can.Model.model(attributes)</code> is used to convert data from the server into\na model instance.  It is rarely called directly.  Instead it is invoked as \na result of [can.Model.findOne] or [can.Model.findAll].  </p>\n\n<p>If your server is returning data in non-standard way,\noverwriting <code>can.Model.model</code> is a good way to normalize it.</p>\n\n<h2>Example</h2>\n\n<p>The following uses <code>model</code> to convert to a model\ninstance.</p>\n\n<pre><code>Task = can.Model({},{})\nvar task = Task.model({id: 1, name : \"dishes\", complete : false})\n\ntasks.attr(\"complete\", true)\n</code></pre>\n\n<p><code>Task.model(attrs)</code> is very similar to simply calling <code>new Model(attrs)</code> except\nthat it checks the model's store if the instance has already been created.  The model's \nstore is a collection of instances that have event handlers.  </p>\n\n<p>This means that if the model's store already has an instance, you'll get the same instance\nback.  Example:</p>\n\n<pre><code>// create a task\nvar taskA = new Task({id: 5, complete: true});\n\n// bind to it, which puts it in the store\n   taskA.bind(\"complete\", function(){});\n\n// use model to create / retrieve a task\nvar taskB = Task.model({id: 5, complete: true});\n\ntaskA === taskB //-&gt; true\n</code></pre>\n\n<h2>Non-standard Services</h2>\n\n<p><code>can.Model.model</code> expects to retreive attributes of the model \ninstance like:</p>\n\n<pre><code>{id: 5, name : \"dishes\"}\n</code></pre>\n\n<p>If the service returns data formatted differently, like:</p>\n\n<pre><code>{todo: {name: \"dishes\", id: 5}}\n</code></pre>\n\n<p>Overwrite <code>model</code> like:</p>\n\n<pre><code>Task = can.Model({\n  model : function(data){\n    return can.Model.model.call(this,data.todo);\n  }\n},{});\n</code></pre>",
                            "description": "<p>Convert raw data into a can.Model instance. </p>",
                            "title": "model",
                            "signatures": [{
                                    "code": "model(data)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "data",
                                            "description": "<p>The data to convert to a can.Model instance.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>An instance of can.Model made with the given data.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 788,
                            "id": 58
                        }
                    ]
                }, {
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Model.prototype",
                    "parent": "can.Model",
                    "src": "can/model/model.js",
                    "line": 868,
                    "id": 59,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.isNew",
                            "parent": "can.Model.prototype",
                            "body": "<p><code>isNew()</code> returns if the instance is has been created \non the server. <br />\nThis is essentially if the [can.Model.id] property is null or undefined.</p>\n\n<pre><code>new Recipe({id: 1}).isNew() //-&gt; false\n</code></pre>",
                            "description": "<p>Check if a Model has yet to be saved on the server. </p>",
                            "title": "isNew",
                            "signatures": [{
                                    "code": "isNew()",
                                    "description": "",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Boolean"
                                            }
                                        ],
                                        "description": "<p>Whether an instance has been saved on the server.\n(This is determined by whether <code>id</code> has a value set yet.)</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 872,
                            "id": 60
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.save",
                            "parent": "can.Model.prototype",
                            "body": "<p><code>model.save([success(model)],[error(xhr)])</code> creates or updates \nthe model instance using [can.Model.create] or\n[can.Model.update] depending if the instance\n[can.Model::isNew has an id or not].</p>\n\n<h2>Using <code>save</code> to create an instance.</h2>\n\n<p>If <code>save</code> is called on an instance that does not have \nan [can.Model.id id] property, it calls [can.Model.create]\nwith the instance's properties.  It also [can.trigger triggers]\na \"created\" event on the instance and the model.</p>\n\n<pre><code>// create a model instance\nvar todo = new Todo({name: \"dishes\"})\n\n// listen when the instance is created\ntodo.bind(\"created\", function(ev){\n     this //-&gt; todo\n})\n\n// save it on the server\ntodo.save(function(todo){\n     console.log(\"todo\", todo, \"created\")\n});\n</code></pre>\n\n<h2>Using <code>save</code> to update an instance.</h2>\n\n<p>If save is called on an instance that has \nan [can.Model.id id] property, it calls [can.Model.create]\nwith the instance's properties.  When the save is complete,\nit triggers an \"updated\" event on the instance and the instance's model.</p>\n\n<p>Instances with an\n<strong>id</strong> are typically retrieved with [can.Model.findAll] or\n[can.Model.findOne].  </p>\n\n<pre><code>// get a created model instance\nTodo.findOne({id: 5},function(todo){\n\n  // listen when the instance is updated\n  todo.bind(\"updated\", function(ev){\n       this //-&gt; todo\n  })\n\n  // update the instance's property\n  todo.attr(\"complete\", true)\n\n  // save it on the server\n  todo.save(function(todo){\n       console.log(\"todo\", todo, \"updated\")\n  });\n\n});\n</code></pre>",
                            "description": "<p>Save a model back to the server. </p>",
                            "title": "save",
                            "signatures": [{
                                    "code": "save([success[, error]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "success",
                                            "description": "<p>A callback to call on successful save. The callback recieves\nthe can.Model after saving.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "error",
                                            "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the Model after it has been saved.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 890,
                            "id": 61
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.destroy",
                            "parent": "can.Model.prototype",
                            "body": "<p>Destroys the instance by calling \n[Can.Model.destroy] with the id of the instance.</p>\n\n<pre><code>recipe.destroy(success, error);\n</code></pre>\n\n<p>This triggers \"destroyed\" events on the instance and the \nModel constructor function which can be listened to with\n[can.Model::bind] and [can.Model.bind]. </p>\n\n<pre><code>Recipe = can.Model({\n  destroy : \"DELETE /services/recipes/{id}\",\n  findOne : \"/services/recipes/{id}\"\n},{})\n\nRecipe.bind(\"destroyed\", function(){\n  console.log(\"a recipe destroyed\");    \n});\n\n// get a recipe\nRecipe.findOne({id: 5}, function(recipe){\n  recipe.bind(\"destroyed\", function(){\n    console.log(\"this recipe destroyed\")    \n  })\n  recipe.destroy();\n})\n</code></pre>",
                            "description": "<p>Destroy a Model on the server. </p>",
                            "title": "destroy",
                            "signatures": [{
                                    "code": "destroy([success[, error]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "success",
                                            "description": "<p>A callback to call on successful destruction. The callback recieves\nthe can.Model as it was just prior to destruction.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "error",
                                            "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the Model as it was before destruction.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 960,
                            "id": 62
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.bind",
                            "parent": "can.Model.prototype",
                            "body": "",
                            "description": "<p>Listen to events on this Model. </p>",
                            "title": "bind",
                            "signatures": [{
                                    "code": "bind(eventName, handler)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventName",
                                            "description": "<p>The event to bind to.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "handler",
                                            "description": "<p>The function to call when the\nevent occurs. <strong>handler</strong> is passed the event and the\nModel instance.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>The Model, for chaining.</p>\n\n<p><code>bind(eventName, handler(ev, args...) )</code> is used to listen\nto events on this model instance.  Example:</p>\n\n<pre><code>Task = can.Model()\nvar task = new Task({name : \"dishes\"})\ntask.bind(\"name\", function(ev, newVal, oldVal){})\n</code></pre>\n\n<p>Use <code>bind</code> the\nsame as [can.Observe::bind] which should be used as\na reference for listening to property changes.</p>\n\n<p>Bind on model can be used to listen to when \nan instance is:</p>\n\n<ul>\n<li>created</li>\n<li>updated</li>\n<li>destroyed</li>\n</ul>\n\n<p>like:</p>\n\n<pre><code>Task = can.Model()\nvar task = new Task({name : \"dishes\"})\n\ntask.bind(\"created\", function(ev, newTask){\n     console.log(\"created\", newTask)\n})\n.bind(\"updated\", function(ev, updatedTask){\n  console.log(\"updated\", updatedTask)\n})\n.bind(\"destroyed\", function(ev, destroyedTask){\n     console.log(\"destroyed\", destroyedTask)\n})\n\n// create, update, and destroy\ntask.save(function(){\n  task.attr('name', \"do dishes\")\n      .save(function(){\n            task.destroy()\n      })\n}); \n</code></pre>\n\n<p><code>bind</code> also extends the inherited \nbehavior of [can.Observe::bind] to track the number\nof event bindings on this object which is used to store\nthe model instance.  When there are no bindings, the \nmodel instance is removed from the store, freeing memory.  </p>"
                                    }
                                }
                            ],
                            "src": "can/model/model.js",
                            "line": 1006,
                            "id": 63
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.unbind",
                            "parent": "can.Model.prototype",
                            "body": "<p><code>unbind(eventName, handler)</code> removes a listener\nattached with [can.Model::bind].</p>\n\n<pre><code>var handler = function(ev, createdTask){\n\n}\ntask.bind(\"created\", handler)\ntask.unbind(\"created\", handler)\n</code></pre>\n\n<p>You have to pass the same function to <code>unbind</code> that you\npassed to <code>bind</code>.</p>\n\n<p>Unbind will also remove the instance from the store\nif there are no other listeners.</p>",
                            "description": "<p>Stop listening to events on this Model. </p>",
                            "title": "unbind",
                            "signatures": [{
                                    "code": "unbind(eventName[, handler])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventName",
                                            "description": "<p>The event to unbind from.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "handler",
                                            "description": "<p>A handler previously bound with <code>bind</code>.\nIf <strong>handler</strong> is not passed, <code>unbind</code> will remove all handlers\nfor the given event.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>The Model, for chaining.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 1075,
                            "id": 64
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "name": "can.Model.List",
            "type": "constructor",
            "parent": "canjs",
            "body": "",
            "description": "<p>Works exactly like [can.Observe.List] and has all of the same properties,\nevents, and functions as an observable list. The only difference is that \nwhen an item from the list is destroyed, it will automatically get removed\nfrom the list.</p>\n\n<h2>Creating a new Model List</h2>\n\n<p>To create a new model list, just use <code>new {model_name}.List(ARRAY)</code> like:</p>\n\n<pre><code>var todo1 = new Todo( { name: \"Do the dishes\" } ),\n    todo2 = new Todo( { name: \"Wash floors\" } )\nvar todos = new Todo.List( [todo1, todo2] );\n</code></pre>\n\n<h3>Model Lists in <code>can.Model</code></h3>\n\n<p>[can.Model.static.findAll can.Model.findAll] or [can.Model.models] will\nalmost always be used to return a <code>can.Model.List</code> object, even though it\nis possible to create new lists like below:</p>\n\n<pre><code>var todos = Todo.models([\n    new Todo( { name: \"Do the dishes\" } ),\n    new Todo( { name: \"Wash floors\" } )\n])\n\ntodos.constructor // -&gt; can.Model.List\n\n// the most correct way to get a can.Model.List\nTodo.findAll({}, function(todos) {\n    todos.constructor // -&gt; can.Model.List\n})\n</code></pre>\n\n<h3>Extending <code>can.Model.List</code></h3>\n\n<p>Creating custom <code>can.Model.Lists</code> allows you to extend lists with helper\nfunctions for a list of a specific type. So, if you wanted to be able to\nsee how many todos were completed and remaining something could be written\nlike:</p>\n\n<pre><code>Todo.List = can.Model.List({\n    completed: function() {\n        var completed = 0;\n        this.each(function(i, todo) {\n            completed += todo.attr('complete') ? 1 : 0\n        })\n        return completed;\n    },\n    remaining: function() {\n        return this.attr('length') - this.completed();\n    }\n})\n\nTodo.findAll({}, function(todos) {\n    todos.completed() // -&gt; 0\n    todos.remaining() // -&gt; 2\n});\n</code></pre>\n\n<h2>Removing models from model list</h2>\n\n<p>The advantage that <code>can.Model.List</code> has over a traditional <code>can.Observe.List</code>\nis that when you destroy a model, if it is in that list, it will automatically\nbe removed from the list. </p>\n\n<pre><code>// Listen for when something is removed from the todos list.\ntodos.bind(\"remove\", function( ev, oldVals, indx ) {\n    console.log(oldVals[indx].attr(\"name\") + \" removed\")\n})\n\ntodo1.destroy(); // console shows \"Do the dishes removed\"\n</code></pre>",
            "title": "",
            "inherits": "can.Observe.List",
            "src": "can/model/model.js",
            "line": 1185,
            "id": 68
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.Control",
            "body": "<div class='demo_wrapper' data-demo-src='can/control/control.html'></div><div class='iframe_wrapper' data-iframe-src='can/test/demo.html' data-iframe-height='400'></div>",
            "description": "<p>widget factory with declarative event binding. \ncan.Control helps create organized, memory-leak free, rapidly performing,\nstateful controls. Use it to create UI controls like tabs, grids, and context menus,\nand organize them into higher-order business rules with\n[can.route]. It can serve as both a traditional view and a traditional controller.</p>\n\n<h2>Todo Example</h2>\n\n<p>Here is an example of how to build a simple tab widget using can.Control:</p>\n\n<h2>Creating a Control</h2>\n\n<p>The following example builds up a basic todos widget for listing \nand completing todo items. Start by creating a control constructor \nfunction of your own by extending can.Control:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element, options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.element.html( 'todos.ejs', todos );\n    });\n  }\n});\n</code></pre>\n\n<p>Create an instance of the Todos control on the <code>todos</code> element with:</p>\n\n<pre><code>var todosControl = new Todos( '#todos', {} );\n</code></pre>\n\n<p>The control's associated [can.EJS EJS] template looks like:</p>\n\n<pre><code>&lt;% list( todos, function( todo ) { %&gt;\n  &lt;li &lt;%= (el) -&gt; el.data( 'todo', todo ) %&gt; &gt;\n    &lt;%= todo.attr( 'name' ) %&gt;\n    &lt;a href=\"javascript://\" class=\"destroy\"&gt;\n  &lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<h2>init <code>can.Control.prototype.init( element, options )</code></h2>\n\n<p><code>init</code> is called when a new can.Control instance is created. It is called with:</p>\n\n<ul>\n<li><strong>element</strong> - The wrapped element passed to the \n            control. Control accepts a\n            raw HTMLElement, a CSS selector, or a NodeList. This is\n            set as <strong>this.element</strong> on the control instance.</li>\n<li><strong>options</strong> - The second argument passed to new Control, extended with\n            the can.Control's static <strong>defaults</strong>. This is set as \n            <strong>this.options</strong> on the control instance.</li>\n</ul>\n\n<p>and any other arguments passed to <code>new can.Control()</code>. For example:</p>\n\n<pre><code>var Todos = can.Control({\n  defaults : { view: 'todos.ejs' }\n}, {\n  init: function( element , options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n        self.element.html( self.options.view, todos );\n    });\n  }\n});\n\n// create a Todos with default options\nnew Todos( document.body.firstElementChild );\n\n// overwrite the template option\nnew Todos( $( '#todos' ), { template: 'specialTodos.ejs' } );\n</code></pre>\n\n<h2>element <code>this.element</code></h2>\n\n<p>[can.Control::element] is the \nNodeList consisting of the element the control is created on. </p>\n\n<pre><code>var todosControl = new Todos( document.body.firstElementChild );\ntodosControl.element[0] //-&gt; document.body.firstElementChild\n</code></pre>\n\n<p>Each library wraps elements differently. If you are using jQuery, for example,\nthe element is wrapped with <code>jQuery( element )</code>.</p>\n\n<h2>options <code>this.options</code></h2>\n\n<p>[can.Control::options] is the second argument passed to \n<code>new can.Control()</code>, merged with the control's static <strong>defaults</strong> property.</p>\n\n<h2>Listening to events</h2>\n\n<p>Control automatically binds prototype methods that look\nlike event handlers. Listen to <strong>click</strong>s on <code>&lt;li&gt;</code> elements like:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element , options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.element.html( self.options.template, todos );\n    });\n  },\n\n  'li click': function( li, event ) {\n    console.log( 'You clicked', li.text() );\n\n    // let other controls know what happened\n    li.trigger( 'selected' );\n  }\n});\n</code></pre>\n\n<p>When an <code>&lt;li&gt;</code> is clicked, <code>\"li click\"</code> is called with:</p>\n\n<ul>\n<li>The library-wrapped <strong>element</strong> that was clicked</li>\n<li>The <strong>event</strong> data</li>\n</ul>\n\n<p>Control uses event delegation, so you can add <code>&lt;li&gt;</code>s without needing to rebind\nevent handlers.</p>\n\n<p>To destroy a todo when its <code>&lt;a href=\"javascript://\" class=\"destroy\"&gt;</code> link \nis clicked:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element, options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.element.html( self.options.template, todos );\n    });\n  },\n\n  'li click': function( li ) {\n    li.trigger( 'selected', li.model() );\n  },\n\n  'li .destroy click': function( el, ev ) {\n    // get the li element that has todo data\n    var li = el.closest( 'li' );\n\n    // get the model\n    var todo = li.data( 'todo' );\n\n    //destroy it\n    todo.destroy();\n  }\n});\n</code></pre>\n\n<p>When the todo is destroyed, EJS's live binding will remove its LI automatically.</p>\n\n<h2>Templated Event Handlers Part 1 <code>\"{eventName}\"</code></h2>\n\n<p>Customize event handler behavior with <code>\"{NAME}\"</code> in\nthe event handler name.  The following allows customization \nof the event that destroys a todo:</p>\n\n<pre><code>var Todos = can.Control( 'Todos', {\n  init: function( element , options ) { ... },\n\n  'li click': function( li ) { ... },\n\n  'li .destroy {destroyEvent}': function( el, ev ) { \n    // previous destroy code here\n  }\n});\n\n// create Todos with this.options.destroyEvent\nnew Todos( '#todos', { destroyEvent: 'mouseenter' } );\n</code></pre>\n\n<p>Values inside <code>{NAME}</code> are looked up on the control's <code>this.options</code> first,\nand then the <code>window</code>. For example, we could customize it instead like:</p>\n\n<pre><code>var Todos = can.Control( 'Todos', {\n  init: function( element , options ) { ... },\n\n  'li click': function( li ) { ... },\n\n  'li .destroy {Events.destroy}': function( el, ev ) { \n    // previous destroy code here\n  }\n});\n\n// Events config\nEvents = { destroy: 'click' };\n\n// Events.destroy is looked up on the window.\nnew Todos( '#todos' );\n</code></pre>\n\n<p>The selector can also be templated.</p>\n\n<pre><code>var Todos = can.Control( 'Todos', {\n  init: function( element , options ) { ... },\n\n  '{listElement} click': function( li ) { ... },\n\n  '{listElement} .destroy {destroyEvent}': function( el, ev ) { \n    // previous destroy code here\n  }\n});\n\n// create Todos with this.options.destroyEvent\nnew Todos( '#todos',  { \n  destroyEvent: 'mouseenter', \n  listElement: 'li' \n} );\n</code></pre>\n\n<h2>Templated Event Handlers Part 2 <code>\"{objectName}\"</code></h2>\n\n<p>Control can also bind to objects other than <code>this.element</code> with\ntemplated event handlers.  This is <em>critical</em>\nfor avoiding memory leaks that are so common among MVC applications.  </p>\n\n<p>If the value inside <code>{NAME}</code> is an object, Control will bind to that\nobject to listen for events. For example, the following tooltip listens to \nclicks on the window:</p>\n\n<pre><code>var Tooltip = can.Control({\n  '{window} click': function( el, ev ) {\n    // hide only if we clicked outside the tooltip\n    if ( !this.element.has( ev.target ) ) {\n      this.element.remove();\n    }\n  }\n});\n\n// create a Tooltip\nnew Tooltip( $( '&lt;div&gt;INFO&lt;/div&gt;' ).appendTo( el ) );\n</code></pre>\n\n<p>This is convenient when listening for model changes. If EJS were not\ntaking care of removing <code>&lt;li&gt;</code>s after their associated models were destroyed,\nwe could implement it in <code>Todos</code> like:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element, options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.todosList = todos;\n      self.element.html( self.options.template, todos );\n    });\n  },\n\n  'li click': function( li ) {\n    li.trigger( 'selected', li.model() );\n  },\n\n  'li .destroy click': function( el, ev ) {\n    // get the li element that has todo data\n    var li = el.closest( 'li' );\n\n    // get the model\n    var todo = li.data( 'todo' );\n\n    //destroy it\n    todo.destroy();\n  },\n\n  '{Todo} destroyed': function( Todo, ev, todoDestroyed ) {\n    // find where the element\n    var index = this.todosList.indexOf( todoDestroyed );\n    this.element.children( ':nth-child(' + ( index + 1 ) + ')' )\n                .remove();\n  }\n});\n\nnew Todos( '#todos' );\n</code></pre>\n\n<h2>destroy <code>control.destroy()</code></h2>\n\n<p>[can.Control::destroy] unbinds a control's\nevent handlers and releases its element, but does not remove \nthe element from the page. </p>\n\n<pre><code>var todo = new Todos( '#todos' );\ntodo.destroy();\n</code></pre>\n\n<p>When a control's element is removed from the page\n<strong>destroy</strong> is called automatically.</p>\n\n<pre><code>new Todos( '#todos' );\n$( '#todos' ).remove();\n</code></pre>\n\n<p>All event handlers bound with Control are unbound when the control \nis destroyed (or its element is removed).</p>\n\n<p><em>Brief aside on destroy and templated event binding. Taken \ntogether, templated event binding, and control's automatic\nclean-up make it almost impossible \nto write leaking applications. An application that uses\nonly templated event handlers on controls within the body\ncould free up all \ndata by calling <code>$(document.body).empty()</code>.</em></p>\n\n<h2>on <code>control.on()</code></h2>\n\n<p>[can.Control::on] rebinds a control's event handlers. This is useful when you want\nto listen to a specific model and change it:</p>\n\n<pre><code>var Editor = can.Control({\n  todo: function( todo ) {\n    this.options.todo = todo;\n    this.on();\n    this.setName();\n  },\n\n  // a helper that sets the value of the input\n  // to the todo's name\n  setName: function() {\n    this.element.val( this.options.todo.name );\n  },\n\n  // listen for changes in the todo\n  // and update the input\n  '{todo} updated': function() {\n    this.setName();\n  },\n\n  // when the input changes\n  // update the todo instance\n  'change': function() {\n    var todo = this.options.todo;\n    todo.attr( 'name', this.element.val() );\n    todo.save();\n  }\n});\n\nvar todo1 = new Todo({ id: 6, name: 'trash' }),\n    todo2 = new Todo({ id: 6, name: 'dishes' });\n\n// create the editor;\nvar editor = new Editor( '#editor' );\n\n// show the first todo\neditor.todo( todo1 );\n\n// switch it to the second todo\neditor.todo( todo2 );\n</code></pre>\n\n<p>Here's the full todo list manager in action:</p>",
            "title": "",
            "parent": "canjs",
            "plugin": "can/control",
            "test": "can/control/qunit.html",
            "inherits": "can.Construct",
            "src": "can/control/control.md",
            "id": 69,
            "children": [{
                    "active": false,
                    "type": "static",
                    "body": "",
                    "description": "",
                    "name": "can.Control.static",
                    "parent": "can.Control",
                    "src": "can/control/control.js",
                    "line": 43,
                    "id": 71,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Control.static.setup",
                            "params": [],
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "<p>Setup pre-process which methods are event listeners.</p>",
                            "hide": true,
                            "src": "can/control/control.js",
                            "line": 48,
                            "id": 72
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.static._isAction",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "methodName",
                                    "description": "<p>a prototype function</p>"
                                }
                            ],
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "Boolean"
                                    }
                                ],
                                "description": "<p>truthy if an action or not</p>"
                            },
                            "src": "can/control/control.js",
                            "line": 93,
                            "id": 73
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.static._action",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "methodName",
                                    "description": "<p>the method that will be bound</p>"
                                }, {
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "options",
                                    "description": "<p>first param merged with class default options</p>"
                                }
                            ],
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "<p>Takes a method name and the options passed to a control\nand tries to return the data necessary to pass to a processor\n(something that binds things).</p>\n\n<p>For performance reasons, this called twice.  First, it is called when \nthe Control class is created.  If the methodName is templated\nlike: \"{window} foo\", it returns null.  If it is not templated\nit returns event binding data.</p>\n\n<p>The resulting data is added to this.actions.</p>\n\n<p>When a control instance is created, _action is called again, but only\non templated actions.  </p>",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p>null or the processor and pre-split parts. <br />\nThe processor is what does the binding/subscribing.</p>"
                            },
                            "src": "can/control/control.js",
                            "line": 112,
                            "id": 74
                        }, {
                            "active": false,
                            "name": "can.Control.static.processors",
                            "type": "property",
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "<p>An object of <code>{eventName : function}</code> pairs that Control uses to hook up events\nauto-magically.  A processor function looks like:</p>\n\n<pre><code>can.Control.processors.\n  myprocessor = function( el, event, selector, cb, control ) {\n     //el - the control's element\n     //event - the event (myprocessor)\n     //selector - the left of the selector\n     //cb - the function to call\n     //control - the binding control\n  };\n</code></pre>\n\n<p>This would bind anything like: \"foo~3242 myprocessor\".</p>\n\n<p>The processor must return a function that when called, \nunbinds the event handler.</p>\n\n<p>Control already has processors for the following events:</p>\n\n<ul>\n<li>change </li>\n<li>click </li>\n<li>contextmenu </li>\n<li>dblclick </li>\n<li>focusin</li>\n<li>focusout</li>\n<li>keydown </li>\n<li>keyup </li>\n<li>keypress </li>\n<li>mousedown </li>\n<li>mouseenter</li>\n<li>mouseleave</li>\n<li>mousemove </li>\n<li>mouseout </li>\n<li>mouseover </li>\n<li>mouseup </li>\n<li>reset </li>\n<li>resize </li>\n<li>scroll </li>\n<li>select </li>\n<li>submit  </li>\n</ul>\n\n<p>Listen to events on the document or window \nwith templated event handlers:</p>\n\n<pre><code>Sized = can.Control({\n  \"{window} resize\": function(){\n    this.element.width( this.element.parent().width() / 2 );\n  }\n});\n\nnew Sized( $( '#foo' ) );\n</code></pre>",
                            "title": "processors",
                            "src": "can/control/control.js",
                            "line": 165,
                            "id": 75
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.prototype.setup",
                            "parent": "can.Control.static",
                            "body": "<p>Setup is where most of control's magic happens.  It does the following:</p>\n\n<h3>Sets this.element</h3>\n\n<p>The first parameter passed to new Control( el, options ) is expected to be \nan element.  This gets converted to a Wrapped NodeList element and set as\n[can.Control.prototype.element this.element].</p>\n\n<h3>Adds the control's name to the element's className.</h3>\n\n<p>Control adds it's plugin name to the element's className for easier \ndebugging.  For example, if your Control is named \"Foo.Bar\", it adds\n\"foo_bar\" to the className.</p>\n\n<h3>Saves the control in $.data</h3>\n\n<p>A reference to the control instance is saved in $.data.  You can find \ninstances of \"Foo.Bar\" like: </p>\n\n<pre><code>$( '#el' ).data( 'controls' )[ 'foo_bar' ]\n</code></pre>\n\n<h3>Merges Options</h3>\n\n<p>Merges the default options with optional user-supplied ones.\nAdditionally, default values are exposed in the static [can.Control.static.defaults defaults] \nso that users can change them.</p>\n\n<h3>Binds event handlers</h3>\n\n<p>Setup does the event binding described in [can.Control.listening Listening To Events].</p>",
                            "description": "<p>Perform pre-initialization logic. </p>",
                            "title": "setup",
                            "signatures": [{
                                    "code": "setup(element, options)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "HTMLElement"
                                                }
                                            ],
                                            "name": "element",
                                            "description": "<p>the element this instance operates on.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "options",
                                            "description": "<p>option values for the control.  These get added to\nthis.options and merged with [can.Control.static.defaults defaults].</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "undefined"
                                            }, {
                                                "type": "Array"
                                            }
                                        ],
                                        "description": "<p>return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 252,
                            "id": 77
                        }, {
                            "active": false,
                            "name": "can.Control.prototype.options",
                            "type": "property",
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "<p>Options are used to configure a control.  They are\nthe 2nd argument\npassed to a control (or the first argument passed to the \n[can.Control.plugin control's jQuery plugin]).</p>\n\n<p>For example:</p>\n\n<pre><code>can.Control('Hello')\n\nvar h1 = new Hello( $( '#content1' ), { message: 'World' } );\nequal( h1.options.message , \"World\" );\n\nvar h2 = $( '#content2' ).hello({ message: 'There' })\n                         .control();\nequal( h2.options.message , \"There\" );\n</code></pre>\n\n<p>Options are merged with [can.Control.static.defaults defaults] in\n[can.Control.prototype.setup setup].</p>\n\n<p>For example:</p>\n\n<pre><code>Tabs = can.Control({\n   defaults: {\n     activeClass: \"ui-active-state\"\n   }\n}, {\n   init: function(){\n     this.element.addClass( this.options.activeClass );\n   }\n});\n\nnew Tabs( $( \"#tabs1\" ) ); // adds 'ui-active-state'\nnew Tabs( $( \"#tabs2\" ), { activeClass : 'active' } ); // adds 'active'\n</code></pre>\n\n<p>Options are typically updated by calling \n[can.Control.prototype.update update];</p>",
                            "title": "options",
                            "src": "can/control/control.js",
                            "line": 311,
                            "id": 78
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.prototype.on",
                            "parent": "can.Control.static",
                            "body": "<p><code>on(el, selector, eventName, func)</code> binds an event handler for an event to a selector under the scope of the given element.</p>\n\n<p><code>this.on()</code> is used to rebind \nall event handlers when [can.Control::options this.options] has changed.  It\ncan also be used to bind or delegate from other elements or objects.</p>\n\n<h2>Rebinding</h2>\n\n<p>By using templated event handlers, a control can listen to objects outside\n<code>this.element</code>.  This is extremely common in MVC programming.  For example,\nthe following control might listen to a task model's <code>completed</code> property and\ntoggle a strike className like:</p>\n\n<pre><code>TaskStriker = can.Control({\n  \"{task} completed\": function(){\n       this.update();\n  },\n  update: function(){\n    if ( this.options.task.completed ) {\n         this.element.addClass( 'strike' );\n       } else {\n      this.element.removeClass( 'strike' );\n    }\n  }\n});\n\nvar taskstriker = new TaskStriker({ \n  task: new Task({ completed: 'true' }) \n});\n</code></pre>\n\n<p>To update the taskstriker's task, add a task method that updates\nthis.options and calls rebind like:</p>\n\n<pre><code>TaskStriker = can.Control({\n  \"{task} completed\": function(){\n       this.update();\n  },\n  update: function() {\n    if ( this.options.task.completed ) {\n         this.element.addClass( 'strike' );\n       } else {\n      this.element.removeClass( 'strike' );\n    }\n  },\n  task: function( newTask ) {\n    this.options.task = newTask;\n    this.on();\n    this.update();\n  }\n});\n\nvar taskstriker = new TaskStriker({ \n  task: new Task({ completed: true }) \n});\ntaskstriker.task( new TaskStriker({ \n  task: new Task({ completed: false }) \n}));\n</code></pre>\n\n<h2>Adding new events</h2>\n\n<p>If events need to be bound to outside of the control and templated event handlers\nare not sufficent, you can call this.on to bind or delegate programatically:</p>\n\n<pre><code>init: function() {\n   // calls somethingClicked( el, ev )\n   this.on( 'click', 'somethingClicked' ); \n\n   // calls function when the window is clicked\n   this.on( window, 'click', function( ev ) {\n     //do something\n   });\n},\nsomethingClicked: function( el, ev ) {\n\n}\n</code></pre>",
                            "description": "<p>Bind an event handler to a Control, or rebind all event handlers on a Control. </p>",
                            "title": "on",
                            "signatures": [{
                                    "code": "on([el,] selector, eventName, func)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "HTMLElement"
                                                }, {
                                                    "type": "jQuery"
                                                }, {
                                                    "type": "collection"
                                                }, {
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "el",
                                            "defaultValue": "this.element",
                                            "description": "<p>The element to be bound.  If no element is provided, the control's element is used instead.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "selector",
                                            "description": "<p>A css selector for event delegation.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventName",
                                            "description": "<p>The event to listen for.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }, {
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "func",
                                            "description": "<p>A callback function or the String name of a control function.  If a control\nfunction name is given, the control function is called back with the bound element and event as the first\nand second parameter.  Otherwise the function is called back like a normal bind.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>The id of the binding in this._bindings</p>"
                                    }
                                }, {
                                    "code": "on()",
                                    "description": "",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>The number of handlers bound to this Control.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 460,
                            "id": 80
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.static.off",
                            "params": [],
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "<p>Unbinds all event handlers on the controller. You should never\nbe calling this unless in use with [can.Control::on].</p>",
                            "hide": true,
                            "src": "can/control/control.js",
                            "line": 610,
                            "id": 81
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.static.destroy",
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "<p>Clean up after a Control that has been removed. </p>",
                            "signatures": [{
                                    "code": "destroy()",
                                    "description": "<p><code>destroy</code> prepares a control for garbage collection and is a place to\nreset any changes the control has made.  </p>\n\n<h2>Allowing Garbage Collection</h2>\n\n<p>Destroy is called whenever a control's element is removed from the page using \nthe library's standard HTML modifier methods.  This means that you\ndon't have to call destroy yourself and it \nwill be called automatically when appropriate.  </p>\n\n<p>The following <code>Clicker</code> widget listens on the window for clicks and updates\nits element's innerHTML.  If we remove the element, the window's event handler\nis removed auto-magically:</p>\n\n<pre><code> Clickr = can.Control({\n  \"{window} click\": function() {\n       this.element.html( this.count ? \n                          this.count++ : this.count = 0 );\n  }  \n});\n\n// create a clicker on an element\nnew Clicker( \"#clickme\" );\n\n// remove the element\n$( '#clickme' ).remove();\n</code></pre>\n\n<p>The methods you can use that will destroy controls automatically by library:</p>\n\n<p><strong>jQuery and Zepto</strong></p>\n\n<ul>\n<li>$.fn.remove</li>\n<li>$.fn.html</li>\n<li>$.fn.replaceWith</li>\n<li>$.fn.empty</li>\n</ul>\n\n<p><strong>Dojo</strong></p>\n\n<ul>\n<li>dojo.destroy</li>\n<li>dojo.empty</li>\n<li>dojo.place (with the replace option)</li>\n</ul>\n\n<p><strong>Mootools</strong></p>\n\n<ul>\n<li>Element.prototype.destroy</li>\n</ul>\n\n<p><strong>YUI</strong></p>\n\n<ul>\n<li>TODO!</li>\n</ul>\n\n<h2>Teardown in Destroy</h2>\n\n<p>Sometimes, you want to reset a controlled element back to its\noriginal state when the control is destroyed.  Overwriting destroy\nlets you write teardown code of this manner.  <strong>When overwriting\ndestroy, make sure you call Control's base functionality</strong>.</p>\n\n<p>The following example changes an element's text when the control is\ncreated and sets it back when the control is removed:</p>\n\n<pre><code>Changer = can.Control({\n  init: function() {\n    this.oldText = this.element.text();\n    this.element.text( \"Changed!!!\" );\n  },\n  destroy: function() {\n    this.element.text( this.oldText );\n    can.Control.prototype.destroy.call( this );\n  }\n});\n\n// create a changer which changes #myel's text\nvar changer = new Changer( '#myel' );\n\n// destroy changer which will reset it\nchanger.destroy();\n</code></pre>\n\n<h2>Base Functionality</h2>\n\n<p>Control prepares the control for garbage collection by:</p>\n\n<ul>\n<li>unbinding all event handlers</li>\n<li>clearing references to this.element and this.options</li>\n<li>clearing the element's reference to the control</li>\n<li>removing it's [can.Control.pluginName] from the element's className</li>\n</ul>",
                                    "params": []
                                }
                            ],
                            "src": "can/control/control.js",
                            "line": 624,
                            "id": 82
                        }
                    ]
                }
            ]
        }
    ]
}