{
    "active": false,
    "type": "page",
    "name": "canjs",
    "body": "",
    "description": "<p>CanJS API Documentation. </p>\n\n<h2>CanJS API Documentation</h2>\n\n<h3>What is CanJS?</h3>\n\n<p>CanJS makes building rich web applications easy. It provides a lightweight inheritance system,\nbookmark and back-button support, a powerful MVC core with live templates, and more &mdash;\nall for about 8k (minified and gzipped).</p>\n\n<p>CanJS is built to work with jQuery, Zepto, Dojo, YUI and Mootools right out of the box.</p>\n\n<p><a href=\"http://canjs.us/\">CanJS.us</a> is an overview and getting started guide to CanJS. Get up to\nspeed on CanJS, then come back here for a more detailed reference.</p>",
    "title": "CanJS",
    "parent": "index",
    "order": 0,
    "src": "can/can.md",
    "id": 0,
    "children": [{
            "active": false,
            "type": "constructor",
            "name": "can.Construct",
            "body": "",
            "description": "",
            "title": "",
            "download": "can/construct",
            "test": "can/construct/qunit.html",
            "parent": "canjs",
            "signatures": [{
                    "code": "can.Construct([name, [staticProperties,]] instanceProperties)",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "optional": true,
                            "name": "name",
                            "description": "<p>the namespace and name of the constructor</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "staticProperties",
                            "description": "<p>properties that will belong to the constructor</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "instanceProperties",
                            "description": "<p>properties that will belong to instances made with the constructor</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "description": "<p>The constructor.</p>\n\n<p>In the example below, <code>Animal</code> is a constructor function. All instances of <code>Animal</code> will have a <code>breathe</code>\nmethod, and the <code>Animal</code> constructor itself has a <code>legs</code> property.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('Animal', {\n    legs: 4\n}, {\n    init: function(sound) {\n        this.sound = sound;\n    }\n    speak: function() {\n        console.log(this.sound);\n    }\n});</code></pre>\n\n<p>You don't have to pass in a name. If you do, the constructor is assigned to that name globally. If not,\nyou'll want to make sure you save your constructor to use later:</p>\n\n<pre><code class=\"lang-javascript\">var Robot = can.Construct({\n    beep: function() {\n        console.log('Beep boop.');\n    }\n});</code></pre>\n\n<p>You can make instances by calling your constructor with the <code>new</code> keyword. When you do, the [can.Construct::init|init]\nmethod gets called (if you supplied one):</p>\n\n<pre><code class=\"lang-javascript\">var panther = new Animal({sound: 'growl'});\npanther.speak(); // \"growl\"\npanther instanceof Animal; // true</code></pre>\n\n<p>This becomes much more powerful when you add inheritance.</p>\n\n<h2>Inheritance</h2>\n\n<p>Subclasses with <code>can.Construct</code> are simple. All you need to do is call the base constructor\nwith the new function's static and instance properties. For example, we want our <code>Snake</code> to\nbe an <code>Animal</code>, but there are some differences:</p>\n\n<pre><code class=\"lang-javascript\">Animal('Snake', {\n    legs: 0\n}, {\n    init: function() {\n        this.sound = 'ssssss';\n    },\n    slither: function() {\n        console.log('slithering...');\n    }\n});\n\nvar baslisk = new Snake();\nbaslisk.speak();   // \"ssssss\"\nbaslisk.slither(); // \"slithering...\"\nbaslisk instanceof Snake;  // true\nbaslisk instanceof Animal; // true</code></pre>\n\n<p>Note that <code>Animal</code>'s <code>init</code> does not get called.</p>\n\n<h2>Static properties and inheritance</h2>\n\n<p>If you pass all three arguments to can.Construct, the second one will be attached directy to the\nconstructor, allowing you to imitate static properties and functions. You can access these\nproperties through the <code>[can.Construct::constructor|this.constructor]</code> property.</p>\n\n<p>Static properties can get overridden through inheritance just like instance properties. Let's see\nhow this works with <code>Animal</code> and <code>Snake</code>:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('Animal', {\n    legs: 4\n}, {\n    init: function(sound) {\n        this.sound = sound;\n    }\n    speak: function() {\n        console.log(this.sound);\n    }\n});\n\nAnimal('Snake', {\n    legs: 0\n}, {\n    init: function() {\n        this.sound = 'ssssss';\n    },\n    slither: function() {\n        console.log('slithering...');\n    }\n});\n\nAnimal.legs; // 4\nSnake.legs; // 0</code></pre>\n\n<h2>Plugins</h2>\n\n<p>There are two plugins available to help make using <code>can.Construct</code> even simpler.\n* [can.Construct.super] allows you to easily call base methods by making <code>this._super</code> available in inherited methods.\n* [can.Construct.proxy] helps you keep your scope straight when creating callbacks inside constructors.</p>"
                    }
                }
            ],
            "src": "can/construct/construct.md",
            "id": 1,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Construct.prototype",
                    "parent": "can.Construct",
                    "src": "can/construct/construct.js",
                    "line": 325,
                    "id": 9,
                    "children": [{
                            "active": false,
                            "type": "property",
                            "body": "",
                            "description": "<p>A reference to the constructor function that created the instance. This allows you to access\nthe constructor's static properties from an instance.</p>\n\n<h2>Example</h2>\n\n<p>This class has a static counter that counts how mane instances have been created:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"Counter\", {\n    count: 0\n}, {\n    init: function() {\n        this.constructor.count++;\n    }\n});\n\nnew Counter();\nCounter.count; // 1</code></pre>         ",
                            "types": [{
                                    "type": "function",
                                    "returns": {
                                        "types": [{
                                                "type": "undefined"
                                            }
                                        ]
                                    },
                                    "params": []
                                }
                            ],
                            "title": "constructor",
                            "name": "can.Construct.prototype.constructor",
                            "parent": "can.Construct.prototype",
                            "src": "can/construct/construct.js",
                            "line": 445,
                            "id": 12
                        }, {
                            "active": false,
                            "body": "<p>If a prototype <code>init</code> method is provided, it is called when a new Construct is created,\nafter [can.Construct::setup]. The <code>init</code> method is where the bulk of your initialization code\nshould go, and a common thing to do in <code>init</code> is to save the arguments passed into the constructor.</p>\n\n<h2>Examples</h2>\n\n<p>First, we'll make a Person constructor that has a first and last name:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"Person\", {\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar justin = new Person(\"Justin\", \"Meyer\");\njustin.first; // \"Justin\"\njustin.last; // \"Meyer\"</code></pre>\n\n<p>Then we'll extend Person into Programmer and add a favorite language:</p>\n\n<pre><code class=\"lang-javascript\">Person(\"Programmer\", {\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return 'Hi! I'm ' + this.first + ' ' + this.last +\n            ' and I write ' + this.language + '.';\n    }\n});\n\nvar brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\nbrian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";</code></pre>\n\n<h2>Be Aware</h2>\n\n<p>[can.Construct::setup] is able to modify the arguments passed to <code>init</code>.\nIf you aren't receiving the right arguments to <code>init</code>, check to make sure\nthat they aren't being changed by <code>setup</code> somewhere along the inheritance chain.</p>",
                            "description": "",
                            "title": "init",
                            "name": "can.Construct.prototype.init",
                            "type": "function",
                            "parent": "can.Construct.prototype",
                            "signatures": [{
                                    "code": "init(...args)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "args",
                                            "description": "<p>the arguments passed to the constructor (or the elements of the array returned from [can.Construct::setup])</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/construct/construct.js",
                            "line": 389,
                            "id": 11
                        }, {
                            "active": false,
                            "body": "<p>If a prototype <code>setup</code> method is provided, it is called when a new \ninstance is created. It is passed the same arguments that were passed\nto the constructor.</p>\n\n<p>Because <code>setup</code> is not defined on <code>can.Construct</code> itself, calling super from\ndirectly-inheriting classes will break. In other words, don't do this:</p>\n\n<pre><code class=\"lang-javascript\">can.Construct('Snowflake', {\n    setup: function() {\n        this._super(); // this will break!\n    }\n});</code></pre>\n\n<h2><code>setup</code> vs. <code>init</code></h2>\n\n<p>Usually, you should use [can.Construct::init] to do your class's initialization.\nUse <code>setup</code> instead for:</p>\n\n<ul>\n<li>initialization code that you want to run before the inheriting constructor's \n<code>init</code> method is called.</li>\n<li>initialization code that should run whether or not inheriting constructors\ncall their base's <code>init</code> methods.</li>\n<li>modifying the arguments that will get passed to <code>init</code>.</li>\n</ul>\n\n<h2>Example</h2>\n\n<p>This code is a simplified version of the code in [can.Control]'s setup\nmethod. It converts the first argument to a jQuery collection and\nextends the controller's defaults with the options that were passed.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"can.Control\", {\n    setup: function(domElement, rawOptions) {\n        // set up this.element\n        this.element = $(domElement);\n\n        // set up this.options\n        this.options = can.extend({},\n                                  this.constructor.defaults,\n                                  rawOptions\n                                 );\n\n        // pass this.element and this.options to init.\n        return [this.element, this.options];        \n    }\n});</code></pre>         ",
                            "description": "",
                            "title": "setup",
                            "name": "can.Construct.prototype.setup",
                            "type": "function",
                            "parent": "can.Construct.prototype",
                            "signatures": [{
                                    "code": "setup(...args)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "args",
                                            "description": "<p>the arguments passed to the constructor.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Array"
                                            }, {
                                                "type": "undefined"
                                            }
                                        ],
                                        "description": "<p>if an array is returned, the elements of that array are passed as\narguments to [can.Construct::init]. Otherwise, the arguments to the\nconstructor are passed to [can.Construct::init] and the return value of <code>setup</code> is discarded.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/construct/construct.js",
                            "line": 329,
                            "id": 10
                        }
                    ]
                }, {
                    "active": false,
                    "type": "static",
                    "body": "",
                    "description": "",
                    "name": "can.Construct.static",
                    "parent": "can.Construct",
                    "src": "can/construct/construct.js",
                    "line": 22,
                    "id": 2,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Construct.static.extend",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "fullName",
                                    "description": "<p>the class's name (used for classes w/ introspection)</p>"
                                }, {
                                    "types": [{
                                            "type": "Object",
                                            "template": [{
                                                    "types": [{
                                                            "type": "string"
                                                        }
                                                    ]
                                                }, {
                                                    "types": [{
                                                            "type": "function",
                                                            "returns": {
                                                                "types": [{
                                                                        "type": "undefined"
                                                                    }
                                                                ]
                                                            },
                                                            "params": []
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ],
                                    "optional": true,
                                    "name": "klass",
                                    "description": "<p>the new class's static functions</p>"
                                }, {
                                    "types": [{
                                            "type": "Object",
                                            "template": [{
                                                    "types": [{
                                                            "type": "string"
                                                        }
                                                    ]
                                                }, {
                                                    "types": [{
                                                            "type": "function",
                                                            "returns": {
                                                                "types": [{
                                                                        "type": "undefined"
                                                                    }
                                                                ]
                                                            },
                                                            "params": []
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ],
                                    "optional": true,
                                    "name": "proto",
                                    "description": "<p>the new class's prototype functions</p>"
                                }
                            ],
                            "parent": "can.Construct.static",
                            "body": "",
                            "description": "<p>Extends a class with new static and prototype functions.  There are a variety of ways\nto use extend:</p>\n\n<pre><code>// with className, static and prototype functions\ncan.Construct('Task',{ STATIC },{ PROTOTYPE })\n// with just classname and prototype functions\ncan.Construct('Task',{ PROTOTYPE })\n// with just a className\ncan.Construct('Task')\n</code></pre>\n\n<p>You no longer have to use <code>extend</code>.  Instead, you can pass those options directly to\ncan.Construct (and any inheriting classes):</p>\n\n<pre><code>// with className, static and prototype functions\ncan.Construct('Task',{ STATIC },{ PROTOTYPE })\n// with just classname and prototype functions\ncan.Construct('Task',{ PROTOTYPE })\n// with just a className\ncan.Construct('Task')\n</code></pre>",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "can.Construct"
                                    }
                                ],
                                "description": "<p>returns the new class</p>"
                            },
                            "src": "can/construct/construct.js",
                            "line": 169,
                            "id": 5
                        }, {
                            "active": false,
                            "name": "can.Construct.static.fullName",
                            "type": "property",
                            "parent": "can.Construct.static",
                            "body": "",
                            "description": "<p>If you pass a name when creating a Construct, the <code>fullName</code> property will be set to\nthe name you passed.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"</code></pre>             ",
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "title": "fullName",
                            "src": "can/construct/construct.js",
                            "line": 296,
                            "id": 8
                        }, {
                            "active": false,
                            "name": "can.Construct.static.namespace",
                            "type": "property",
                            "parent": "can.Construct.static",
                            "body": "",
                            "description": "<p>The <code>namespace</code> property returns the namespace your constructor is in.\nThis provides a way organize code and ensure globally unique types.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"</code></pre>             ",
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "title": "namespace",
                            "src": "can/construct/construct.js",
                            "line": 267,
                            "id": 6
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Construct.static.newInstance",
                            "parent": "can.Construct.static",
                            "body": "<p>Creates a new instance of the constructor function. This method is useful for creating new instances\nwith arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n<strong>new</strong> operator.</p>\n\n<h2>Example</h2>\n\n<p>The following creates a <code>Person</code> Construct and then creates a new instance of Person,\nusing <code>apply</code> on newInstance to pass arbitrary parameters.</p>\n\n<pre><code class=\"lang-javascript\">var Person = can.Construct({\n  init : function(first, middle, last) {\n    this.first = first;\n    this.middle = middle;\n    this.last = last;\n  }\n});\n\nvar args = [\"Justin\",\"Barry\",\"Meyer\"],\n    justin = new Person.newInstance.apply(null, args);</code></pre>     ",
                            "description": "<p>Create a new instance of a Construct. </p>",
                            "title": "newInstance",
                            "signatures": [{
                                    "code": "newInstance([...args])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "args",
                                            "description": "<p>arguments that get passed to [can.Construct::setup] and [can.Construct::init]. Note\nthat if [can.Construct::setup] returns an array, those arguments will be passed to [can.Construct::init]\ninstead.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "class"
                                            }
                                        ],
                                        "description": "<p>instance of the class</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/construct/construct.js",
                            "line": 26,
                            "id": 3
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Construct.static.setup",
                            "parent": "can.Construct.static",
                            "body": "<p>The static <code>setup</code> method is called immediately after a constructor function is created and \nset to inherit from its base constructor. It is useful for setting up additional inheritance work.\nDo not confuse this with the prototype <code>[can.Construct::setup]</code> method.</p>\n\n<h2>Setup Extends Defaults</h2>\n\n<p>Setup deeply extends the static <code>defaults</code> property of the base constructor with \nproperties of the inheriting constructor.  For example:</p>\n\n<pre><code class=\"lang-javascript\">Parent = can.Construct({\n  defaults : {\n    parentProp: 'foo'\n  }\n},{})\n\nChild = Parent({\n  defaults : {\n    childProp : 'bar'\n  }\n},{}\n\nChild.defaults // {parentProp: 'foo', 'childProp': 'bar'}</code></pre>\n\n<h2>Example</h2>\n\n<p>This <code>Parent</code> class adds a reference to its base class to itself, and\nso do all the classes that inherit from it.</p>\n\n<pre><code class=\"lang-javascript\">Parent = can.Construct({\n  setup : function(base, fullName, staticProps, protoProps){\n    this.base = base;\n\n    // call base functionality\n    can.Construct.setup.apply(this, arguments)\n  }\n},{});\n\nParent.base; // can.Construct\n\nChild = Parent({});\n\nChild.base; // Parent</code></pre>     ",
                            "description": "<p>Perform initialization logic for a constructor function. </p>",
                            "title": "setup",
                            "signatures": [{
                                    "code": "setup(base, fullName, staticProps, protoProps)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "constructor"
                                                }
                                            ],
                                            "name": "base",
                                            "description": "<p>The base constructor that is being inherited from.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "fullName",
                                            "description": "<p>The name of the new constructor.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "staticProps",
                                            "description": "<p>The static properties of the new constructor.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "protoProps",
                                            "description": "<p>The prototype properties of the new constructor.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/construct/construct.js",
                            "line": 93,
                            "id": 4
                        }, {
                            "active": false,
                            "name": "can.Construct.static.shortName",
                            "type": "property",
                            "parent": "can.Construct.static",
                            "body": "",
                            "description": "<p>If you pass a name when creating a Construct, the <code>shortName</code> property will be set to the\nname you passed without the namespace.</p>\n\n<pre><code class=\"lang-javascript\">can.Construct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"</code></pre>             ",
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "title": "shortName",
                            "src": "can/construct/construct.js",
                            "line": 281,
                            "id": 7
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.Control",
            "body": "<div class='demo_wrapper' data-demo-src='can/control/control.html'></div><div class='iframe_wrapper' data-iframe-src='can/test/demo.html' data-iframe-height='400'></div>",
            "description": "<p>widget factory with declarative event binding. \ncan.Control helps create organized, memory-leak free, rapidly performing,\nstateful controls. Use it to create UI controls like tabs, grids, and context menus,\nand organize them into higher-order business rules with\n[can.route]. It can serve as both a traditional view and a traditional controller.</p>\n\n<h2>Todo Example</h2>\n\n<p>Here is an example of how to build a simple tab widget using can.Control:</p>\n\n<h2>Creating a Control</h2>\n\n<p>The following example builds up a basic todos widget for listing \nand completing todo items. Start by creating a control constructor \nfunction of your own by extending can.Control:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element, options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.element.html( 'todos.ejs', todos );\n    });\n  }\n});\n</code></pre>\n\n<p>Create an instance of the Todos control on the <code>todos</code> element with:</p>\n\n<pre><code>var todosControl = new Todos( '#todos', {} );\n</code></pre>\n\n<p>The control's associated [can.EJS EJS] template looks like:</p>\n\n<pre><code>&lt;% list( todos, function( todo ) { %&gt;\n  &lt;li &lt;%= (el) -&gt; el.data( 'todo', todo ) %&gt; &gt;\n    &lt;%= todo.attr( 'name' ) %&gt;\n    &lt;a href=\"javascript://\" class=\"destroy\"&gt;\n  &lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<h2>init <code>can.Control.prototype.init( element, options )</code></h2>\n\n<p><code>init</code> is called when a new can.Control instance is created. It is called with:</p>\n\n<ul>\n<li><strong>element</strong> - The wrapped element passed to the \n            control. Control accepts a\n            raw HTMLElement, a CSS selector, or a NodeList. This is\n            set as <strong>this.element</strong> on the control instance.</li>\n<li><strong>options</strong> - The second argument passed to new Control, extended with\n            the can.Control's static <strong>defaults</strong>. This is set as \n            <strong>this.options</strong> on the control instance.</li>\n</ul>\n\n<p>and any other arguments passed to <code>new can.Control()</code>. For example:</p>\n\n<pre><code>var Todos = can.Control({\n  defaults : { view: 'todos.ejs' }\n}, {\n  init: function( element , options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n        self.element.html( self.options.view, todos );\n    });\n  }\n});\n\n// create a Todos with default options\nnew Todos( document.body.firstElementChild );\n\n// overwrite the template option\nnew Todos( $( '#todos' ), { template: 'specialTodos.ejs' } );\n</code></pre>\n\n<h2>element <code>this.element</code></h2>\n\n<p>[can.Control::element] is the \nNodeList consisting of the element the control is created on. </p>\n\n<pre><code>var todosControl = new Todos( document.body.firstElementChild );\ntodosControl.element[0] //-&gt; document.body.firstElementChild\n</code></pre>\n\n<p>Each library wraps elements differently. If you are using jQuery, for example,\nthe element is wrapped with <code>jQuery( element )</code>.</p>\n\n<h2>options <code>this.options</code></h2>\n\n<p>[can.Control::options] is the second argument passed to \n<code>new can.Control()</code>, merged with the control's static <strong>defaults</strong> property.</p>\n\n<h2>Listening to events</h2>\n\n<p>Control automatically binds prototype methods that look\nlike event handlers. Listen to <strong>click</strong>s on <code>&lt;li&gt;</code> elements like:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element , options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.element.html( self.options.template, todos );\n    });\n  },\n\n  'li click': function( li, event ) {\n    console.log( 'You clicked', li.text() );\n\n    // let other controls know what happened\n    li.trigger( 'selected' );\n  }\n});\n</code></pre>\n\n<p>When an <code>&lt;li&gt;</code> is clicked, <code>\"li click\"</code> is called with:</p>\n\n<ul>\n<li>The library-wrapped <strong>element</strong> that was clicked</li>\n<li>The <strong>event</strong> data</li>\n</ul>\n\n<p>Control uses event delegation, so you can add <code>&lt;li&gt;</code>s without needing to rebind\nevent handlers.</p>\n\n<p>To destroy a todo when its <code>&lt;a href=\"javascript://\" class=\"destroy\"&gt;</code> link \nis clicked:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element, options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.element.html( self.options.template, todos );\n    });\n  },\n\n  'li click': function( li ) {\n    li.trigger( 'selected', li.model() );\n  },\n\n  'li .destroy click': function( el, ev ) {\n    // get the li element that has todo data\n    var li = el.closest( 'li' );\n\n    // get the model\n    var todo = li.data( 'todo' );\n\n    //destroy it\n    todo.destroy();\n  }\n});\n</code></pre>\n\n<p>When the todo is destroyed, EJS's live binding will remove its LI automatically.</p>\n\n<h2>Templated Event Handlers Part 1 <code>\"{eventName}\"</code></h2>\n\n<p>Customize event handler behavior with <code>\"{NAME}\"</code> in\nthe event handler name.  The following allows customization \nof the event that destroys a todo:</p>\n\n<pre><code>var Todos = can.Control( 'Todos', {\n  init: function( element , options ) { ... },\n\n  'li click': function( li ) { ... },\n\n  'li .destroy {destroyEvent}': function( el, ev ) { \n    // previous destroy code here\n  }\n});\n\n// create Todos with this.options.destroyEvent\nnew Todos( '#todos', { destroyEvent: 'mouseenter' } );\n</code></pre>\n\n<p>Values inside <code>{NAME}</code> are looked up on the control's <code>this.options</code> first,\nand then the <code>window</code>. For example, we could customize it instead like:</p>\n\n<pre><code>var Todos = can.Control( 'Todos', {\n  init: function( element , options ) { ... },\n\n  'li click': function( li ) { ... },\n\n  'li .destroy {Events.destroy}': function( el, ev ) { \n    // previous destroy code here\n  }\n});\n\n// Events config\nEvents = { destroy: 'click' };\n\n// Events.destroy is looked up on the window.\nnew Todos( '#todos' );\n</code></pre>\n\n<p>The selector can also be templated.</p>\n\n<pre><code>var Todos = can.Control( 'Todos', {\n  init: function( element , options ) { ... },\n\n  '{listElement} click': function( li ) { ... },\n\n  '{listElement} .destroy {destroyEvent}': function( el, ev ) { \n    // previous destroy code here\n  }\n});\n\n// create Todos with this.options.destroyEvent\nnew Todos( '#todos',  { \n  destroyEvent: 'mouseenter', \n  listElement: 'li' \n} );\n</code></pre>\n\n<h2>Templated Event Handlers Part 2 <code>\"{objectName}\"</code></h2>\n\n<p>Control can also bind to objects other than <code>this.element</code> with\ntemplated event handlers.  This is <em>critical</em>\nfor avoiding memory leaks that are so common among MVC applications.  </p>\n\n<p>If the value inside <code>{NAME}</code> is an object, Control will bind to that\nobject to listen for events. For example, the following tooltip listens to \nclicks on the window:</p>\n\n<pre><code>var Tooltip = can.Control({\n  '{window} click': function( el, ev ) {\n    // hide only if we clicked outside the tooltip\n    if ( !this.element.has( ev.target ) ) {\n      this.element.remove();\n    }\n  }\n});\n\n// create a Tooltip\nnew Tooltip( $( '&lt;div&gt;INFO&lt;/div&gt;' ).appendTo( el ) );\n</code></pre>\n\n<p>This is convenient when listening for model changes. If EJS were not\ntaking care of removing <code>&lt;li&gt;</code>s after their associated models were destroyed,\nwe could implement it in <code>Todos</code> like:</p>\n\n<pre><code>var Todos = can.Control({\n  init: function( element, options ) {\n    var self = this;\n    Todo.findAll( {}, function( todos ) {\n      self.todosList = todos;\n      self.element.html( self.options.template, todos );\n    });\n  },\n\n  'li click': function( li ) {\n    li.trigger( 'selected', li.model() );\n  },\n\n  'li .destroy click': function( el, ev ) {\n    // get the li element that has todo data\n    var li = el.closest( 'li' );\n\n    // get the model\n    var todo = li.data( 'todo' );\n\n    //destroy it\n    todo.destroy();\n  },\n\n  '{Todo} destroyed': function( Todo, ev, todoDestroyed ) {\n    // find where the element\n    var index = this.todosList.indexOf( todoDestroyed );\n    this.element.children( ':nth-child(' + ( index + 1 ) + ')' )\n                .remove();\n  }\n});\n\nnew Todos( '#todos' );\n</code></pre>\n\n<h2>destroy <code>control.destroy()</code></h2>\n\n<p>[can.Control::destroy] unbinds a control's\nevent handlers and releases its element, but does not remove \nthe element from the page. </p>\n\n<pre><code>var todo = new Todos( '#todos' );\ntodo.destroy();\n</code></pre>\n\n<p>When a control's element is removed from the page\n<strong>destroy</strong> is called automatically.</p>\n\n<pre><code>new Todos( '#todos' );\n$( '#todos' ).remove();\n</code></pre>\n\n<p>All event handlers bound with Control are unbound when the control \nis destroyed (or its element is removed).</p>\n\n<p><em>Brief aside on destroy and templated event binding. Taken \ntogether, templated event binding, and control's automatic\nclean-up make it almost impossible \nto write leaking applications. An application that uses\nonly templated event handlers on controls within the body\ncould free up all \ndata by calling <code>$(document.body).empty()</code>.</em></p>\n\n<h2>on <code>control.on()</code></h2>\n\n<p>[can.Control::on] rebinds a control's event handlers. This is useful when you want\nto listen to a specific model and change it:</p>\n\n<pre><code>var Editor = can.Control({\n  todo: function( todo ) {\n    this.options.todo = todo;\n    this.on();\n    this.setName();\n  },\n\n  // a helper that sets the value of the input\n  // to the todo's name\n  setName: function() {\n    this.element.val( this.options.todo.name );\n  },\n\n  // listen for changes in the todo\n  // and update the input\n  '{todo} updated': function() {\n    this.setName();\n  },\n\n  // when the input changes\n  // update the todo instance\n  'change': function() {\n    var todo = this.options.todo;\n    todo.attr( 'name', this.element.val() );\n    todo.save();\n  }\n});\n\nvar todo1 = new Todo({ id: 6, name: 'trash' }),\n    todo2 = new Todo({ id: 6, name: 'dishes' });\n\n// create the editor;\nvar editor = new Editor( '#editor' );\n\n// show the first todo\neditor.todo( todo1 );\n\n// switch it to the second todo\neditor.todo( todo2 );\n</code></pre>\n\n<p>Here's the full todo list manager in action:</p>",
            "title": "",
            "parent": "canjs",
            "download": "can/route",
            "test": "can/control/qunit.html",
            "inherits": "can.Construct",
            "src": "can/control/control.md",
            "id": 73,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Control.prototype",
                    "parent": "can.Control",
                    "src": "can/control/control.js",
                    "line": 288,
                    "id": 81,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Control.prototype.destroy",
                            "parent": "can.Control.prototype",
                            "body": "",
                            "description": "<p>Remove a Control from an element and clean up the Control. \n<code>destroy</code> prepares a control for garbage collection and is a place to\nreset any changes the control has made.  </p>\n\n<h2>Allowing Garbage Collection</h2>\n\n<p>Destroy is called whenever a control's element is removed from the page using \nthe library's standard HTML modifier methods.  This means that you\ndon't have to call destroy yourself and it \nwill be called automatically when appropriate.  </p>\n\n<p>The following <code>Clicker</code> widget listens on the window for clicks and updates\nits element's innerHTML.  If we remove the element, the window's event handler\nis removed auto-magically:</p>\n\n<pre><code> Clickr = can.Control({\n  \"{window} click\": function() {\n       this.element.html( this.count ? \n                          this.count++ : this.count = 0 );\n  }  \n});\n\n// create a clicker on an element\nnew Clicker( \"#clickme\" );\n\n// remove the element\n$( '#clickme' ).remove();\n</code></pre>\n\n<p>The methods you can use that will destroy controls automatically by library:</p>\n\n<p><strong>jQuery and Zepto</strong></p>\n\n<ul>\n<li>$.fn.remove</li>\n<li>$.fn.html</li>\n<li>$.fn.replaceWith</li>\n<li>$.fn.empty</li>\n</ul>\n\n<p><strong>Dojo</strong></p>\n\n<ul>\n<li>dojo.destroy</li>\n<li>dojo.empty</li>\n<li>dojo.place (with the replace option)</li>\n</ul>\n\n<p><strong>Mootools</strong></p>\n\n<ul>\n<li>Element.prototype.destroy</li>\n</ul>\n\n<p><strong>YUI</strong></p>\n\n<ul>\n<li>TODO!</li>\n</ul>\n\n<h2>Teardown in Destroy</h2>\n\n<p>Sometimes, you want to reset a controlled element back to its\noriginal state when the control is destroyed.  Overwriting destroy\nlets you write teardown code of this manner.  <strong>When overwriting\ndestroy, make sure you call Control's base functionality</strong>.</p>\n\n<p>The following example changes an element's text when the control is\ncreated and sets it back when the control is removed:</p>\n\n<pre><code>Changer = can.Control({\n  init: function() {\n    this.oldText = this.element.text();\n    this.element.text( \"Changed!!!\" );\n  },\n  destroy: function() {\n    this.element.text( this.oldText );\n    can.Control.prototype.destroy.call( this );\n  }\n});\n\n// create a changer which changes #myel's text\nvar changer = new Changer( '#myel' );\n\n// destroy changer which will reset it\nchanger.destroy();\n</code></pre>\n\n<h2>Base Functionality</h2>\n\n<p>Control prepares the control for garbage collection by:</p>\n\n<ul>\n<li>unbinding all event handlers</li>\n<li>clearing references to this.element and this.options</li>\n<li>clearing the element's reference to the control</li>\n<li>removing it's [can.Control.pluginName] from the element's className</li>\n</ul>",
                            "signatures": [{
                                    "code": "destroy()",
                                    "description": "",
                                    "params": []
                                }
                            ],
                            "title": "destroy",
                            "src": "can/control/control.js",
                            "line": 682,
                            "id": 87
                        }, {
                            "active": false,
                            "body": "",
                            "description": "<p>The element the Control is associated with. \nThe control instance's HTMLElement (or window) wrapped by the \nutil library for ease of use. It is set by the first\nparameter to <code>new can.Construct( element, options )</code> \nin [can.Control::setup].  Control listens on <code>this.element</code>\nfor events.</p>\n\n<h3>Quick Example</h3>\n\n<p>The following <code>HelloWorld</code> control sets the control`s text to \"Hello World\":</p>\n\n<pre><code>HelloWorld = can.Control({\n  init: function(){\n       this.element.text( 'Hello World' );\n  }\n});\n\n// create the controller on the element\nnew HelloWorld( document.getElementById( '#helloworld' ) );\n</code></pre>\n\n<h2>Wrapped NodeList</h2>\n\n<p><code>this.element</code> is a wrapped NodeList of one HTMLELement (or window).  This\nis for convience in libraries like jQuery where all methods operate only on a\nNodeList.  To get the raw HTMLElement, write:</p>\n\n<pre><code>this.element[0] //-&gt; HTMLElement\n</code></pre>\n\n<p>The following details the NodeList used by each library with \nan example of updating it's text:</p>\n\n<p><strong>jQuery</strong> <code>jQuery( HTMLElement )</code></p>\n\n<pre><code>this.element.text(\"Hello World\")\n</code></pre>\n\n<p><strong>Zepto</strong> <code>Zepto( HTMLElement )</code></p>\n\n<pre><code>this.element.text(\"Hello World\")\n</code></pre>\n\n<p><strong>Dojo</strong> <code>new dojo.NodeList( HTMLElement )</code></p>\n\n<pre><code>// TODO\n</code></pre>\n\n<p><strong>Mootools</strong> <code>$$( HTMLElement )</code></p>\n\n<p>this.element.empty().appendText(\"Hello World\")</p>\n\n<p><strong>YUI</strong> </p>\n\n<p>// TODO</p>\n\n<h2>Changing <code>this.element</code></h2>\n\n<p>Sometimes you don't want what's passed to <code>new can.Control</code>\nto be this.element.  You can change this by overwriting\nsetup or by unbinding, setting this.element, and rebinding.</p>\n\n<h3>Overwriting Setup</h3>\n\n<p>The following Combobox overwrites setup to wrap a\nselect element with a div.  That div is used \nas <code>this.element</code>. Notice how <code>destroy</code> sets back the\noriginal element.</p>\n\n<pre><code>Combobox = can.Control({\n  setup: function( el, options ) {\n     this.oldElement = $( el );\n     var newEl = $( '&lt;div/&gt;' );\n     this.oldElement.wrap( newEl );\n     can.Controll.prototype.setup.call( this, newEl, options );\n  },\n  init: function() {\n     this.element //-&gt; the div\n  },\n  \".option click\": function() {\n    // event handler bound on the div\n  },\n  destroy: function() {\n     var div = this.element; //save reference\n     can.Control.prototype.destroy.call( this );\n     div.replaceWith( this.oldElement );\n  }\n});\n</code></pre>\n\n<h3>unbinding, setting, and rebinding.</h3>\n\n<p>You could also change this.element by calling\n[can.Control::off], setting this.element, and \nthen calling [can.Control::on] like:</p>\n\n<pre><code>move: function( newElement ) {\n   this.off();\n   this.element = $( newElement );\n   this.on();\n}\n</code></pre>",
                            "title": "element",
                            "name": "can.Control.prototype.element",
                            "type": "property",
                            "parent": "can.Control.prototype",
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 293,
                            "id": 82
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.prototype.off",
                            "params": [],
                            "parent": "can.Control.prototype",
                            "body": "",
                            "description": "<p>Unbinds all event handlers on the controller. You should never\nbe calling this unless in use with [can.Control::on].</p>",
                            "hide": true,
                            "src": "can/control/control.js",
                            "line": 668,
                            "id": 86
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.prototype.on",
                            "parent": "can.Control.prototype",
                            "body": "<p><code>on(el, selector, eventName, func)</code> binds an event handler for an event to a selector under the scope of the given element.</p>\n\n<p><code>this.on()</code> is used to rebind \nall event handlers when [can.Control::options this.options] has changed.  It\ncan also be used to bind or delegate from other elements or objects.</p>\n\n<h2>Rebinding</h2>\n\n<p>By using templated event handlers, a control can listen to objects outside\n<code>this.element</code>.  This is extremely common in MVC programming.  For example,\nthe following control might listen to a task model's <code>completed</code> property and\ntoggle a strike className like:</p>\n\n<pre><code>TaskStriker = can.Control({\n  \"{task} completed\": function(){\n       this.update();\n  },\n  update: function(){\n    if ( this.options.task.completed ) {\n         this.element.addClass( 'strike' );\n       } else {\n      this.element.removeClass( 'strike' );\n    }\n  }\n});\n\nvar taskstriker = new TaskStriker({ \n  task: new Task({ completed: 'true' }) \n});\n</code></pre>\n\n<p>To update the taskstriker's task, add a task method that updates\nthis.options and calls rebind like:</p>\n\n<pre><code>TaskStriker = can.Control({\n  \"{task} completed\": function(){\n       this.update();\n  },\n  update: function() {\n    if ( this.options.task.completed ) {\n         this.element.addClass( 'strike' );\n       } else {\n      this.element.removeClass( 'strike' );\n    }\n  },\n  task: function( newTask ) {\n    this.options.task = newTask;\n    this.on();\n    this.update();\n  }\n});\n\nvar taskstriker = new TaskStriker({ \n  task: new Task({ completed: true }) \n});\ntaskstriker.task( new TaskStriker({ \n  task: new Task({ completed: false }) \n}));\n</code></pre>\n\n<h2>Adding new events</h2>\n\n<p>If events need to be bound to outside of the control and templated event handlers\nare not sufficent, you can call this.on to bind or delegate programatically:</p>\n\n<pre><code>init: function() {\n   // calls somethingClicked( el, ev )\n   this.on( 'click', 'somethingClicked' ); \n\n   // calls function when the window is clicked\n   this.on( window, 'click', function( ev ) {\n     //do something\n   });\n},\nsomethingClicked: function( el, ev ) {\n\n}\n</code></pre>",
                            "description": "<p>Bind an event handler to a Control, or rebind all event handlers on a Control. </p>",
                            "title": "on",
                            "signatures": [{
                                    "code": "on([el,] selector, eventName, func)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "HTMLElement"
                                                }, {
                                                    "type": "jQuery"
                                                }, {
                                                    "type": "collection"
                                                }, {
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "el",
                                            "defaultValue": "this.element",
                                            "description": "<p>The element to be bound.  If no element is provided, the control's element is used instead.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "selector",
                                            "description": "<p>A css selector for event delegation.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventName",
                                            "description": "<p>The event to listen for.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }, {
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "func",
                                            "description": "<p>A callback function or the String name of a control function.  If a control\nfunction name is given, the control function is called back with the bound element and event as the first\nand second parameter.  Otherwise the function is called back like a normal bind.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>The id of the binding in this._bindings</p>"
                                    }
                                }, {
                                    "code": "on()",
                                    "description": "",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>The number of handlers bound to this Control.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 517,
                            "id": 85
                        }, {
                            "active": false,
                            "name": "can.Control.prototype.options",
                            "type": "property",
                            "parent": "can.Control.prototype",
                            "body": "<p>Options are used to configure a control.  They are\nthe 2nd argument\npassed to a control (or the first argument passed to the \n[can.Control.plugin control's jQuery plugin]).</p>\n\n<p>For example:</p>\n\n<pre><code>can.Control('Hello')\n\nvar h1 = new Hello( $( '#content1' ), { message: 'World' } );\nequal( h1.options.message , \"World\" );\n\nvar h2 = $( '#content2' ).hello({ message: 'There' })\n                         .control();\nequal( h2.options.message , \"There\" );\n</code></pre>\n\n<p>Options are merged with [can.Control.static.defaults defaults] in\n[can.Control.prototype.setup setup].</p>\n\n<p>For example:</p>\n\n<pre><code>Tabs = can.Control({\n   defaults: {\n     activeClass: \"ui-active-state\"\n   }\n}, {\n   init: function(){\n     this.element.addClass( this.options.activeClass );\n   }\n});\n\nnew Tabs( $( \"#tabs1\" ) ); // adds 'ui-active-state'\nnew Tabs( $( \"#tabs2\" ), { activeClass : 'active' } ); // adds 'active'\n</code></pre>",
                            "description": "",
                            "title": "options",
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 369,
                            "id": 84
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.prototype.setup",
                            "parent": "can.Control.prototype",
                            "body": "<p>Setup is where most of control's magic happens.  It does the following:</p>\n\n<h3>Sets this.element</h3>\n\n<p>The first parameter passed to new Control( el, options ) is expected to be \nan element.  This gets converted to a Wrapped NodeList element and set as\n[can.Control.prototype.element this.element].</p>\n\n<h3>Adds the control's name to the element's className.</h3>\n\n<p>Control adds it's plugin name to the element's className for easier \ndebugging.  For example, if your Control is named \"Foo.Bar\", it adds\n\"foo_bar\" to the className.</p>\n\n<h3>Saves the control in $.data</h3>\n\n<p>A reference to the control instance is saved in $.data.  You can find \ninstances of \"Foo.Bar\" like: </p>\n\n<pre><code>$( '#el' ).data( 'controls' )[ 'foo_bar' ]\n</code></pre>\n\n<h3>Merges Options</h3>\n\n<p>Merges the default options with optional user-supplied ones.\nAdditionally, default values are exposed in the static [can.Control.static.defaults defaults] \nso that users can change them.</p>\n\n<h3>Binds event handlers</h3>\n\n<p>Setup does the event binding described in [can.Control].</p>",
                            "description": "<p>Perform pre-initialization logic. </p>",
                            "title": "setup",
                            "signatures": [{
                                    "code": "setup(element, options)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "HTMLElement"
                                                }, {
                                                    "type": "NodeList"
                                                }, {
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "element",
                                            "description": "<p>The element as passed to the constructor.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "options",
                                            "description": "<p>option values for the control.  These get added to\nthis.options and merged with [can.Control.static.defaults defaults].</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "undefined"
                                            }, {
                                                "type": "Array"
                                            }
                                        ],
                                        "description": "<p>return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 309,
                            "id": 83
                        }
                    ]
                }, {
                    "active": false,
                    "type": "static",
                    "body": "",
                    "description": "",
                    "name": "can.Control.static",
                    "parent": "can.Control",
                    "src": "can/control/control.js",
                    "line": 43,
                    "id": 75,
                    "children": [{
                            "active": false,
                            "name": "can.Control.processors",
                            "type": "property",
                            "parent": "can.Control.static",
                            "body": "<p><code>processors</code> is an object that allows you to add new events to bind\nto on a control, or to change how existent events are bound. Each\nkey-value pair of <code>processors</code> is a specification that pertains to\nan event where the key is the name of the event, and the value is\na function that processes calls to bind to the event.</p>\n\n<p>The processor function takes five arguments:</p>\n\n<ul>\n<li><em>el</em>: The Control's element.</li>\n<li><em>event</em>: The event type.</li>\n<li><em>selector</em>: The selector preceding the event in the binding used on the Control.</li>\n<li><em>callback</em>: The callback function being bound.</li>\n<li><em>control</em>: The Control the event is bound on.</li>\n</ul>\n\n<p>Inside your processor function, you should bind <em>callback</em> to the event, and\nreturn a function for can.Control to call when <em>callback</em> needs to be unbound.\n(If <em>selector</em> is defined, you will likely want to use some form of delegation\nto bind the event.)</p>\n\n<p>Here is a Control with a custom event processor set and two callbacks bound\nto that event:</p>\n\n<pre><code class=\"lang-javascript\">can.Control.processors.birthday = function(el, ev, selector, callback, control) {\n  if(selector) {\n    myFramework.delegate(ev, el, selector, callback);\n    return function() { myFramework.undelegate(ev, el, selector, callback); };\n  } else {\n    myFramework.bind(ev, el, callback);\n    return function() { myFramework.unbind(ev, el, callback); };  \n  }\n};\n\ncan.Control(\"EventTarget\", { }, {\n  'birthday': function(el, ev) {\n    // do something appropriate for the occasion\n  },\n  '.grandchild birthday': function(el, ev) {\n    // do something appropriate for the occasion\n  }\n});\n\nvar target = new EventTarget('#person');</code></pre>\n\n<p>When <code>target</code> is initialized, can.Control will call <code>can.Control.processors.birthday</code>\ntwice (because there are two event hookups for the <em>birthday</em> event). The first\ntime it's called, the arguments will be:</p>\n\n<ul>\n<li><em>el</em>: A NodeList that wraps the element with id 'person'.</li>\n<li><em>ev</em>: <code>'birthday'</code></li>\n<li><em>selector</em>: <code>''</code></li>\n<li><em>callback</em>: The function assigned to <code>' birthday'</code> in the prototype section of <code>EventTarget</code>'s\ndefinition.</li>\n<li><em>control</em>: <code>target</code> itself.</li>\n</ul>\n\n<p>The second time, the arguments are slightly different:</p>\n\n<ul>\n<li><em>el</em>: A NodeList that wraps the element with id 'person'.</li>\n<li><em>ev</em>: <code>'birthday'</code></li>\n<li><em>selector</em>: <code>'.grandchild'</code></li>\n<li><em>callback</em>: The function assigned to <code>'.grandchild birthday'</code> in the prototype section of <code>EventTarget</code>'s\ndefinition.</li>\n<li><em>control</em>: <code>target</code> itself.</li>\n</ul>\n\n<p>can.Control already has processors for these events:</p>\n\n<ul>\n<li>change </li>\n<li>click </li>\n<li>contextmenu </li>\n<li>dblclick </li>\n<li>focusin</li>\n<li>focusout</li>\n<li>keydown </li>\n<li>keyup </li>\n<li>keypress </li>\n<li>mousedown </li>\n<li>mouseenter</li>\n<li>mouseleave</li>\n<li>mousemove </li>\n<li>mouseout </li>\n<li>mouseover </li>\n<li>mouseup </li>\n<li>reset </li>\n<li>resize </li>\n<li>scroll </li>\n<li>select </li>\n<li>submit  </li>\n</ul>",
                            "description": "<p>A collection of hookups for custom events on Controls. </p>",
                            "title": "processors",
                            "comment": " ",
                            "src": "can/control/control.js",
                            "line": 165,
                            "id": 79
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.static._action",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "methodName",
                                    "description": "<p>the method that will be bound</p>"
                                }, {
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "options",
                                    "description": "<p>first param merged with class default options</p>"
                                }
                            ],
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "<p>Takes a method name and the options passed to a control\nand tries to return the data necessary to pass to a processor\n(something that binds things).</p>\n\n<p>For performance reasons, this called twice.  First, it is called when \nthe Control class is created.  If the methodName is templated\nlike: \"{window} foo\", it returns null.  If it is not templated\nit returns event binding data.</p>\n\n<p>The resulting data is added to this.actions.</p>\n\n<p>When a control instance is created, _action is called again, but only\non templated actions.  </p>",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p>null or the processor and pre-split parts. <br />\nThe processor is what does the binding/subscribing.</p>"
                            },
                            "src": "can/control/control.js",
                            "line": 112,
                            "id": 78
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.static._isAction",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "methodName",
                                    "description": "<p>a prototype function</p>"
                                }
                            ],
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "Boolean"
                                    }
                                ],
                                "description": "<p>truthy if an action or not</p>"
                            },
                            "src": "can/control/control.js",
                            "line": 93,
                            "id": 77
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Control.static.setup",
                            "params": [],
                            "parent": "can.Control.static",
                            "body": "",
                            "description": "<p>Setup pre-process which methods are event listeners.</p>",
                            "hide": true,
                            "src": "can/control/control.js",
                            "line": 48,
                            "id": 76
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "body": "",
            "description": "<p><code>can.Deferred</code> is a object that allows users to assign and chain callback\nfunction(s) for the success or failure state of both asynchronous and synchronous function(s).</p>",
            "type": "constructor",
            "name": "can.Deferred",
            "title": "",
            "parent": "canjs",
            "signatures": [{
                    "code": "can.Deferred()",
                    "description": "",
                    "params": [],
                    "returns": {
                        "types": [{
                                "type": "can.Deferred"
                            }
                        ],
                        "description": "<p>A new Deferred object.</p>"
                    }
                }
            ],
            "src": "can/util/util.js",
            "line": 571,
            "id": 135,
            "children": [{
                    "active": false,
                    "body": "",
                    "description": "",
                    "type": "prototype",
                    "name": "can.Deferred.prototype",
                    "parent": "can.Deferred",
                    "src": "can/util/util.js",
                    "line": 582,
                    "id": 136,
                    "children": [{
                            "active": false,
                            "body": "<p><code>deferred.always( alwaysCallbacks )</code> adds handler(s) to be called when the Deferred object is either resolved or rejected.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.always( function(){\n    //- Called whether the handler fails or is success.\n});</code></pre>",
                            "description": "<p>Add a callback to be unconditionally called. </p>",
                            "title": "always",
                            "name": "can.Deferred.prototype.always",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "always(alwaysCallback)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "alwaysCallback",
                                            "description": "<p>A callback to be called whether the Deferred is resolved or rejected.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 679,
                            "id": 141
                        }, {
                            "active": false,
                            "body": "<p><code>deferred.done(doneCallback)</code> adds handler(s) to be called when the Deferred object is resolved.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.done(function(){\n    //- Deferred is done.\n});</code></pre>",
                            "description": "<p>Add a callback to be called when a Deferred is resolved. </p>",
                            "title": "done",
                            "name": "can.Deferred.prototype.done",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "done(doneCallback)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "doneCallback",
                                            "description": "<p>A callback to be called when the Deferred is resolved.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 644,
                            "id": 140
                        }, {
                            "active": false,
                            "body": "<p><code>deferred.isResolved()</code> returns whether a Deferred object has been resolved.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\nvar resolved = def.isResolved();</code></pre>",
                            "description": "<p>Determine whether a Deferred has been resolved. </p>",
                            "title": "isResolved",
                            "name": "can.Deferred.prototype.isResolved",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "isResolved()",
                                    "description": "",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Boolean"
                                            }
                                        ],
                                        "description": "<p>Whether this Boolean has been resolved.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 718,
                            "id": 143
                        }, {
                            "active": false,
                            "body": "<p><code>deferred.reject( args )</code> rejects the Deferred object and calls the fail callbacks with the given arguments.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.reject({ error: 'Thats not an animal.' })</code></pre>",
                            "description": "<p>Reject a Deferred. </p>",
                            "title": "reject",
                            "name": "can.Deferred.prototype.reject",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "reject([argument])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "argument",
                                            "description": "<p>The argument to call the <code>failCallback</code> with.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 748,
                            "id": 144
                        }, {
                            "active": false,
                            "body": "<p><code>deferred.rejectWith(context, arguments)</code> rejects a Deferred and calls the <code>failCallbacks</code> with the given arguments.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.rejectWith(this, { error: \"Animals are gone.\" })</code></pre>",
                            "description": "<p>Reject a Deferred in a particular context. </p>",
                            "title": "rejectWith",
                            "name": "can.Deferred.prototype.rejectWith",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "rejectWith(context[, arguments])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "context",
                                            "description": "<p>Context passed to the <code>failCallbacks</code> as the <code>this</code> object.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "arguments",
                                            "description": "<p>Array of arguments that are passed to the <code>failCallbacks</code>.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 627,
                            "id": 139
                        }, {
                            "active": false,
                            "body": "<p><code>deferred.resolveWith(context, arguments)</code> resolves a Deferred and calls the <code>doneCallbacks</code> with the given arguments.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.resolveWith(this, { animals: [ 'cows', 'monkey', 'panda' ] })</code></pre>",
                            "description": "<p>Resolve a Deferred in a particular context. </p>",
                            "title": "resolveWith",
                            "name": "can.Deferred.prototype.resolveWith",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "resolveWith(context[, arguments])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "context",
                                            "description": "<p>Context passed to the <code>doneCallbacks</code> as the <code>this</code> object.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "arguments",
                                            "description": "<p>Array of arguments that are passed to the <code>doneCallbacks</code>.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 610,
                            "id": 138
                        }, {
                            "active": false,
                            "body": "<p><code>deferred.then( doneCallback, failCallback )</code> adds handler(s) to be called when the Deferred object to be called after its resolved.</p>\n\n<pre><code class=\"lang-javascript\">var def = can.Deferred();\ndef.then(function(){\n    //- Called when the deferred is resolved.\n}, function(){\n    //- Called when the deferred fails.\n})</code></pre>",
                            "description": "<p>Add callbacks to a Deferred. </p>",
                            "title": "then",
                            "name": "can.Deferred.prototype.then",
                            "type": "function",
                            "parent": "can.Deferred.prototype",
                            "signatures": [{
                                    "code": "then(doneCallback[, failCallback])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "doneCallback",
                                            "description": "<p>A function called when the Deferred is resolved.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "failCallback",
                                            "description": "<p>A function called when the Deferred is rejected.</p>"
                                        }
                                    ]
                                }
                            ],
                            "comment": " ",
                            "src": "can/util/util.js",
                            "line": 697,
                            "id": 142
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.Model",
            "body": "",
            "description": "",
            "title": "",
            "parent": "canjs",
            "download": "can/model",
            "test": "can/model/qunit.html",
            "signatures": [{
                    "code": "can.Model([name,] staticProperties, instanceProperties)",
                    "description": "<p>Creates a can.Model class constructor. (See [can.Construct] for more details on this syntax.)</p>",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "optional": true,
                            "name": "name",
                            "description": "<p>If given, this will be the globally-available name of the constructor function.</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "staticProperties",
                            "description": "<p>The static properties of the class. See below for properties with\nspecial meanings to <code>can.Model</code>.</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "instanceProperties",
                            "description": "<p>The instance properties of instances of the class. These will usually\nbe functions.</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "function",
                                "returns": {
                                    "types": [{
                                            "type": "undefined"
                                        }
                                    ]
                                },
                                "params": []
                            }
                        ],
                        "description": "<p>A can.Model constructor.</p>"
                    }
                }, {
                    "code": "new ModelConstructor([options])",
                    "description": "<p>Creates a new instance of <em>ModelConstructor</em>.</p>",
                    "params": [{
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "options",
                            "description": "<p>Options to pass to <code>setup</code> or <code>init</code>.</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.Model"
                            }
                        ],
                        "description": "<p>A new instance of <em>ModelConstructor</em>.</p>"
                    }
                }
            ],
            "comment": " ",
            "src": "can/model/model.md",
            "id": 51,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Model.prototype",
                    "parent": "can.Model",
                    "src": "can/model/model.js",
                    "line": 868,
                    "id": 63,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.bind",
                            "parent": "can.Model.prototype",
                            "body": "",
                            "description": "<p>Listen to events on this Model. </p>",
                            "title": "bind",
                            "signatures": [{
                                    "code": "bind(eventName, handler)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventName",
                                            "description": "<p>The event to bind to.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "handler",
                                            "description": "<p>The function to call when the\nevent occurs. <strong>handler</strong> is passed the event and the\nModel instance.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>The Model, for chaining.</p>\n\n<p><code>bind(eventName, handler(ev, args...) )</code> is used to listen\nto events on this model instance.  Example:</p>\n\n<pre><code>Task = can.Model()\nvar task = new Task({name : \"dishes\"})\ntask.bind(\"name\", function(ev, newVal, oldVal){})\n</code></pre>\n\n<p>Use <code>bind</code> the\nsame as [can.Observe::bind] which should be used as\na reference for listening to property changes.</p>\n\n<p>Bind on model can be used to listen to when \nan instance is:</p>\n\n<ul>\n<li>created</li>\n<li>updated</li>\n<li>destroyed</li>\n</ul>\n\n<p>like:</p>\n\n<pre><code>Task = can.Model()\nvar task = new Task({name : \"dishes\"})\n\ntask.bind(\"created\", function(ev, newTask){\n     console.log(\"created\", newTask)\n})\n.bind(\"updated\", function(ev, updatedTask){\n  console.log(\"updated\", updatedTask)\n})\n.bind(\"destroyed\", function(ev, destroyedTask){\n     console.log(\"destroyed\", destroyedTask)\n})\n\n// create, update, and destroy\ntask.save(function(){\n  task.attr('name', \"do dishes\")\n      .save(function(){\n            task.destroy()\n      })\n}); \n</code></pre>\n\n<p><code>bind</code> also extends the inherited \nbehavior of [can.Observe::bind] to track the number\nof event bindings on this object which is used to store\nthe model instance.  When there are no bindings, the \nmodel instance is removed from the store, freeing memory.  </p>"
                                    }
                                }
                            ],
                            "src": "can/model/model.js",
                            "line": 1006,
                            "id": 67
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.destroy",
                            "parent": "can.Model.prototype",
                            "body": "<p>Destroys the instance by calling \n[Can.Model.destroy] with the id of the instance.</p>\n\n<pre><code>recipe.destroy(success, error);\n</code></pre>\n\n<p>This triggers \"destroyed\" events on the instance and the \nModel constructor function which can be listened to with\n[can.Model::bind] and [can.Model.bind]. </p>\n\n<pre><code>Recipe = can.Model({\n  destroy : \"DELETE /services/recipes/{id}\",\n  findOne : \"/services/recipes/{id}\"\n},{})\n\nRecipe.bind(\"destroyed\", function(){\n  console.log(\"a recipe destroyed\");    \n});\n\n// get a recipe\nRecipe.findOne({id: 5}, function(recipe){\n  recipe.bind(\"destroyed\", function(){\n    console.log(\"this recipe destroyed\")    \n  })\n  recipe.destroy();\n})\n</code></pre>",
                            "description": "<p>Destroy a Model on the server. </p>",
                            "title": "destroy",
                            "signatures": [{
                                    "code": "destroy([success[, error]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "success",
                                            "description": "<p>A callback to call on successful destruction. The callback recieves\nthe can.Model as it was just prior to destruction.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "error",
                                            "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the Model as it was before destruction.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 960,
                            "id": 66
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.isNew",
                            "parent": "can.Model.prototype",
                            "body": "<p><code>isNew()</code> returns if the instance is has been created \non the server. <br />\nThis is essentially if the [can.Model.id] property is null or undefined.</p>\n\n<pre><code>new Recipe({id: 1}).isNew() //-&gt; false\n</code></pre>",
                            "description": "<p>Check if a Model has yet to be saved on the server. </p>",
                            "title": "isNew",
                            "signatures": [{
                                    "code": "isNew()",
                                    "description": "",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Boolean"
                                            }
                                        ],
                                        "description": "<p>Whether an instance has been saved on the server.\n(This is determined by whether <code>id</code> has a value set yet.)</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 872,
                            "id": 64
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.save",
                            "parent": "can.Model.prototype",
                            "body": "<p><code>model.save([success(model)],[error(xhr)])</code> creates or updates \nthe model instance using [can.Model.create] or\n[can.Model.update] depending if the instance\n[can.Model::isNew has an id or not].</p>\n\n<h2>Using <code>save</code> to create an instance.</h2>\n\n<p>If <code>save</code> is called on an instance that does not have \nan [can.Model.id id] property, it calls [can.Model.create]\nwith the instance's properties.  It also [can.trigger triggers]\na \"created\" event on the instance and the model.</p>\n\n<pre><code>// create a model instance\nvar todo = new Todo({name: \"dishes\"})\n\n// listen when the instance is created\ntodo.bind(\"created\", function(ev){\n     this //-&gt; todo\n})\n\n// save it on the server\ntodo.save(function(todo){\n     console.log(\"todo\", todo, \"created\")\n});\n</code></pre>\n\n<h2>Using <code>save</code> to update an instance.</h2>\n\n<p>If save is called on an instance that has \nan [can.Model.id id] property, it calls [can.Model.create]\nwith the instance's properties.  When the save is complete,\nit triggers an \"updated\" event on the instance and the instance's model.</p>\n\n<p>Instances with an\n<strong>id</strong> are typically retrieved with [can.Model.findAll] or\n[can.Model.findOne].  </p>\n\n<pre><code>// get a created model instance\nTodo.findOne({id: 5},function(todo){\n\n  // listen when the instance is updated\n  todo.bind(\"updated\", function(ev){\n       this //-&gt; todo\n  })\n\n  // update the instance's property\n  todo.attr(\"complete\", true)\n\n  // save it on the server\n  todo.save(function(todo){\n       console.log(\"todo\", todo, \"updated\")\n  });\n\n});\n</code></pre>",
                            "description": "<p>Save a model back to the server. </p>",
                            "title": "save",
                            "signatures": [{
                                    "code": "save([success[, error]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "success",
                                            "description": "<p>A callback to call on successful save. The callback recieves\nthe can.Model after saving.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "error",
                                            "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the Model after it has been saved.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 890,
                            "id": 65
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.prototype.unbind",
                            "parent": "can.Model.prototype",
                            "body": "<p><code>unbind(eventName, handler)</code> removes a listener\nattached with [can.Model::bind].</p>\n\n<pre><code>var handler = function(ev, createdTask){\n\n}\ntask.bind(\"created\", handler)\ntask.unbind(\"created\", handler)\n</code></pre>\n\n<p>You have to pass the same function to <code>unbind</code> that you\npassed to <code>bind</code>.</p>\n\n<p>Unbind will also remove the instance from the store\nif there are no other listeners.</p>",
                            "description": "<p>Stop listening to events on this Model. </p>",
                            "title": "unbind",
                            "signatures": [{
                                    "code": "unbind(eventName[, handler])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventName",
                                            "description": "<p>The event to unbind from.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "handler",
                                            "description": "<p>A handler previously bound with <code>bind</code>.\nIf <strong>handler</strong> is not passed, <code>unbind</code> will remove all handlers\nfor the given event.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>The Model, for chaining.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 1075,
                            "id": 68
                        }
                    ]
                }, {
                    "active": false,
                    "body": "",
                    "description": "",
                    "type": "static",
                    "name": "can.Model.static",
                    "parent": "can.Model",
                    "src": "can/model/model.js",
                    "line": 118,
                    "id": 52,
                    "children": [{
                            "active": false,
                            "body": "<p><code>bind(eventType, handler(event, instance))</code> listens to\n<strong>created</strong>, <strong>updated</strong>, <strong>destroyed</strong> events on all \ninstances of the model.</p>\n\n<pre><code>Task.bind(\"created\", function(ev, createdTask){\n     this //-&gt; Task\n  createdTask.attr(\"name\") //-&gt; \"Dishes\"\n})\n\nnew Task({name: \"Dishes\"}).save();\n</code></pre>",
                            "description": "<p>Listen for events on a Model class. </p>",
                            "title": "bind",
                            "name": "can.Model.static.bind",
                            "type": "function",
                            "parent": "can.Model.static",
                            "signatures": [{
                                    "code": "bind(eventType, handler)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventType",
                                            "description": "<p>The type of event.  It must be\n<code>\"created\"</code>, <code>\"udpated\"</code>, <code>\"destroyed\"</code>.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "handler",
                                            "description": "<p>A callback function\nthat gets called with the event and instance that was\ncreated, destroyed, or updated.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>The model constructor function.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 122,
                            "id": 53
                        }, {
                            "active": false,
                            "name": "can.Model.static.create",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>create(attributes) -&gt; Deferred</code> is used by [can.Model::save save] to create a \nmodel instance on the server. </p>\n\n<h2>Implement with a URL</h2>\n\n<p>The easiest way to implement create is to give it the url \nto post data to:</p>\n\n<pre><code>var Recipe = can.Model({\n  create: \"/recipes\"\n},{})\n</code></pre>\n\n<p>This lets you create a recipe like:</p>\n\n<pre><code>new Recipe({name: \"hot dog\"}).save();\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>You can also implement create by yourself. Create gets called \nwith <code>attrs</code>, which are the [can.Observe::serialize serialized] model \nattributes.  Create returns a <code>Deferred</code> \nthat contains the id of the new instance and any other \nproperties that should be set on the instance.</p>\n\n<p>For example, the following code makes a request \nto <code>POST /recipes.json {'name': 'hot+dog'}</code> and gets back\nsomething that looks like:</p>\n\n<pre><code>{ \n  \"id\": 5,\n  \"createdAt\": 2234234329\n}\n</code></pre>\n\n<p>The code looks like:</p>\n\n<pre><code>can.Model(\"Recipe\", {\n  create : function( attrs ){\n    return $.post(\"/recipes.json\",attrs, undefined ,\"json\");\n  }\n},{})\n</code></pre>",
                            "description": "<p>Create a new resource on the server. </p>",
                            "title": "create",
                            "signatures": [{
                                    "code": "[METHOD] /path/to/resource",
                                    "description": "<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or POST if none is specified) when saving a\nnew instance on the server. (See below for more details.)</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the created model.</p>"
                                    }
                                }, {
                                    "code": "function(serialized)",
                                    "description": "<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "serialized",
                                            "description": "<p>The [can.Observe::serialize serialized] properties of\nthe model to create.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the created model.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 209,
                            "id": 56
                        }, {
                            "active": false,
                            "name": "can.Model.static.destroy",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>destroy(id) -&gt; Deferred</code> is used by [can.Model::destroy] remove a model \ninstance from the server.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>You can implement destroy with a string like:</p>\n\n<pre><code>Recipe = can.Model({\n  destroy : \"/recipe/{id}\"\n},{})\n</code></pre>\n\n<p>And use [can.Model::destroy] to destroy it like:</p>\n\n<pre><code>Recipe.findOne({id: 1}, function(recipe){\n      recipe.destroy();\n});\n</code></pre>\n\n<p>This sends a <code>DELETE</code> request to <code>/thing/destroy/1</code>.</p>\n\n<p>If your server does not support <code>DELETE</code> you can override it like:</p>\n\n<pre><code>Recipe = can.Model({\n  destroy : \"POST /recipe/destroy/{id}\"\n},{})\n</code></pre>\n\n<h2>Implement with a function</h2>\n\n<p>Implement destroy with a function like:</p>\n\n<pre><code>Recipe = can.Model({\n  destroy : function(id){\n    return $.post(\"/recipe/destroy/\"+id,{});\n  }\n},{})\n</code></pre>\n\n<p>Destroy just needs to return a deferred that resolves.</p>",
                            "description": "<p>Destroy a resource on the server. </p>",
                            "title": "destroy",
                            "signatures": [{
                                    "code": "[METHOD] /path/to/resource",
                                    "description": "<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or DELETE if none is specified) when deleting an\ninstance on the server. (See below for more details.)</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the destroyed model.</p>"
                                    }
                                }, {
                                    "code": "function(id)",
                                    "description": "<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "id",
                                            "description": "<p>The ID of the resource to destroy.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the destroyed model.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 362,
                            "id": 58
                        }, {
                            "active": false,
                            "name": "can.Model.static.findAll",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>findAll( params, success(instances), error(xhr) ) -&gt; Deferred</code> is used to retrieve model \ninstances from the server. Before you can use <code>findAll</code>, you must implement it.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>Implement findAll with a url like:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : \"/recipes.json\"\n},{});\n</code></pre>\n\n<p>The server should return data that looks like:</p>\n\n<pre><code>[\n  {\"id\" : 57, \"name\": \"Ice Water\"},\n  {\"id\" : 58, \"name\": \"Toast\"}\n]\n</code></pre>\n\n<h2>Implement with an Object</h2>\n\n<p>Implement findAll with an object that specifies the parameters to\n<code>can.ajax</code> (jQuery.ajax) like:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : {\n    url: \"/recipes.xml\",\n    dataType: \"xml\"\n  }\n},{})\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>To implement with a function, <code>findAll</code> is passed <strong>params</strong> to filter\nthe instances retrieved from the server and it should return a\ndeferred that resolves to an array of model data. For example:</p>\n\n<pre><code>Recipe = can.Model({\n  findAll : function(params){\n    return $.ajax({\n      url: '/recipes.json',\n      type: 'get',\n      dataType: 'json'})\n  }\n},{})\n</code></pre>\n\n<h2>Use</h2>\n\n<p>After implementing <code>findAll</code>, you can use it to retrieve instances of the model\nlike:</p>\n\n<pre><code>Recipe.findAll({favorite: true}, function(recipes){\n  recipes[0].attr('name') //-&gt; \"Ice Water\"\n}, function( xhr ){\n  // called if an error\n}) //-&gt; Deferred\n</code></pre>",
                            "description": "<p>Retrieve multiple resources from a server. </p>",
                            "title": "findAll",
                            "signatures": [{
                                    "code": "findAll(filters[, success[, error]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "filters",
                                            "description": "<p>Values to filter the request or results with.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "success",
                                            "description": "<p>A callback to call on successful retrieval. The callback recieves\na can.Model.List of the retrieved resources.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "error",
                                            "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A deferred that resolves to a [can.Model.List] of retrieved models.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 422,
                            "id": 59
                        }, {
                            "active": false,
                            "name": "can.Model.static.findOne",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>findOne( params, success(instance), error(xhr) ) -&gt; Deferred</code> is used to retrieve a model \ninstance from the server. Before you can use <code>findOne</code>, you must implement it.</p>\n\n<h2>Implement with a URL</h2>\n\n<p>Implement findAll with a url like:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : \"/recipes/{id}.json\"\n},{});\n</code></pre>\n\n<p>If <code>findOne</code> is called like:</p>\n\n<pre><code>Recipe.findOne({id: 57});\n</code></pre>\n\n<p>The server should return data that looks like:</p>\n\n<pre><code>{\"id\" : 57, \"name\": \"Ice Water\"}\n</code></pre>\n\n<h2>Implement with an Object</h2>\n\n<p>Implement <code>findOne</code> with an object that specifies the parameters to\n<code>can.ajax</code> (jQuery.ajax) like:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : {\n    url: \"/recipes/{id}.xml\",\n    dataType: \"xml\"\n  }\n},{})\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>To implement with a function, <code>findOne</code> is passed <strong>params</strong> to specify\nthe instance retrieved from the server and it should return a\ndeferred that resolves to the model data.  Also notice that you now need to\nbuild the URL manually. For example:</p>\n\n<pre><code>Recipe = can.Model({\n  findOne : function(params){\n    return $.ajax({\n      url: '/recipes/' + params.id,\n      type: 'get',\n      dataType: 'json'})\n  }\n},{})\n</code></pre>\n\n<h2>Use</h2>\n\n<p>After implementing <code>findOne</code>, you can use it to retrieve an instance of the model\nlike:</p>\n\n<pre><code>Recipe.findOne({id: 57}, function(recipe){\n     recipe.attr('name') //-&gt; \"Ice Water\"\n}, function( xhr ){\n     // called if an error\n}) //-&gt; Deferred\n</code></pre>",
                            "description": "<p>Retrieve a resource from a server. </p>",
                            "title": "findOne",
                            "signatures": [{
                                    "code": "findOne(filters[, success[, error]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "filters",
                                            "description": "<p>Values to filter the request or results with.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "success",
                                            "description": "<p>A callback to call on successful retrieval. The callback recieves\nthe retrieved resource as a can.Model.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "error",
                                            "description": "<p>A callback to call when an error occurs. The callback receives the\nXmlHttpRequest object.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A deferred that resolves to a [can.Model.List] of retrieved models.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 494,
                            "id": 60
                        }, {
                            "active": false,
                            "body": "",
                            "description": "<p>The name of the id field.  Defaults to 'id'. Change this if it is something different.</p>\n\n<p>For example, it's common in .NET to use Id.  Your model might look like:</p>\n\n<pre><code>Friend = can.Model({\n  id: \"Id\"\n},{});\n</code></pre>",
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "title": "id",
                            "name": "can.Model.static.id",
                            "type": "property",
                            "parent": "can.Model.static",
                            "src": "can/model/model.js",
                            "line": 174,
                            "id": 55
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.static.model",
                            "parent": "can.Model.static",
                            "body": "<p><code>can.Model.model(attributes)</code> is used to convert data from the server into\na model instance.  It is rarely called directly.  Instead it is invoked as \na result of [can.Model.findOne] or [can.Model.findAll].  </p>\n\n<p>If your server is returning data in non-standard way,\noverwriting <code>can.Model.model</code> is a good way to normalize it.</p>\n\n<h2>Example</h2>\n\n<p>The following uses <code>model</code> to convert to a model\ninstance.</p>\n\n<pre><code>Task = can.Model({},{})\nvar task = Task.model({id: 1, name : \"dishes\", complete : false})\n\ntasks.attr(\"complete\", true)\n</code></pre>\n\n<p><code>Task.model(attrs)</code> is very similar to simply calling <code>new Model(attrs)</code> except\nthat it checks the model's store if the instance has already been created.  The model's \nstore is a collection of instances that have event handlers.  </p>\n\n<p>This means that if the model's store already has an instance, you'll get the same instance\nback.  Example:</p>\n\n<pre><code>// create a task\nvar taskA = new Task({id: 5, complete: true});\n\n// bind to it, which puts it in the store\n   taskA.bind(\"complete\", function(){});\n\n// use model to create / retrieve a task\nvar taskB = Task.model({id: 5, complete: true});\n\ntaskA === taskB //-&gt; true\n</code></pre>\n\n<h2>Non-standard Services</h2>\n\n<p><code>can.Model.model</code> expects to retreive attributes of the model \ninstance like:</p>\n\n<pre><code>{id: 5, name : \"dishes\"}\n</code></pre>\n\n<p>If the service returns data formatted differently, like:</p>\n\n<pre><code>{todo: {name: \"dishes\", id: 5}}\n</code></pre>\n\n<p>Overwrite <code>model</code> like:</p>\n\n<pre><code>Task = can.Model({\n  model : function(data){\n    return can.Model.model.call(this,data.todo);\n  }\n},{});\n</code></pre>",
                            "description": "<p>Convert raw data into a can.Model instance. </p>",
                            "title": "model",
                            "signatures": [{
                                    "code": "model(data)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "data",
                                            "description": "<p>The data to convert to a can.Model instance.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>An instance of can.Model made with the given data.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 788,
                            "id": 62
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Model.static.models",
                            "parent": "can.Model.static",
                            "body": "<p><code>can.Model.models(data, xhr)</code> is used to \nconvert the raw response of a [can.Model.findAll] request \ninto a [can.Model.List] of model instances.  </p>\n\n<p>This method is rarely called directly. Instead the deferred returned\nby findAll is piped into <code>models</code>.  This creates a new deferred that\nresolves to a [can.Model.List] of instances instead of an array of\nsimple JS objects.</p>\n\n<p>If your server is returning data in non-standard way,\noverwriting <code>can.Model.models</code> is the best way to normalize it.</p>\n\n<h2>Quick Example</h2>\n\n<p>The following uses models to convert to a [can.Model.List] of model\ninstances.</p>\n\n<pre><code>Task = can.Model({},{})\nvar tasks = Task.models([\n  {id: 1, name : \"dishes\", complete : false},\n  {id: 2, name: \"laundry\", compelte: true}\n])\n\ntasks.attr(\"0.complete\", true)\n</code></pre>\n\n<h2>Non-standard Services</h2>\n\n<p><code>can.Model.models</code> expects data to be an array of name-value pair \nobjects like:</p>\n\n<pre><code>[{id: 1, name : \"dishes\"},{id:2, name: \"laundry\"}, ...]\n</code></pre>\n\n<p>It can also take an object with additional data about the array like:</p>\n\n<pre><code>{\n  count: 15000 //how many total items there might be\n  data: [{id: 1, name : \"justin\"},{id:2, name: \"brian\"}, ...]\n}\n</code></pre>\n\n<p>In this case, models will return a [can.Model.List] of instances found in \ndata, but with additional properties as expandos on the list:</p>\n\n<pre><code>var tasks = Task.models({\n  count : 1500,\n  data : [{id: 1, name: 'dishes'}, ...]\n})\ntasks.attr(\"name\") // -&gt; 'dishes'\ntasks.count // -&gt; 1500\n</code></pre>\n\n<h3>Overwriting Models</h3>\n\n<p>If your service returns data like:</p>\n\n<pre><code>{thingsToDo: [{name: \"dishes\", id: 5}]}\n</code></pre>\n\n<p>You will want to overwrite models to pass the base models what it expects like:</p>\n\n<pre><code>Task = can.Model({\n  models : function(data){\n    return can.Model.models.call(this,data.thingsToDo);\n  }\n},{})\n</code></pre>\n\n<p><code>can.Model.models</code> passes each intstance's data to <code>can.Model.model</code> to\ncreate the individual instances.</p>",
                            "description": "<p>Convert raw data into can.Model instances. </p>",
                            "title": "models",
                            "signatures": [{
                                    "code": "models(data[, oldList])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Array",
                                                    "template": [{
                                                            "types": [{
                                                                    "type": "Object"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "name": "data",
                                            "description": "<p>The raw data from a <code>[can.Model.findAll findAll()]</code> request.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "can.Model.List"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "oldList",
                                            "description": "<p>If supplied, this List will be updated with the data from\n<strong>data</strong>.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model.List"
                                            }
                                        ],
                                        "description": "<p>A List of Models made from the raw data.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 650,
                            "id": 61
                        }, {
                            "active": false,
                            "body": "<p><code>unbind(eventType, handler)</code> removes a listener\nattached with [can.Model.bind].</p>\n\n<pre><code>var handler = function(ev, createdTask){\n\n}\nTask.bind(\"created\", handler)\nTask.unbind(\"created\", handler)\n</code></pre>\n\n<p>You have to pass the same function to <code>unbind</code> that you\npassed to <code>bind</code>.</p>",
                            "description": "<p>Stop listening for events on a Model class. </p>",
                            "title": "unbind",
                            "name": "can.Model.static.unbind",
                            "type": "function",
                            "parent": "can.Model.static",
                            "signatures": [{
                                    "code": "unbind(eventType, handler)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventType",
                                            "description": "<p>The type of event. It must be\n<code>\"created\"</code>, <code>\"udpated\"</code>, <code>\"destroyed\"</code>.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "handler",
                                            "description": "<p>A callback function\nthat was passed to <code>bind</code>.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Model"
                                            }
                                        ],
                                        "description": "<p>The model constructor function.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 148,
                            "id": 54
                        }, {
                            "active": false,
                            "name": "can.Model.static.update",
                            "type": "function",
                            "parent": "can.Model.static",
                            "body": "<p><code>update( id, attrs ) -&gt; Deferred</code> is used by [can.Model::save save] to \nupdate a model instance on the server. </p>\n\n<h2>Implement with a URL</h2>\n\n<p>The easist way to implement update is to just give it the url to <code>PUT</code> data to:</p>\n\n<pre><code>Recipe = can.Model({\n  update: \"/recipes/{id}\"\n},{});\n</code></pre>\n\n<p>This lets you update a recipe like:</p>\n\n<pre><code>Recipe.findOne({id: 1}, function(recipe){\n  recipe.attr('name','salad');\n  recipe.save();\n})\n</code></pre>\n\n<p>This will make an XHR request like:</p>\n\n<pre><code>PUT /recipes/1 \nname=salad\n</code></pre>\n\n<p>If your server doesn't use PUT, you can change it to post like:</p>\n\n<pre><code>$.Model(\"Recipe\",{\n  update: \"POST /recipes/{id}\"\n},{});\n</code></pre>\n\n<p>The server should send back an object with any new attributes the model \nshould have.  For example if your server udpates the \"updatedAt\" property, it\nshould send back something like:</p>\n\n<pre><code>// PUT /recipes/4 {name: \"Food\"} -&gt;\n{\n  updatedAt : \"10-20-2011\"\n}\n</code></pre>\n\n<h2>Implement with a Function</h2>\n\n<p>You can also implement update by yourself.  Update takes the <code>id</code> and\n<code>attributes</code> of the instance to be udpated.  Update must return\na [can.Deferred Deferred] that resolves to an object that contains any \nproperties that should be set on the instance.</p>\n\n<p>For example, the following code makes a request \nto '/recipes/5.json?name=hot+dog' and gets back\nsomething that looks like:</p>\n\n<pre><code>{ \n  updatedAt: \"10-20-2011\"\n}\n</code></pre>\n\n<p>The code looks like:</p>\n\n<pre><code>Recipe = can.Model({\n  update : function(id, attrs ) {\n    return $.post(\"/recipes/\"+id+\".json\",attrs, null,\"json\");\n  }\n},{});\n</code></pre>",
                            "description": "<p>Update a resource on the server. </p>",
                            "title": "update",
                            "signatures": [{
                                    "code": "[METHOD] /path/to/resource",
                                    "description": "<p>If you provide a URL, the Model will send a request to that URL using\nthe method specified (or PUT if none is specified) when updating an\ninstance on the server. (See below for more details.)</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the updated model.</p>"
                                    }
                                }, {
                                    "code": "function(id, serialized)",
                                    "description": "<p>If you provide a function, the Model will expect you to do your own AJAX requests.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "id",
                                            "description": "<p>The ID of the model to update.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "name": "serialized",
                                            "description": "<p>The [can.Observe::serialize serialized] properties of\nthe model to update.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Deferred"
                                            }
                                        ],
                                        "description": "<p>A Deferred that resolves to the updated model.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/model/model.js",
                            "line": 271,
                            "id": 57
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "name": "can.Model.List",
            "type": "constructor",
            "parent": "canjs",
            "body": "",
            "description": "<p>Works exactly like [can.Observe.List] and has all of the same properties,\nevents, and functions as an observable list. The only difference is that \nwhen an item from the list is destroyed, it will automatically get removed\nfrom the list.</p>\n\n<h2>Creating a new Model List</h2>\n\n<p>To create a new model list, just use <code>new {model_name}.List(ARRAY)</code> like:</p>\n\n<pre><code>var todo1 = new Todo( { name: \"Do the dishes\" } ),\n    todo2 = new Todo( { name: \"Wash floors\" } )\nvar todos = new Todo.List( [todo1, todo2] );\n</code></pre>\n\n<h3>Model Lists in <code>can.Model</code></h3>\n\n<p>[can.Model.static.findAll can.Model.findAll] or [can.Model.models] will\nalmost always be used to return a <code>can.Model.List</code> object, even though it\nis possible to create new lists like below:</p>\n\n<pre><code>var todos = Todo.models([\n    new Todo( { name: \"Do the dishes\" } ),\n    new Todo( { name: \"Wash floors\" } )\n])\n\ntodos.constructor // -&gt; can.Model.List\n\n// the most correct way to get a can.Model.List\nTodo.findAll({}, function(todos) {\n    todos.constructor // -&gt; can.Model.List\n})\n</code></pre>\n\n<h3>Extending <code>can.Model.List</code></h3>\n\n<p>Creating custom <code>can.Model.Lists</code> allows you to extend lists with helper\nfunctions for a list of a specific type. So, if you wanted to be able to\nsee how many todos were completed and remaining something could be written\nlike:</p>\n\n<pre><code>Todo.List = can.Model.List({\n    completed: function() {\n        var completed = 0;\n        this.each(function(i, todo) {\n            completed += todo.attr('complete') ? 1 : 0\n        })\n        return completed;\n    },\n    remaining: function() {\n        return this.attr('length') - this.completed();\n    }\n})\n\nTodo.findAll({}, function(todos) {\n    todos.completed() // -&gt; 0\n    todos.remaining() // -&gt; 2\n});\n</code></pre>\n\n<h2>Removing models from model list</h2>\n\n<p>The advantage that <code>can.Model.List</code> has over a traditional <code>can.Observe.List</code>\nis that when you destroy a model, if it is in that list, it will automatically\nbe removed from the list. </p>\n\n<pre><code>// Listen for when something is removed from the todos list.\ntodos.bind(\"remove\", function( ev, oldVals, indx ) {\n    console.log(oldVals[indx].attr(\"name\") + \" removed\")\n})\n\ntodo1.destroy(); // console shows \"Do the dishes removed\"\n</code></pre>",
            "title": "",
            "inherits": "can.Observe.List",
            "download": "can/model",
            "test": "can/model/qunit.html",
            "src": "can/model/model.js",
            "line": 1185,
            "id": 72
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.Observe",
            "body": "<h2>Working with Observes</h2>\n\n<p>To create an Observe, use <code>new can.Observe([props])</code>. This will return a\ncopy of <code>props</code> that emits events when its properties are changed with\n<code>[can.Observe.prototype.attr attr]</code>.</p>\n\n<p>You can read the values of properties on Observes directly, but you should\nnever set them directly. You can also read property values using <code>attr</code>.\nUsually, you will want to do this when creating a <code>[can.compute]</code> or when\nlive-binding properties in an [can.EJS EJS] template. (If you are using\n[can.Mustache Mustache], you don't need to use <code>attr</code>.)</p>\n\n<pre><code class=\"lang-javascript\">var aName = {a: 'Alexis'},\n    observe = can.Observe(aName);\n\n// Observes are copies of data:\naName === observe; // false\n\n// reading from an Observe:\nobserve.attr();    // {a: 'Alexis'}\nobserve.a;         // 'Alexis'\nobserve.attr('a'); // 'Alexis'\n\n// setting an Observe's property:\nobserve.attr('a, 'Alice');\nobserve.a; // Alice\n\n// removing an Observe's property;\nobserve.removeAttr('a');\nobserve.attr(); // {}\n\n// Don't do this!\nobserve.a = 'Adam'; // wrong!</code></pre>\n\n<p>Find out more about manipulating properties of Observes under\n[can.Observe.protoype.attr attr] and [can.Observe.protoype.removeAtt removeAttr].</p>\n\n<h2>Listening to changes</h2>\n\n<p>The real power of observable objects comes from being able to react to\nproperties being added, set, and removed. Observes emit events when\nproperties are changed that you can bind to.</p>\n\n<p><code>can.Observe</code> has two types of events that fire due to changes on an Observe:\n- the <em>change</em> event fires on every change to an Observe.\n- an event named after the property name fires on every change to that property.</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('change', function(ev, attr, how, newVal, oldVal) {\n    console.log('Something on o changed.');\n});\no.bind('a', function(ev, newVal, oldVal) {\n    console.log('a was changed.');\n});\n\no.attr('a', 'Alexis'); // 'Something on o changed.'\n                       // 'a was changed.'\no.attr({\n    'a': 'Alice',      // 'Something on o changed.' (for a's change)\n    'b': 'Bob'         // 'Something on o changed.' (for b's change)\n});                    // 'a was changed.'\n\no.removeAttr('a');     // 'Something on o changed.'\n                       // 'a was changed.'</code></pre>\n\n<p>For more detail on how to use these events, see [can.Observe.prototype.bind bind] and\n[can.Observe.prototype.unbind unbind]. There is also a plugin called [can.Observe.delegate]\nthat makes binding to specific types of events easier:</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.delegate('a', 'add' function(ev, newVal, oldVal) {\n    console.log('a was added.');\n});\no.delegate('a', 'set' function(ev, newVal, oldVal) {\n    console.log('a was set.');\n});\no.delegate('a', 'remove' function(ev, newVal, oldVal) {\n    console.log('a was removed.');\n});\no.delegate('a', 'change' function(ev, newVal, oldVal) {\n    console.log('a was changed.');\n});\n\no.attr('a', 'Alexis'); // 'a was added.'\n                       // 'a was changed.'\n\no.attr('a', 'Alice'); // 'a was set.'\n                      // 'a was changed.'\n\n\no.removeAttr('a'); // 'a was removed.'\n                   // 'a was changed.'</code></pre>",
            "description": "<p><code>can.Observe</code> provides a way for you to listen for and keep track of changes\nto objects. When you use the getters and setters provided by <code>can.Observe</code>,\nevents are fired that you can react to. <code>can.Observe</code> also has support for\nworking with deep properties. Observable arrays are also available with\n<code>[can.Observe.List]</code>, which is based on <code>can.Observe</code>.</p>",
            "inherits": "can.Construct",
            "parent": "canjs",
            "test": "can/observe/qunit.html",
            "download": "can/observe",
            "signatures": [{
                    "code": "can.Observe([props])",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "props",
                            "description": "<p>properties and values to seed the Observe with</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.Observe"
                            }
                        ],
                        "description": "<p>an instance of <code>can.Observe</code> with the properties from <em>props</em></p>"
                    }
                }
            ],
            "comment": " ",
            "src": "can/observe/observe.md",
            "id": 13,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Observe.prototype",
                    "parent": "can.Observe",
                    "src": "can/observe/observe.js",
                    "line": 347,
                    "id": 20,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype._attrs",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "props",
                                    "description": ""
                                }, {
                                    "types": [{
                                            "type": "Boolean"
                                        }
                                    ],
                                    "name": "remove",
                                    "description": "<p>true if you should remove properties that are not in props</p>"
                                }
                            ],
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Set multiple properties on the observable</p>",
                            "hide": true,
                            "src": "can/observe/observe.js",
                            "line": 876,
                            "id": 28
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.attr",
                            "parent": "can.Observe.prototype",
                            "body": "<p><code>attr</code> gets or sets properties on the <code>can.Observe</code> it's called on. Here's a tour through\nhow all of its forms work:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({});\n\n// set a property:\npeople.attr('a', 'Alex');\n\n// get a property:\npeople.attr('a'); // 'Alex'\n\n// set and merge multiple properties:\npeople.attr({\n    a: 'Alice',\n    b: 'Bob'\n});\n\n// get all properties:\npeople.attr(); // {a: 'Alice', b: 'Bob'}\n\n// set properties while removing others:\npeople.attr({\n    b: 'Bill',\n    e: 'Eve'\n}, true);\n\npeople.attr(); // {b: 'Bill', e: 'Eve'}</code></pre>\n\n<h2>Deep properties</h2>\n\n<p><code>attr</code> can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using <code>attr</code>.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({names: {}});\n\n// set a property:\npeople.attr('names.a', 'Alice');\n\n// get a property:\npeople.attr('names.a'); // 'Alice'\npeople.names.attr('a'); // 'Alice'\n\n// get all properties:\npeople.attr(); // {names: {a: 'Alice'}}</code></pre>\n\n<p>Objects that are added to Observes become Observes themselves behind the scenes,\nso changes to deep properties fire events at each level, and you can bind at any\nlevel. As this example shows, all the same events are fired no matter what level\nyou call <code>attr</code> at:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({names: {}});\n\npeople.bind('change', function(ev, attr, how, newVal, oldVal) {\n  console.log('people change: ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\npeople.names.bind('change', function(ev, attr, how, newVal, oldVal) {\n   console.log('people.names change' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\npeople.bind('names', function(ev, newVal, oldVal) {\n    console.log('people names: ' + newVal + ', ' + oldVal);\n});\n\npeople.names.bind('a', function(ev, newVal, oldVal) {\n    console.log('people.names a: ' + newVal + ', ' + oldVal);\n});\n\npeople.bind('names.a', function(ev, newVal, oldVal) {\n    console.log('people names.a: ' + newVal + ', ' + oldVal);\n});\n\npeople.attr('names.a', 'Alice'); // people change: names.a, add, Alice, undefined\n                                 // people.names change: a, add, Alice, undefined\n                                 // people.names a: Alice, undefined\n                                 // people names.a: Alice, undefined\n\npeople.names.attr('b', 'Bob');   // people change: names.b, add, Bob, undefined\n                                 // people.names change: b, add, Bob, undefined\n                                 // people.names b: Bob, undefined\n                                 // people names.b: Bob, undefined</code></pre>\n\n<h2>See also</h2>\n\n<p>For information on the events that are fired on property changes and how\nto listen for those events, see [can.Observe.prototype.bind bind].</p>",
                            "description": "<p>Get or set properties on an Observe. </p>",
                            "title": "attr",
                            "signatures": [{
                                    "code": "attr()",
                                    "description": "<p>Gets a collection of all the properties in this <code>can.Observe</code>.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Object",
                                                "template": [{
                                                        "types": [{
                                                                "type": "String"
                                                            }
                                                        ]
                                                    }, {
                                                        "types": [{
                                                                "type": "*"
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }
                                        ],
                                        "description": "<p>an object with all the properties in this <code>can.Observe</code>.</p>"
                                    }
                                }, {
                                    "code": "attr(key)",
                                    "description": "<p>Reads a property from this <code>can.Observe</code>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "key",
                                            "description": "<p>the property to read</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the value assigned to <em>key</em>.</p>"
                                    }
                                }, {
                                    "code": "attr(key, value)",
                                    "description": "<p>Assigns <em>value</em> to a property on this <code>can.Observe</code> called <em>key</em>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "key",
                                            "description": "<p>the property to set</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "the",
                                            "description": "<p>value to assign to <em>key</em>.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe"
                                            }
                                        ],
                                        "description": "<p>this Observe, for chaining</p>"
                                    }
                                }, {
                                    "code": "attr(obj[, removeOthers])",
                                    "description": "<p>Assigns each value in <em>obj</em> to a property on this <code>can.Observe</code> named after the\ncorresponding key in <em>obj</em>, effectively merging <em>obj</em> into the Observe.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Object",
                                                    "template": [{
                                                            "types": [{
                                                                    "type": "String"
                                                                }
                                                            ]
                                                        }, {
                                                            "types": [{
                                                                    "type": "*"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "name": "obj",
                                            "description": "<p>a collection of key-value pairs to set.\nIf any properties already exist on the <code>can.Observe</code>, they will be overwritten.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "bool"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "removeOthers",
                                            "defaultValue": "false",
                                            "description": "<p>whether to remove keys not present in <em>obj</em>.\nTo remove keys without setting other keys, use <code>[can.Observe::removeAttr|removeAttr]</code>.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe"
                                            }
                                        ],
                                        "description": "<p>this Observe, for chaining</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 374,
                            "id": 22
                        }, {
                            "active": false,
                            "name": "can.Observe.prototype.bind",
                            "type": "function",
                            "parent": "can.Observe.prototype",
                            "body": "<p><code>bind</code> binds event handlers to property changes on <code>can.Observe</code>s. When you change\na property using <code>attr</code>, two events are fired on the Observe, allowing other parts\nof your application to observe the changes to the object.</p>\n\n<h2>The <em>change</em> event</h2>\n\n<p>The first event that is fired is the <em>change</em> event. The <em>change</em> event is useful\nif you want to react to all changes on an Observe.</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('change', function(ev, attr, how, newVal, oldVal) {\n    console.log('Something changed.');\n});</code></pre>\n\n<p>The parameters of the event handler for the <em>change</em> event are:</p>",
                            "description": "<p>Bind event handlers to an Observe. </p>",
                            "title": "bind",
                            "signatures": [{
                                    "code": "bind(eventType, handler)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventType",
                                            "description": "<p>the type of event to bind this handler to</p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "handler",
                                            "description": "<p>the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "attr",
                                            "description": "<p>which property changed</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "how",
                                            "description": "<p>whether the property was added, removed, or set\nPossible values are <code>'add'</code>, <code>'remove'</code>, or <code>'set'</code>.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "newVal",
                                            "description": "<p>the value of the property after the change\n<code>newVal</code> will be <code>undefined</code> if the property was removed.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "oldVal",
                                            "description": "<p>the value of the property before the change\n<code>oldVal</code> will be <code>undefined</code> if the property was added.</p>\n\n<p>Here is a concrete tour through the <em>change</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('change', function(ev, attr, how, newVal, oldVal) {\n    console.log(ev + ', ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\no.attr('a', 'Alexis'); // [object Object], a, add, Alexis, undefined\no.attr('a', 'Adam');   // [object Object], a, set, Adam, Alexis\no.attr({\n    'a': 'Alice',      // [object Object], a, set, Alice, Adam\n    'b': 'Bob'         // [object Object], b, add, Bob, undefined\n});\no.removeAttr('a');     // [object Object], a, remove, undefined, Alice</code></pre>\n\n<p>(See also <code>[can.Observe::removeAttr|removeAttr]</code>, which removes properties).</p>\n\n<h2>The <em>property name</em> event</h2>\n\n<p>The second event that is fired is an event whose type is the same as the changed\nproperty's name. This event is useful for noticing changes to a specific property.</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('a', function(ev, newVal, oldVal) {\n    console.log('The value of a changed.');\n});</code></pre>\n\n<p>The parameters of the event handler for the <em>property name</em> event are:</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "newVal",
                                            "description": "<p>the value of the property after the change\n<code>newVal</code> will be <code>undefined</code> if the property was removed.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "oldVal",
                                            "description": "<p>the value of the property before the change\n<code>oldVal</code> will be <code>undefined</code> if the property was added.</p>\n\n<p>Here is a concrete tour through the <em>property name</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var o = new can.Observe({});\no.bind('a', function(ev, newVal, oldVal) {\n    console.log(ev + ', ' + newVal + ', ' + oldVal);\n});\n\no.attr('a', 'Alexis'); // [object Object], Alexis, undefined\no.attr('a', 'Adam');   // [object Object], Adam, Alexis\no.attr({\n    'a': 'Alice',      // [object Object], Alice, Adam\n    'b': 'Bob' \n});\no.removeAttr('a');     // [object Object], undefined, Alice</code></pre>\n\n<h2>See also</h2>\n\n<p>More information about changing properties on Observes can be found under\n[can.Observe.prototype.attr attr].</p>\n\n<p>For a more specific way to changes on Observes, see the [can.Observe.delegate] plugin.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe"
                                            }
                                        ],
                                        "description": "<p>this Observe, for chaining</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 715,
                            "id": 25
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.compute",
                            "parent": "can.Observe.prototype",
                            "body": "<p><code>compute</code> is a convenience method for making computes from properties\nof Observes. More information about computes can be found under [can.compute].</p>",
                            "description": "<p>Make a can.compute from an observable property. </p>",
                            "title": "compute",
                            "signatures": [{
                                    "code": "compute(attrName)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "attrName",
                                            "description": "<p>the property to bind to</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.compute"
                                            }
                                        ],
                                        "description": "<p>a [can.compute] bound to <em>attrName</em></p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 928,
                            "id": 29
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.each",
                            "parent": "can.Observe.prototype",
                            "body": "<pre><code class=\"lang-javascript\">var names = [];\nnew can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n    names.push(value);\n});\n\nnames; // ['Alice', 'Bob', 'Eve']\n\nnames = [];\nnew can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n    names.push(value);\n    if(key === 'b') {\n        return false;\n    }\n});\n\nnames; // ['Alice', 'Bob']\n</code></pre>     ",
                            "description": "<p>Call a function on each property of an Observe. </p>",
                            "title": "each",
                            "signatures": [{
                                    "code": "each(callback)",
                                    "description": "<p><code>each</code> iterates through the Observe, calling a function\nfor each property value and key.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "name": "callback",
                                            "description": "<p>the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe"
                                            }
                                        ],
                                        "description": "<p>this Observe, for chaining</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 521,
                            "id": 23
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.removeAttr",
                            "parent": "can.Observe.prototype",
                            "body": "<p><code>removeAttr</code> removes a property by name from an Observe.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({a: 'Alice', b: 'Bob', e: 'Eve'});\n\npeople.removeAttr('b'); // 'Bob'\npeople.attr();          // {a: 'Alice', e: 'Eve'}</code></pre>\n\n<p>Removing an attribute will cause a <em>change</em> event to fire with <code>'remove'</code>\npassed as the <em>how</em> parameter and <code>undefined</code> passed as the <em>newVal</em> to\nhandlers. It will also cause a <em>property name</em> event to fire with <code>undefined</code>\npassed as <em>newVal</em>. An in-depth description at these events can be found\nunder <code>[can.Observe.prototype.attr attr]</code>.</p>",
                            "description": "<p>Remove a property from an Observe. </p>",
                            "title": "removeAttr",
                            "signatures": [{
                                    "code": "removeAttr(attrName)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "attrName",
                                            "description": "<p>the name of the property to remove</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the value of the property that was removed</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 561,
                            "id": 24
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.prototype.serialize",
                            "params": [],
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Get the serialized Object form of the observe.  Serialized\ndata is typically used to send back to a server.</p>\n\n<pre><code>o.serialize() //-&gt; { name: 'Justin' }\n</code></pre>\n\n<p>Serialize currently returns the same data \nas [can.Observe.prototype.attrs].  However, in future\nversions, serialize will be able to return serialized\ndata similar to [can.Model].  The following will work:</p>\n\n<pre><code>new Observe({time: new Date()})\n  .serialize() //-&gt; { time: 1319666613663 }\n</code></pre>",
                            "hide": true,
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p>a JavaScript Object that can be \nserialized with <code>JSON.stringify</code> or other methods. </p>"
                            },
                            "src": "can/observe/observe.js",
                            "line": 854,
                            "id": 27
                        }, {
                            "active": false,
                            "name": "can.Observe.prototype.unbind",
                            "type": "function",
                            "parent": "can.Observe.prototype",
                            "body": "",
                            "description": "<p>Unbind event handlers from an Observe. </p>",
                            "title": "unbind",
                            "signatures": [{
                                    "code": "unbind(eventType[, handler])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "eventType",
                                            "description": "<p>the type of event to unbind, exactly as passed to <code>bind</code></p>"
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ],
                                            "optional": true,
                                            "name": "handler",
                                            "description": "<p>the handler to unbind</p>\n\n<p><code>unbind</code> unbinds event handlers previously bound with [can.Observe.prototype.bind|<code>bind</code>].\nIf no <em>handler</em> is passed, all handlers for the given event type will be unbound.</p>\n\n<pre><code class=\"lang-javascript\">var i = 0,\n    increaseBy2 = function() { i += 2; },\n    increaseBy3 = function() { i += 3; },\n    o = new can.Observe();\n\no.bind('change', increaseBy2);\no.bind('change', increaseBy3);\no.attr('a', 'Alice');\ni; // 5\n\no.unbind('change', increaseBy2);\no.attr('b', 'Bob');\ni; // 8\n\no.unbind('change');\no.attr('e', 'Eve');\ni; // 8</code></pre>"
                                        }
                                    ]
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 823,
                            "id": 26
                        }
                    ]
                }, {
                    "active": false,
                    "type": "static",
                    "body": "",
                    "description": "",
                    "name": "can.Observe.static",
                    "parent": "can.Observe",
                    "src": "can/observe/observe.js",
                    "line": 113,
                    "id": 15,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.static.keys",
                            "parent": "can.Observe.static",
                            "body": "<p><code>keys</code> iterates over an observe to get an array of its keys.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe({\n    a: 'Alice',\n    b: 'Bob',\n    e: 'Eve'\n});\n\ncan.Observe.keys(people); // ['a', 'b', 'e']</code></pre>     ",
                            "description": "<p>Iterate over the keys of an Observe. </p>",
                            "title": "keys",
                            "signatures": [{
                                    "code": "can.Observe.keys(observe)",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "can.Observe"
                                                }
                                            ],
                                            "name": "observe",
                                            "description": "<p>the <code>can.Observe</code> to get the keys from</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Array"
                                            }
                                        ],
                                        "description": "<p>array An array containing the keys from <em>observe</em>.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 318,
                            "id": 19
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.static.startBatch",
                            "params": [{
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": []
                                        }
                                    ],
                                    "optional": true,
                                    "name": "batchStopHandler",
                                    "description": "<p>a callback that gets called after all batched events have been called</p>\n\n<p><code>startBatch</code> causes can.Observe to begin an event batch. Until <code>[can.Observe.stopBatch]</code> is called, any\nevents that would result from calls to <code>[can.Observe::attr|attr]</code> are held back from firing. If you have\nlots of changes to make to can.Observes, batching them together can help performance &emdash; especially if\nthose can.Observes are live-bound to the DOM.</p>\n\n<p>In this example, you can see how the <em>first</em> and <em>change</em> events are not fired (and their handlers\nare not called) until <code>stopBatch</code> is called.</p>\n\n<pre><code class=\"lang-javascript\">var person = new can.Observe({\n    first: 'Alexis',\n    last: 'Abril'\n});\n\nperson.bind('first', function() {\n    console.log(\"First name changed.\"\");\n}).bind('change', function() {\n    console.log(\"Something changed.\");\n});\n\ncan.Observe.startBatch();\nperson.attr('first', 'Alex');\nconsole.log('Still in the batch.');\ncan.Observe.stopBatch();\n\n// the log has:\n// Still in the batch.\n// First name changed.\n// Something changed.</code></pre>\n\n<p>You can also pass a callback to <code>startBatch</code> which will be called after all the events have\nbeen fired:</p>\n\n<pre><code class=\"lang-javascript\">can.Observe.startBatch(function() {\n    console.log('The batch is over.');\n});\nperson.attr('first', 'Izzy');\nconsole.log('Still in the batch.');\ncan.Observe.stopBatch();\n\n// The console has:\n// Still in the batch.\n// First name changed.\n// Something changed.\n// The batch is over.</code></pre>\n\n<h2>Calling <code>startBatch</code> multiple times</h2>\n\n<p>If you call <code>startBatch</code> more than once, <code>stopBatch</code> needs to be called\nthe same number of times before any batched events will fire. For ways\nto circumvent this process, see [can.Observe.stopBatch].</p>\n\n<p>Here is an example that demonstrates how events are affected by calling\n<code>startBatch</code> multiple times.</p>\n\n<pre><code class=\"lang-javascript\">var addPeople = function(observable) {\n    can.Observe.startBatch();\n    observable.attr('a', 'Alice');\n    observable.attr('b', 'Bob');\n    observable.attr('e', 'Eve');\n    can.Observe.stopBatch();\n};\n\n// In a completely different place:\nvar list = new can.Observe();\nlist.bind('change', function() {\n    console.log('The list changed.');\n});\n\ncan.Observe.startBatch();\naddPeople(list);\nconsole.log('Still in the batch.');\n\n// Here, the console has:\n// Still in the batch.\n\ncan.Observe.stopBatch();\n\n// Here, the console has:\n// Still in the batch.\n// The list changed.\n// The list changed.\n// The list changed.</code></pre>"
                                }
                            ],
                            "parent": "can.Observe.static",
                            "body": "",
                            "description": "<p>Begin an event batch. </p>",
                            "title": "startBatch",
                            "src": "can/observe/observe.js",
                            "line": 124,
                            "id": 16
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.static.stopBatch",
                            "params": [{
                                    "types": [{
                                            "type": "bool"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "force",
                                    "defaultValue": "false",
                                    "description": "<p>whether to stop batching events immediately</p>"
                                }, {
                                    "types": [{
                                            "type": "bool"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "callStart",
                                    "defaultValue": "false",
                                    "description": "<p>whether to call <code>[can.Observe.startBatch startBatch]</code> after firing batched events</p>\n\n<p><code>stopBatch</code> matches an earlier <code>[can.Observe.startBatch]</code> call. If <code>stopBatch</code> has been\ncalled as many times as <code>startBatch</code> (or if <em>force</em> is true), all batched events will be\nfired and any callbacks passed to <code>startBatch</code> since the beginning of the batch will be\ncalled. If <em>force and _callStart</em> are both true, a new batch will be started when all\nthe events and callbacks have been fired.</p>\n\n<p>See <code>[can.Observe.startBatch]</code> for examples of <code>startBatch</code> and <code>stopBatch</code> in normal use.</p>\n\n<p>In this example, the batch is forceably ended in the <code>addPeople</code> function.</p>\n\n<pre><code class=\"lang-javascript\">var addPeople = function(observable) {\n    can.Observe.startBatch();\n    observable.attr('a', 'Alice');\n    observable.attr('b', 'Bob');\n    observable.attr('e', 'Eve');\n    can.Observe.stopBatch(true);\n};\n\n// In a completely different place:\nvar list = new can.Observe();\nlist.bind('change', function() {\n    console.log('The list changed.');\n});\n\ncan.Observe.startBatch();\naddPeople(list);\nconsole.log('Still in the batch.');\n\n// Here, the console has:\n// Still in the batch.\n\ncan.Observe.stopBatch();\n\n// Here, the console has:\n// The list changed.\n// The list changed.\n// The list changed.\n// Still in the batch.</code></pre>"
                                }
                            ],
                            "parent": "can.Observe.static",
                            "body": "",
                            "description": "<p>End an event batch. </p>",
                            "title": "stopBatch",
                            "src": "can/observe/observe.js",
                            "line": 221,
                            "id": 17
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.static.triggerBatch",
                            "parent": "can.Observe.static",
                            "body": "",
                            "description": "<p>Trigger an event to be added to the current batch. </p>",
                            "title": "triggerBatch",
                            "signatures": [{
                                    "code": "can.Observe.triggerBatch(item, event [, args])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "can.Observe"
                                                }
                                            ],
                                            "name": "item",
                                            "description": "<p>the target of the event</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }, {
                                                    "type": "Object",
                                                    "options": [{
                                                            "name": "type",
                                                            "types": [{
                                                                    "type": "String"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "name": "event",
                                            "description": "<p>the type of event, or an event object with a type given</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Array"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "args",
                                            "description": "<p>the parameters to trigger the event with.</p>\n\n<p>If events are currently being batched, calling <code>triggerBatch</code> adds an event\nto the batch. If events are not currently being batched, the event is triggered\nimmediately.</p>"
                                        }
                                    ]
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 289,
                            "id": 18
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "name": "can.Observe.List",
            "type": "constructor",
            "parent": "canjs",
            "body": "<h2>Working with Lists</h2>\n\n<p><code>can.Observe.List</code> extends <code>[can.Observe]</code>, so all the ways that you're used to working with\nObserves also work here, including [can.Observe.prototype.bind bind], [can.Observe.prototype.unbind unbind],\nand [can.Observe.prototype.each each]. And just as you can directly read properties normally\noff of an Observe, you can use array accessors ([]) to read elements directly off of a List.</p>\n\n<p>The one function of <code>can.Observe</code> that works slightly differently is <code>attr</code>. As expected when working with\narrays, top-level keys passed into <code>attr</code> are required to be numeric. (Strings may still be used when getting\nor modifying deep properties). Any top-level keys that are non-numeric are ignored. In addition, as might be\nexpected, a call to argument-less <code>attr</code> returns an array instead of an object.</p>\n\n<p>Just as you shouldn't set properties of an Observe directly, you shouldn't change elements\nof a List directly. Always use <code>attr</code> to set the elements of a List, or use [can.Observe.List.push push],\n[can.Observe.List.pop pop], [can.Observe.List.shift shift], [can.Observe.List.unshift unshift], or [can.Observe.List.splice splice].</p>\n\n<p>Here is a tour through the forms of <code>can.Observe.List</code>'s <code>attr</code> that parallels the one found under [can.Observe.prototype.attr attr]:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe.List(['Alex', 'Bill']);\n\n// set an element:\npeople.attr(0, 'Adam');\npeople[0] = 'Adam'; // don't do this!\n\n// get an element:\npeople.attr(0); // 'Adam'\npeople[0]; // 'Adam'\n\n// get all elements:\npeople.attr(); // ['Adam', 'Bill']\n\n// extend the array:\npeople.attr(4, 'Charlie');\npeople.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n// merge the elements:\npeople.attr(['Alice', 'Bob', 'Eve']);\npeople.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']</code></pre>\n\n<h2>Listening to changes</h2>\n\n<p>As with <code>can.Observe</code>s, the real power of observable arrays comes from being able to\nreact to changes in the member elements of the array. Lists emit five types of events:\n- the <em>change</em> event fires on every change to a List.\n- the <em>set</em> event is fired when an element is set.\n- the <em>add</em> event is fired when an element is added to the List.\n- the <em>remove</em> event is fired when an element is removed from the List.\n- the <em>length</em> event is fired when the length of the List changes.</p>\n\n<p>This example presents a brief concrete survey of the times these events are fired:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\n\nlist.bind('change', function() { console.log('An element changed.'); });\nlist.bind('set', function() { console.log('An element was set.'); });\nlist.bind('add', function() { console.log('An element was added.'); });\nlist.bind('remove', function() { console.log('An element was removed.'); });\nlist.bind('length', function() { console.log('The length of the list changed.'); });\n\nlist.attr(0, 'Alexis'); // 'An element changed.'\n                        // 'An element was set.'\n\nlist.attr(3, 'Xerxes'); // 'An element changed.'\n                        // 'An element was added.'\n                        // 'The length of the list was changed.'\n\nlist.attr(['Adam', 'Bill']); // 'An element changed.'\n                             // 'An element was set.'\n                             // 'An element was changed.'\n                             // 'An element was set.'\n\nlist.pop(); // 'An element changed.'\n            // 'An element was removed.'\n            // 'The length of the list was changed.'</code></pre>\n\n<p>More information about binding to these events can be found under [can.Observe.List.attr attr].</p>",
            "description": "<p><code>can.Observe.List</code> provides a way for you to use <code>can.Observe</code>s with arrays. Much like <code>can.Observe</code>,\nwhen you use the getters and setters on <code>can.Observe.List</code>, events are fired that you can listen for\nand react to.</p>",
            "inherits": "can.Observe",
            "download": "can/observe",
            "test": "can/observe/qunit.html",
            "signatures": [{
                    "code": "can.Observe.List([elements])",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "Array"
                                }
                            ],
                            "optional": true,
                            "name": "elements",
                            "description": "<p>elements to seed the List with</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.Observe.List"
                            }
                        ],
                        "description": "<p>an instance of <code>can.Observe.List</code> with the elements from <em>elements</em></p>"
                    }
                }
            ],
            "comment": " ",
            "src": "can/observe/observe.js",
            "line": 965,
            "id": 30,
            "children": [{
                    "active": false,
                    "type": "prototype",
                    "body": "",
                    "description": "",
                    "name": "can.Observe.List.prototype",
                    "parent": "can.Observe.List",
                    "src": "can/observe/observe.js",
                    "line": 1065,
                    "id": 31,
                    "children": [{
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.attr",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>attr</code> gets or sets elements on the <code>can.Observe.List</code> it's called on. Here's a tour through\nhow all of its forms work:</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe.List(['Alex', 'Bill']);\n\n// set an element:\npeople.attr(0, 'Adam');\n\n// get an element:\npeople.attr(0); // 'Adam'\npeople[0]; // 'Adam'\n\n// get all elements:\npeople.attr(); // ['Adam', 'Bill']\n\n// extend the array:\npeople.attr(4, 'Charlie');\npeople.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n// merge the elements:\npeople.attr(['Alice', 'Bob', 'Eve']);\npeople.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']</code></pre>\n\n<h2>Deep properties</h2>\n\n<p><code>attr</code> can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using <code>attr</code>.</p>\n\n<pre><code class=\"lang-javascript\">var people = new can.Observe.List([{name: 'Alex'}, {name: 'Bob'}]);\n\n// set a property:\npeople.attr('0.name', 'Alice');\n\n// get a property:\npeople.attr('0.name');  // 'Alice'\npeople[0].attr('name'); // 'Alice'\n\n// get all properties:\npeople.attr(); // [{name: 'Alice'}, {name: 'Bob'}]</code></pre>\n\n<p>The discussion of deep properties under <code>[can.Observe.prototype.attr]</code> may also\nbe enlightening.</p>\n\n<h2>Events</h2>\n\n<p><code>can.Observe.List</code>s emit five types of events in response to changes. They are:\n- the <em>change</em> event fires on every change to a List.\n- the <em>set</em> event is fired when an element is set.\n- the <em>add</em> event is fired when an element is added to the List.\n- the <em>remove</em> event is fired when an element is removed from the List.\n- the <em>length</em> event is fired when the length of the List changes.</p>\n\n<ul>\n<li>## The <em>change</em> event</li>\n</ul>\n\n<p>The first event that is fired is the <em>change</em> event. The <em>change</em> event is useful\nif you want to react to all changes on an List.</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List([]);\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log('Something changed.');\n});</code></pre>\n\n<p>The parameters of the event handler for the <em>change</em> event are:</p>",
                            "description": "<p>Get or set elements in a List. </p>",
                            "title": "attr",
                            "signatures": [{
                                    "code": "attr()",
                                    "description": "<p>Gets a collection of all the elements in this <code>can.Observe.List</code>.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "Array"
                                            }
                                        ],
                                        "description": "<p>array with all the elements in this List.</p>"
                                    }
                                }, {
                                    "code": "attr(index)",
                                    "description": "<p>Reads a element from this <code>can.Observe.List</code>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>the element to read</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the value at <em>index</em>.</p>"
                                    }
                                }, {
                                    "code": "attr(index, value)",
                                    "description": "<p>Assigns <em>value</em> to the index <em>index</em> on this <code>can.Observe.List</code>, expanding the list if necessary.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>the element to set</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "the",
                                            "description": "<p>value to assign at <em>index</em></p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe.List"
                                            }
                                        ],
                                        "description": "<p>this List, for chaining</p>"
                                    }
                                }, {
                                    "code": "attr(elements[, replaceCompletely])",
                                    "description": "<p>Merges the members of <em>elements</em> into this List, replacing each from the beginning in order. If\n<em>elements</em> is longer than the current List, the current List will be expanded. If <em>elements</em>\nis shorter than the current List, the extra existing members are not affected (unless\n<em>replaceCompletely</em> is <code>true</code>). To remove elements without replacing them, use <code>[can.Observe.List.prototype.removeAttr removeAttr]</code>.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Array"
                                                }
                                            ],
                                            "name": "elements",
                                            "description": "<p>an array of elements to merge in</p>"
                                        }, {
                                            "types": [{
                                                    "type": "bool"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "replaceCompletely",
                                            "defaultValue": "false",
                                            "description": "<p>whether to completely replace the elements of List\nIf <em>replaceCompletely</em> is <code>true</code> and <em>elements</em> is shorter than the List, the existing\nextra members of the List will be removed.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Index"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>where the change took place</p>"
                                        }, {
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "how",
                                            "description": "<p>whether elements were added, removed, or set\nPossible values are <code>'add'</code>, <code>'remove'</code>, or <code>'set'</code>.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }, {
                                                    "type": "Array"
                                                }, {
                                                    "type": "undefined"
                                                }
                                            ],
                                            "name": "newVal",
                                            "description": "<p>the elements affected after the change\n<em>newVal</em> will be a single value when an index is set, an Array when elements\nwere added, and <code>undefined</code> if elements were removed.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }, {
                                                    "type": "Array"
                                                }, {
                                                    "type": "undefined"
                                                }
                                            ],
                                            "name": "oldVal",
                                            "description": "<p>the elements affected before the change\n<em>newVal</em> will be a single value when an index is set, an Array when elements\nwere removed, and <code>undefined</code> if elements were added.</p>\n\n<p>Here is a concrete tour through the <em>change</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log(ev + ', ' + index + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\nlist.attr(['Alexis', 'Bill']); // [object Object], 0, add, ['Alexis', 'Bill'], undefined\nlist.attr(2, 'Eve');           // [object Object], 2, add, Eve, undefined\nlist.attr(0, 'Adam');          // [object Object], 0, set, Adam, Alexis\nlist.attr(['Alice', 'Bob']);   // [object Object], 0, set, Alice, Adam\n                               // [object Object], 1, set, Bob, Bill\nlist.removeAttr(1);            // [object Object], 1, remove, undefined, Bob</code></pre>\n\n<h2>The <em>set</em> event</h2>\n\n<p><em>set</em> events are fired when an element at an index that already exists in the List is\nmodified. Actions can cause <em>set</em> events to fire never also cause <em>length</em> events\nto fire (although some functions, such as <code>[can.Observe.List.prototype.splice splice]</code>\nmay cause unrelated sets of events to fire after being batched).</p>\n\n<p>The parameters of the event handler for the <em>set</em> event are:</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "newVal",
                                            "description": "<p>the new value of the element</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Index"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>where the set took place</p>\n\n<p>Here is a concrete tour through the <em>set</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nlist.bind('set', function(ev, newVal, index) {\n    console.log(newVal + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');          \nlist.attr(0, 'Adam');          // Adam, 0\nlist.attr(['Alice', 'Bob']);   // Alice, 0\n                               // Bob, 1\nlist.removeAttr(1);            </code></pre>\n\n<h2>The <em>add</em> event</h2>\n\n<p><em>add</em> events are fired when elements are added or inserted\ninto the List.</p>\n\n<p>The parameters of the event handler for the <em>add</em> event are:</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Array"
                                                }, {
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "newElements",
                                            "description": "<p>the new elements\nIf more than one element is added, <em>newElements</em> will be an array.\nOtherwise, it is simply the new element itself.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Index"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>where the add or insert took place</p>\n\n<p>Here is a concrete tour through the <em>add</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nlist.bind('add', function(ev, newElements, index) {\n    console.log(newElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']); // ['Alexis', 'Bill'], 0\nlist.attr(2, 'Eve');           // Eve, 2\nlist.attr(0, 'Adam');          \nlist.attr(['Alice', 'Bob']);   \n\nlist.removeAttr(1);            </code></pre>\n\n<h2>The <em>remove</em> event</h2>\n\n<p><em>remove</em> events are fired when elements are removed from the list.</p>\n\n<p>The parameters of the event handler for the <em>remove</em> event are:</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Array"
                                                }, {
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "removedElements",
                                            "description": "<p>the removed elements\nIf more than one element was removed, <em>removedElements</em> will be an array.\nOtherwise, it is simply the element itself.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Index"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>where the removal took place</p>\n\n<p>Here is a concrete tour through the <em>remove</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nlist.bind('remove', function(ev, removedElements, index) {\n    console.log(removedElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']); \nlist.attr(2, 'Eve');           \nlist.attr(0, 'Adam');          \nlist.attr(['Alice', 'Bob']);   \n\nlist.removeAttr(1);            // Bob, 1</code></pre>\n\n<h2>The <em>length</em> event</h2>\n\n<p><em>length</em> events are fired whenever the list changes.</p>\n\n<p>The parameters of the event handler for the <em>length</em> event are:</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Event"
                                                }
                                            ],
                                            "name": "ev",
                                            "description": "<p>the event object</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "name": "length",
                                            "description": "<p>the current length of the list\nIf events were batched when the <em>length</em> event was triggered, <em>length</em>\nwill have the length of the list when <code>stopBatch</code> was called. Because\nof this, you may recieve multiple <em>length</em> events with the same\n<em>length</em> parameter.</p>\n\n<p>Here is a concrete tour through the <em>length</em> event handler's arguments:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nlist.bind('length', function(ev, length) {\n    console.log(length);\n});\n\nlist.attr(['Alexis', 'Bill']); // 2\nlist.attr(2, 'Eve');           // 3\nlist.attr(0, 'Adam');          \nlist.attr(['Alice', 'Bob']);   \n\nlist.removeAttr(1);            // 2</code></pre>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe.List"
                                            }
                                        ],
                                        "description": "<p>this List, for chaining</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1243,
                            "id": 35
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.concat",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Merge many collections together into a List. </p>",
                            "title": "concat",
                            "signatures": [{
                                    "code": "concat(...args)",
                                    "description": "<p><code>concat</code> makes a new List with the elements of the List followed by the elements of the parameters.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Array"
                                                }, {
                                                    "type": "can.Observe.List"
                                                }, {
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "args",
                                            "description": "<p>Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new can.Observe.List(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]</code></pre>"
                                        }
                                    ]
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1879,
                            "id": 44
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.forEach",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Call a function for each element of a List. </p>",
                            "title": "forEach",
                            "signatures": [{
                                    "code": "forEach(callback[, thisArg])",
                                    "description": "<p><code>forEach</code> calls a callback for each element in the List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": [{
                                                            "types": [{
                                                                    "type": "element"
                                                                }
                                                            ]
                                                        }, {
                                                            "types": [{
                                                                    "type": "index"
                                                                }
                                                            ]
                                                        }, {
                                                            "types": [{
                                                                    "type": "list"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ],
                                            "name": "callback",
                                            "description": "<p>a function to call with each element of the List\nThe three parameters that <em>callback</em> gets passed are <em>element</em>, the element at <em>index</em>, <em>index</em> the\ncurrent element of the list, and <em>list</em> the List the elements are coming from.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Object"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "thisArg",
                                            "description": "<p>the object to use as <code>this</code> inside the callback</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.attr(index, element * element);\n});\nlist.attr(); // [1, 4, 9]</code></pre>"
                                        }
                                    ]
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1909,
                            "id": 45
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.indexOf",
                            "parent": "can.Observe.List.prototype",
                            "body": "<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1</code></pre>\n\n<p>It is trivial to make a <code>contains</code>-type function using <code>indexOf</code>:</p>\n\n<pre><code class=\"lang-javascript\">function(list, item) {\n    return list.indexOf(item) >= 0;\n}</code></pre>     ",
                            "description": "<p>Look for an item in a List. </p>",
                            "title": "indexOf",
                            "signatures": [{
                                    "code": "indexOf(item)",
                                    "description": "<p><code>indexOf</code> finds the position of a given item in the List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "item",
                                            "description": "<p>the item to find</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>the position of the item in the List, or -1 if the item is not found.</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1769,
                            "id": 40
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.join",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n\nvar beatles = new can.Observe.List(['John', 'Paul', 'Ringo', 'George']);\nbeatles.join('&'); // 'John&Paul&Ringo&George'</code></pre>     ",
                            "description": "<p>Join a List's elements into a string. </p>",
                            "title": "join",
                            "signatures": [{
                                    "code": "join(separator)",
                                    "description": "<p><code>join</code> turns a List into a string by inserting <em>separator</em> between the string representations\nof all the elements of the List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ],
                                            "name": "separator",
                                            "description": "<p>the string to seperate elements with</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "String"
                                            }
                                        ],
                                        "description": "<p>the joined string</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1800,
                            "id": 41
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.pop",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>pop</code> is the opposite action from <code>[can.Observe.List.push push]</code>:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined</code></pre>\n\n<h2>Events</h2>\n\n<p><code>pop</code> causes <em>change</em>, <em>remove</em>, and <em>length</em> events to be fired if the List is not empty\nwhen it is called.</p>\n\n<h2>See also</h2>\n\n<p><code>pop</code> has its counterpart in [can.Observe.List.push push], or you may be\nlooking for [can.Observe.List.unshift unshift] and its counterpart [can.Observe.List.shift shift].</p>",
                            "description": "<p>Remove an element from the end of a List. </p>",
                            "title": "pop",
                            "signatures": [{
                                    "code": "pop()",
                                    "description": "<p><code>push</code> removes an element from the end of a List.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the element just popped off the List, or <code>undefined</code> if the List was empty</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1673,
                            "id": 38
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.push",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>push</code> is fairly straightforward:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']</code></pre>\n\n<p>If you have an array you want to concatenate to the end\nof the List, you can use <code>apply</code>:</p>\n\n<pre><code class=\"lang-javascript\">var names = ['Bob', 'Eve'],\n    list = new can.Observe.List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Alice', 'Bob', 'Eve']</code></pre>\n\n<h2>Events</h2>\n\n<p><code>push</code> causes <em>change</em>, <em>add</em>, and <em>length</em> events to be fired.</p>\n\n<h2>See also</h2>\n\n<p><code>push</code> has a counterpart in [can.Observe.List.pop pop], or you may be\nlooking for [can.Observe.List.unshift unshift] and its counterpart [can.Observe.List.shift shift].</p>",
                            "description": "<p>Add elements to the end of a list. </p>",
                            "title": "push",
                            "signatures": [{
                                    "code": "push(...elements)",
                                    "description": "<p><code>push</code> adds elements onto the end of a List.]</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "elements",
                                            "description": "<p>the elements to add to the List</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>the new length of the List</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1552,
                            "id": 36
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.replace",
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Replace all the elements of a List. </p>",
                            "title": "replace",
                            "signatures": [{
                                    "code": "replace(collection)",
                                    "description": "<p><code>replace</code> replaces all the elements of this List with new ones.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Array"
                                                }, {
                                                    "type": "can.Observe.List"
                                                }, {
                                                    "type": "can.Deferred"
                                                }
                                            ],
                                            "name": "collection",
                                            "description": "<p>the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an <code>Array</code> or <code>can.Observe.List</code>.\nThe elements of the list are not actually removed until the Deferred resolves.</p>\n\n<p><code>replace</code> is especially useful when <code>can.Observe.List</code>s are live-bound into <code>[can.Control]</code>s,\nand you intend to populate them with the results of a <code>[can.Model]</code> call:</p>\n\n<pre><code class=\"lang-javascript\">can.Control({\n    init: function() {\n        this.list = new Todo.List();\n        // live-bind the list into the DOM\n        this.element.html(can.view('list.mustache', this.list));\n        // when this AJAX call returns, the live-bound DOM will be updated\n        this.list.replace(Todo.findAll());\n    }\n});</code></pre>\n\n<p>Learn more about [can.Model.List making Lists of models].</p>\n\n<h2>Events</h2>\n\n<p>A major difference between <code>replace</code> and <code>attr(newElements, true)</code> is that <code>replace</code> always emits\nan<em>add</em> event and a <em>remove</em> event, whereas <code>attr</code> will cause <em>set</em> events along an <em>add</em> or <em>remove</em>\nevent if needed. Corresponding <em>change</em> and <em>length</em> events will be fired as well.</p>\n\n<p>The differences in the events fired by <code>attr</code> and <code>replace</code> are demonstrated concretely by this example:</p>\n\n<pre><code class=\"lang-javascript\">var attrList = new can.Observe.List(['Alexis', 'Bill']);\nattrList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nvar replaceList = new can.Observe.List(['Alexis', 'Bill']);\nreplaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nattrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n                                              // 1, set, Ben, Bill\nreplaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n                                              // 0, add, undefined, ['Adam', 'Ben']\n\nattrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n                                              // 1, remove, undefined, Ben\nreplaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n                                              // 0, add, Amber, ['Adam', 'Ben']\n\nattrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n                                              // 1, add, ['Bob', 'Eve'], undefined\nreplaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n                                              // 0, add, ['Alice', 'Bob', 'Eve'], Amber</code></pre>"
                                        }
                                    ]
                                }
                            ],
                            "src": "can/observe/observe.js",
                            "line": 1934,
                            "id": 46
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.reverse",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true</code></pre>     ",
                            "description": "<p>Reverse the order of a List. </p>",
                            "title": "reverse",
                            "signatures": [{
                                    "code": "reverse()",
                                    "description": "<p><code>reverse</code> reverses the elements of the List in place.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe.List"
                                            }
                                        ],
                                        "description": "<p>the List, for chaining</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1823,
                            "id": 42
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.serialize",
                            "params": [],
                            "parent": "can.Observe.List.prototype",
                            "body": "",
                            "description": "<p>Returns the serialized form of this list.</p>",
                            "hide": true,
                            "src": "can/observe/observe.js",
                            "line": 1111,
                            "id": 32
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.shift",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>shift</code> is the opposite action from <code>[can.Observe.List.unshift unshift]</code>:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n\nlist.shift(); // 'Bob'\nlist.shift(); // 'Eve'\nlist.shift(); // 'Alice'\nlist.shift(); // undefined</code></pre>\n\n<h2>Events</h2>\n\n<p><code>pop</code> causes <em>change</em>, <em>remove</em>, and <em>length</em> events to be fired if the List is not empty\nwhen it is called.</p>\n\n<h2>See also</h2>\n\n<p><code>shift</code> has a counterpart in [can.Observe.List.unshift unshift], or you may be\nlooking for [can.Observe.List.push push] and its counterpart [can.Observe.List.pop pop].</p>",
                            "description": "<p>Remove en element from the front of a list. </p>",
                            "title": "shift",
                            "signatures": [{
                                    "code": "shift()",
                                    "description": "<p><code>shift</code> removes an element from the beginning of a List.</p>",
                                    "params": [],
                                    "returns": {
                                        "types": [{
                                                "type": "*"
                                            }
                                        ],
                                        "description": "<p>the element just shifted off the List, or <code>undefined</code> if the List is empty</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1708,
                            "id": 39
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.slice",
                            "parent": "can.Observe.List.prototype",
                            "body": "<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList.attr(); // ['Bob', 'Charlie', 'Daniel']</code></pre>\n\n<p><code>slice</code> is the simplest way to copy a List:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy.attr();   // ['Alice', 'Bob', 'Eve']\nlist === copy; // false</code></pre>     ",
                            "description": "<p>Make a copy of a part of a List. </p>",
                            "title": "slice",
                            "signatures": [{
                                    "code": "slice([start[, end]])",
                                    "description": "<p><code>slice</code> creates a copy of a portion of the List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "start",
                                            "defaultValue": "0",
                                            "description": "<p>the index to start copying from</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "end",
                                            "description": "<p>the first index not to include in the copy\nIf <em>end</em> is not supplied, <code>slice</code> will copy until the end of the list.</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "can.Observe.List"
                                            }
                                        ],
                                        "description": "<p>a new <code>can.Observe.List</code> with the extracted elements</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1843,
                            "id": 43
                        }, {
                            "active": false,
                            "type": "function",
                            "name": "can.Observe.List.prototype.splice",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>splice</code> lets you remove elements from and insert elements into a List.</p>\n\n<p>This example demonstrates how to do surgery on a list of numbers:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.attr(); // [0, 1, 'Alice', 'Bob', 3]</code></pre>\n\n<h2>Events</h2>\n\n<p><code>splice</code> causes the List it's called on to emit <em>change</em> events,\n<em>add</em> events, <em>remove</em> events, and <em>length</em> events. If there are\nany elements to remove, a <em>change</em> event, a <em>remove</em> event, and a\n<em>length</em> event will be fired. If there are any elements to insert, a\nseparate <em>change</em> event, an <em>add</em> event, and a separate <em>length</em> event\nwill be fired. </p>\n\n<p>This slightly-modified version of the above example should help\nmake it clear how <code>splice</code> causes events to be emitted:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['a', 'b', 'c', 'd']);\nlist.bind('change', function(ev, attr, how, newVals, oldVals) {\n    console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\nlist.bind('add', function(ev, newVals, where) {\n    console.log('add: ' + newVals + ', ' + where);\n});\nlist.bind('remove', function(ev, oldVals, where) {\n    console.log('remove: ' + oldVals + ', ' + where);\n});\nlist.bind('length', function(ev, length) {\n    console.log('length: ' + length + ', ' + this.attr());\n});\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                   // remove: ['c'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                   // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                   // add: ['Alice', 'Bob'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']</code></pre>\n\n<p>More information about binding to these events can be found under [can.Observe.List.attr attr].</p>",
                            "description": "<p>Insert and remove elements from a List. </p>",
                            "title": "splice",
                            "signatures": [{
                                    "code": "splice(index[, howMany[, ...newElements]])",
                                    "description": "",
                                    "params": [{
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "name": "index",
                                            "description": "<p>where to start removing or inserting elements</p>"
                                        }, {
                                            "types": [{
                                                    "type": "Number"
                                                }
                                            ],
                                            "optional": true,
                                            "name": "howMany",
                                            "description": "<p>the number of elements to remove\nIf <em>howMany</em> is not provided, <code>splice</code> will all elements from <code>index</code> to the end of the List.</p>"
                                        }, {
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "newElements",
                                            "description": "<p>elements to insert into the List</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Array"
                                            }
                                        ],
                                        "description": "<p>the elements removed by <code>splice</code></p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1154,
                            "id": 34
                        }, {
                            "active": false,
                            "name": "can.Observe.List.prototype.unshift",
                            "type": "function",
                            "parent": "can.Observe.List.prototype",
                            "body": "<p><code>unshift</code> adds elements to the front of the list in bulk in the order specified:</p>\n\n<pre><code class=\"lang-javascript\">var list = new can.Observe.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']</code></pre>\n\n<p>If you have an array you want to concatenate to the beginning\nof the List, you can use <code>apply</code>:</p>\n\n<pre><code class=\"lang-javascript\">var names = ['Bob', 'Eve'],\n    list = new can.Observe.List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Bob', 'Eve', 'Alice']</code></pre>\n\n<h2>Events</h2>\n\n<p><code>unshift</code> causes <em>change</em>, <em>add</em>, and <em>length</em> events to be fired.</p>\n\n<h2>See also</h2>\n\n<p><code>unshift</code> has a counterpart in [can.Observe.List.shift shift], or you may be\nlooking for [can.Observe.List.push push] and its counterpart [can.Observe.List.pop pop].</p>",
                            "description": "<p>Add elements to the beginning of a List. </p>",
                            "title": "unshift",
                            "signatures": [{
                                    "code": "unshift(...elements)",
                                    "description": "<p><code>unshift</code> adds elements onto the beginning of a List.</p>",
                                    "params": [{
                                            "types": [{
                                                    "type": "*"
                                                }
                                            ],
                                            "name": "elements",
                                            "description": "<p>the elements to add to the List</p>"
                                        }
                                    ],
                                    "returns": {
                                        "types": [{
                                                "type": "Number"
                                            }
                                        ],
                                        "description": "<p>the new length of the List</p>"
                                    }
                                }
                            ],
                            "comment": " ",
                            "src": "can/observe/observe.js",
                            "line": 1594,
                            "id": 37
                        }
                    ]
                }
            ]
        }, {
            "active": false,
            "name": "can.compute",
            "type": "constructor",
            "body": "<p><code>can.compute</code> lets you make observable values. A compute is actually a function that returns\nthe computed value, but you can also use the compute to set the value and you can use\n<code>bind</code> to listen to changes in the compute's return value. In this way, computes are similar\nto [can.Observe Observes], but they represent a single value rather than a collection of values.</p>\n\n<h2>Working with computes</h2>\n\n<p>The simplest way to use a compute is to have it store a single value, and to set it when\nthat value needs to change:</p>\n\n<pre><code class=\"lang-javascript\">var tally = can.compute(12);\ntally(); // 12\n\ntally(13);\ntally(); // 13</code></pre>\n\n<p>This is useful for making observable values, but the real power of <code>can.compute</code> reveals\nitself when you combine it with <code>[can.Observe]</code>. If you use a compute that derives its\nvalue from properties of an Observe, the compute will listen for changes in those\nproperties and automatically recalculate itself, emitting a <em>change</em> event if its value\nchanges.</p>\n\n<p>As this example shows, this kind of compute rarely has need to be set directly:</p>\n\n<pre><code class=\"lang-javascript\">var person = new can.Observe({\n    firstName: 'Alice',\n    lastName: 'Liddell'\n});\n\nvar fullName = can.compute(function() {\n    return person.attr('firstName') + ' ' + person.attr('lastName');\n});\nfullName.bind('change', function(ev, newVal, oldVal) {\n    console.log(\"This person's full name is now \" + newVal + '.');\n});\n\nperson.attr('firstName', 'Allison'); // The log reads:\n                                     // \"This person's full name is now Allison Liddell.\"</code></pre>\n\n<p>Take special notice of how the definition of the compute uses <code>[can.Observe.prototype.attr attr]</code>\nto read the values of the properties of <code>person</code>. This is how the compute knows to listen\nfor changes. and is similar to the need to use <code>attr</code> when live-binding properties of Observes into\n<code>[can.EJS EJS]</code> templates.</p>\n\n<p>A specific use for bound computes like this is to provide a way to work with values of Observable\nproperties in different units:</p>\n\n<pre><code class=\"lang-javascript\">var wall = new can.Observe({\n    material: 'brick',\n    length: 10 // in feet\n});\n\nvar wallLengthInMeters = can.compute(function(lengthInM) {\n    if(lengthInM !== undefined) {\n        wall.attr('length', lengthInM / 3.28084);\n    } else {\n        return wall.attr('length') * 3.28084;\n    }\n});\n\nwallLengthInMeters(); // 3.048\n\n// When you set the compute...\nwallLengthInMeters(5);\nwallLengthInMeters(); // 5\n// ...the original Observe changes too.\nwall.length;          // 16.4042</code></pre>\n\n<h2>Events</h2>\n\n<p>When a compute's value is changed, it emits a <em>change</em> event. You can listen for this change\nevent by using <code>[can.compute.bind bind]</code> to bind an event handler to the compute:</p>\n\n<pre><code class=\"lang-javascript\">var tally = can.compute(0);\ntally.bind('change', function(ev, newVal, oldVal) {\n    console.log('The tally is now at ' + newVal + '.');\n});\n\ntally(tally() + 5); // The log reads:\n                    // 'The tally is now at 5.'</code></pre>\n\n<h2>Using computes to build Controls</h2>\n\n<p>It's a piece of cake to build a <code>[can.Control]</code> off of the value of a compute. And since computes\nare observable, it means that the view of that Control will update itself whenever the value\nof the compute updates. Here's a simple slider that works off of a compute:</p>\n\n<pre><code class=\"lang-javascript\">var project = new Observe({\n    name: 'A Very Important Project',\n    percentDone: .35\n});\n\ncan.Control('SimpleSlider', { }, {\n    init: function() {\n        this.element.html(can.view(this.options.view, this.options));\n    },\n    '.handle dragend': function(el, ev) {\n        var percent = this.calculateSliderPercent();\n        // set the compute's value\n        this.options.percentDone(percent);\n    },\n    '{percentDone} change': function(ev, newVal, oldVal) {\n       // react to the percentage changing some other way\n        this.moveSliderTo(newVal);\n    }\n    // Implementing calculateSliderPercent and moveSliderTo\n    // has been left as an exercise for the reader.\n});\n\nnew SimpleSlider('#slider', {percentDone: project.compute('percentDone')});</code></pre>\n\n<p>Now that's some delicious cake. More information on Controls can be found under <code>[can.Control]</code>.\nThere is also a full explanation of can.Observe's <code>[can.Observe.prototype.compute compute]</code>,\nwhich is used in the last line of the example above.</p>",
            "description": "",
            "parent": "canjs",
            "signatures": [{
                    "code": "can.compute(getterSetter[, context])",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "function",
                                    "returns": {
                                        "types": [{
                                                "type": "undefined"
                                            }
                                        ]
                                    },
                                    "params": []
                                }
                            ],
                            "name": "getterSetter",
                            "description": "<p>A function that gets and optionally sets the value of the compute.\nWhen called with no parameters, <em>getterSetter</em> should return the current value of the compute. When\ncalled with a single parameter, <em>getterSetter</em> should arrange things so that the next read of the compute\nproduces that value.</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "context",
                            "description": "<p>The context to use when evaluating the compute.</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.compute"
                            }
                        ],
                        "description": "<p>A new compute.</p>"
                    }
                }
            ],
            "comment": " ",
            "src": "can/observe/compute/compute.js",
            "line": 130,
            "id": 47,
            "children": [{
                    "active": false,
                    "type": "function",
                    "name": "can.compute.bind",
                    "parent": "can.compute",
                    "body": "",
                    "description": "<p>Bind an event handler to a compute. </p>",
                    "title": "bind",
                    "signatures": [{
                            "code": "bind(eventType, handler)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "eventType",
                                    "description": "<p>The event to bind this handler to.\nThe only event type that computes emit is <em>change</em>.</p>"
                                }, {
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": [{
                                                    "types": [{
                                                            "type": "Object",
                                                            "options": [{
                                                                    "name": "Object"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }, {
                                                    "types": [{
                                                            "type": "Object",
                                                            "options": [{
                                                                    "name": "*"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }, {
                                                    "types": [{
                                                            "type": "Object",
                                                            "options": [{
                                                                    "name": "*"
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ],
                                    "name": "handler",
                                    "description": "<p>The handler to call when the event happens.\nThe handler should have three parameters:\n- <em>event</em> is the event object.\n- <em>newVal</em> is the newly-computed value of the compute.\n- <em>oldVal</em> is the value of the compute before it changed.</p>\n\n<p><code>bind</code> lets you listen to a compute to know when it changes. It works just like\ncan.Observe's <code>[can.Observe.prototype.bind bind]</code>:</p>\n\n<pre><code class=\"lang-javascript\">var tally = can.compute(0);\ntally.bind('change', function(ev, newVal, oldVal) {\n    console.log('The tally is now at ' + newVal + '.');\n});\n\ntally(tally() + 5); // The log reads:\n                    // 'The tally is now at 5.'</code></pre>"
                                }
                            ]
                        }
                    ],
                    "src": "can/observe/compute/compute.js",
                    "line": 327,
                    "id": 49
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.compute.unbind",
                    "parent": "can.compute",
                    "body": "",
                    "description": "<p>Unbind an event handler from a compute. </p>",
                    "title": "unbind",
                    "signatures": [{
                            "code": "unbind(eventType[, handler])",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "eventType",
                                    "description": "<p>The type of event to unbind.\nThe only event type available for computes is <em>change</em>.</p>"
                                }, {
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": []
                                        }
                                    ],
                                    "optional": true,
                                    "name": "handler",
                                    "description": "<p>If given, the handler to unbind.\nIf <em>handler</em> is not supplied, all handlers bound to <em>eventType</em>\nwill be removed.</p>"
                                }
                            ]
                        }
                    ],
                    "src": "can/observe/compute/compute.js",
                    "line": 362,
                    "id": 50
                }, {
                    "active": false,
                    "name": "isComputed",
                    "type": "property",
                    "parent": "can.compute",
                    "body": "",
                    "description": "<p>Whether the value of the compute has been computed yet.</p>",
                    "title": "",
                    "src": "can/observe/compute/compute.js",
                    "line": 319,
                    "id": 48
                }
            ]
        }, {
            "active": false,
            "type": "page",
            "name": "can.route",
            "body": "<h2>Background Information</h2>\n\n<p>To support the browser's back button and bookmarking\nin an Ajax application, most applications use\nthe <code>window.location.hash</code>.  By\nchanging the hash (via a link or JavaScript), \none is able to add to the browser's history \nwithout changing the page.</p>\n\n<p>This provides the basics needed to\ncreate history enabled Ajax websites.  However,\n<code>can.route</code> addresses several other needs such as:</p>\n\n<ul>\n<li>Pretty urls (actually hashes)</li>\n<li>Keeping routes independent of application code</li>\n<li>Listening to specific parts of the history changing</li>\n<li>Setup / Teardown of widgets.</li>\n</ul>\n\n<h2>How it works</h2>\n\n<p><code>can.route</code> is a [can.Observe] that represents the\n<code>window.location.hash</code> as an \nobject.  For example, if the hash looks like:</p>\n\n<pre><code>#!type=videos&amp;id=5\n</code></pre>\n\n<p>the data in <code>can.route</code> looks like:</p>\n\n<pre><code>{ type: 'videos', id: 5 }\n</code></pre>\n\n<p><code>can.route</code> keeps the state of the hash in-sync with the <code>data</code> contained within \n<code>can.route</code>.</p>\n\n<h2>can.Observe</h2>\n\n<p><code>can.route</code> is a [can.Observe]. Understanding\n<code>can.Observe</code> is essential for using <code>can.route</code> correctly.</p>\n\n<p>You can listen to changes in an Observe with <code>bind(eventName, handler(ev, args...))</code> and\nchange can.route's properties with \n[can.Observe.prototype.attr attr].</p>\n\n<h3>Listening to changes in an Observable</h3>\n\n<p>Listen to changes in history \nby [can.Observe.prototype.bind bind]ing to\nchanges in <code>can.route</code> like:</p>\n\n<pre><code>can.route.bind('change', function(ev, attr, how, newVal, oldVal) {\n\n})\n</code></pre>\n\n<ul>\n<li><code>attr</code> - the name of the changed attribute</li>\n<li><code>how</code> - the type of Observe change event (add, set or remove)</li>\n<li><code>newVal</code>/<code>oldVal</code> - the new and old values of the attribute</li>\n</ul>\n\n<p>You can also listen to specific changes \nwith [can.Observe.delegate delegate]:</p>\n\n<pre><code>can.route.delegate('id','change', function(){ ... })\n</code></pre>\n\n<p>Observe lets you listen to the following events:</p>\n\n<ul>\n<li>change - any change to the object</li>\n<li>add - a property is added</li>\n<li>set - a property value is added or changed</li>\n<li>remove - a property is removed</li>\n</ul>\n\n<p>Listening for <code>add</code> is useful for widget setup\nbehavior, <code>remove</code> is useful for teardown.</p>\n\n<h3>Updating an observable</h3>\n\n<p>Create changes in the route data with [can.Observe.prototype.attr attr] like:</p>\n\n<pre><code>can.route.attr('type','images');\n</code></pre>\n\n<p>Or change multiple properties at once like:</p>\n\n<pre><code>can.route.attr({type: 'pages', id: 5}, true)\n</code></pre>\n\n<p>When you make changes to can.route, they will automatically\nchange the <code>hash</code>.</p>\n\n<h2>Creating a Route</h2>\n\n<p>Use <code>can.route(url, defaults)</code> to create a \nroute. A route is a mapping from a url to \nan object (that is the can.route's state). \nIn order to map to a specific properties in the url,\nprepend a colon to the name of the property like:</p>\n\n<pre><code>can.route( \"!#content/:type\" )\n</code></pre>\n\n<p>If no routes are added, or no route is matched, \ncan.route's data is updated with the [can.deparam deparamed]\nhash.</p>\n\n<pre><code>location.hash = \"#!type=videos\";\n// can.route -&gt; {type : \"videos\"}\n</code></pre>\n\n<p>Once routes are added and the hash changes,\ncan.route looks for matching routes and uses them\nto update can.route's data.</p>\n\n<pre><code>can.route( \"!#content/:type\" );\nlocation.hash = \"#!content/images\";\n// can.route -&gt; {type : \"images\"}\ncan.route.attr( \"type\", \"songs\" )\n// location.hash -&gt; \"#!content/songs\"\n</code></pre>\n\n<p>Default values can also be added:</p>\n\n<pre><code>can.route(\"content/:type\",{type: \"videos\" });\nlocation.hash = \"#!content/\"\n// can.route -&gt; {type : \"videos\"}\n</code></pre>\n\n<h2>Delay setting can.route</h2>\n\n<p>By default, <code>can.route</code> sets its initial data\non document ready.  Sometimes, you want to wait to set \nthis data.  To wait, call:</p>\n\n<pre><code>can.route.ready(false);\n</code></pre>\n\n<p>and when ready, call:</p>\n\n<pre><code>can.route.ready(true);\n</code></pre>\n\n<h2>Changing the route.</h2>\n\n<p>Typically, you never want to set <code>location.hash</code>\ndirectly.  Instead, you can change properties on <code>can.route</code>\nlike:</p>\n\n<pre><code>can.route.attr('type', 'videos')\n</code></pre>\n\n<p>This will automatically look up the appropriate \nroute and update the hash.</p>\n\n<p>Often, you want to create links.  <code>can.route</code> provides\nthe [can.route.link] and [can.route.url] helpers to make this \neasy:</p>\n\n<pre><code>can.route.link(\"Videos\", {type: 'videos'})\n</code></pre>\n\n<h2>Demo</h2>\n\n<p>The following demo shows the relationship between <code>window.location.hash</code>,\nroutes given to <code>can.data</code>,\n<code>can.route</code>'s data, and events on <code>can.data</code>.  Most properties \nare editable so experiment!</p>\n\n<div class='iframe_wrapper' data-iframe-src='can/route/demo.html' data-iframe-height='980'></div>\n\n<h2>IE Compatibility</h2>\n\n<p>Internet Explorer 6 and 7 does not support <code>window.onhashchange</code>. \nEven Internet Explorer 8 running in IE7 compatibility mode reports <code>true</code> \nfor <code>onhashchange</code> in window, even though the event isn't supported.</p>\n\n<p>If you are using jQuery, you can include Ben Alman's [HashChange Plugin http://benalman.com/projects/jquery-hashchange-plugin/]\nto support the event in the unsupported browser(s).  Include <code>can/route/hashchange.js</code>\nin your file to support those browsers.</p>\n\n<h2>Using routes with <code>can.Control</code></h2>\n\n<p>Using templated event handlers, it is possible to listen to changes to\n<code>can.route</code> within <code>can.Control</code>. This is convenient as it allows the\ncontrol to listen to and make changes whenever the route is modified, \neven outside of the control itself.</p>\n\n<pre><code>// create the route\ncan.route(\"!#content/:type\")\n\n// the route has changed\n\"{can.route} change\": function(ev, attr, how, newVal, oldVal) {\n    if (attr === \"type\") {\n        // the route has a type\n    }\n}\n</code></pre>\n\n<h3>Creating and binding routes with <code>can.Control.route</code></h3>\n\n<p>Using [can.Control.route], a builtin plugin to CanJS, cuts down on the amount\nof code needed to work with <code>can.route</code> in <code>can.Control</code>. With this plugin, it is possible\nto both create routes and bind to <code>can.route</code> at the same time. Instead of creating\nseveral routes to handle changes to <strong>type</strong> and <strong>id</strong>, write something like this\nin a control:</p>\n\n<pre><code>// the route is empty\n\"route\": function(data) {\n\n},\n// the route has a type\n\":type route\": function(data) {\n\n}, \n// the route has a type and id\n\":type/:id route\": function(data) {\n\n}\n</code></pre>\n\n<h3>Getting more specific with the <code>can.Observe.delegate</code> plugin</h3>\n\n<p>Sometimes, you might only want to trigger a function when the route changes\nonly once, even if the route change gets called multiple times. By using the \n[can.Observe.delegate] plugin, this is extremely easy. This plugin allows you to \nlisten to change, set, add, and remove on <code>can.route</code>.</p>\n\n<p>If you wanted to, say, show a list of recipes when  <strong>type</strong> was set to recipe\nand show a specific recipe when <strong>id</strong> was set, you could do something like:</p>\n\n<pre><code>\"{can.route} type=recipe set\": \n        function( ev, prop, how, newVal, oldVal ) {\n    // show list of recipes\n},\n\"recipe/:id\": function(data) {\n    // show a single recipe\n}\n</code></pre>\n\n<p>If we didn't only listen to when recipe is set, then every time we chose to\nshow a single recipe, we would create and show the list of recipes again which \nwould not very efficient.</p>",
            "description": "<p>can.route is a plugin that helps manage browser history and\nclient state by synchronizing the window.location.hash with\nan [can.Observe].</p>",
            "title": "can.route",
            "inherits": "can.Observe",
            "download": "can/route",
            "test": "can/route/qunit.html",
            "parent": "canjs",
            "signatures": [{
                    "code": "can.route(template[, defaults])",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "name": "template",
                            "description": "<p>the fragment identifier to match.  The fragment identifier\nshould start with either a character (a-Z) or colon (:).  Examples:</p>\n\n<pre><code>can.route(\":foo\")\ncan.route(\"foo/:bar\")\n</code></pre>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "optional": true,
                            "name": "defaults",
                            "description": "<p>an object of default values</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "can.route"
                            }
                        ],
                        "description": ""
                    }
                }
            ],
            "comment": " ",
            "src": "can/route/route.md",
            "id": 88,
            "children": [{
                    "active": false,
                    "type": "function",
                    "name": "can.route.current",
                    "parent": "can.route",
                    "body": "<p>Checks the page's current URL to see if the route represents the options passed \ninto the function.</p>\n\n<p>Returns true if the options respresent the current URL.</p>\n\n<pre><code>can.route.attr('id', 5) // location.hash -&gt; \"#!id=5\"\ncan.route.current({ id: 5 }) // -&gt; true\ncan.route.current({ id: 5, type: 'videos' }) // -&gt; false\n\ncan.route.attr('type', 'videos') \n       // location.hash -&gt; #!id=5&amp;type=videos\ncan.route.current({ id: 5, type: 'videos' }) // -&gt; true\n</code></pre>",
                    "description": "",
                    "title": "",
                    "signatures": [{
                            "code": "current(options)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "options",
                                    "description": "<p>Data to check agains the current route.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Boolean"
                                    }
                                ],
                                "description": "<p>Whether the data matches the current URL.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/route/route.js",
                    "line": 388,
                    "id": 96
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.route.deparam",
                    "parent": "can.route",
                    "body": "<p>Creates a data object based on the query string passed into it. This is \nuseful to create an object based on the <code>location.hash</code>.</p>\n\n<pre><code>can.route.deparam(\"id=5&amp;type=videos\") \n     // -&gt; { id: 5, type: \"videos\" }\n</code></pre>\n\n<p>It's important to make sure the hash or exclamantion point is not passed\nto <code>can.route.deparam</code> otherwise it will be included in the first property's\nname.</p>\n\n<pre><code>can.route.attr(\"id\", 5) // location.hash -&gt; #!id=5\ncan.route.attr(\"type\", \"videos\") \n     // location.hash -&gt; #!id=5&amp;type=videos\ncan.route.deparam(location.hash) \n     // -&gt; { #!id: 5, type: \"videos\" }\n</code></pre>\n\n<p><code>can.route.deparam</code> will try and find a matching route and, if it does,\nwill deconstruct the URL and parse our the key/value parameters into the data object.</p>\n\n<pre><code>can.route(\":type/:id\")\n\ncan.route.deparam(\"videos/5\");\n     // -&gt; { id: 5, route: \":type/:id\", type: \"videos\" }\n</code></pre>",
                    "description": "<p>Extract data from a route URL. </p>",
                    "title": "",
                    "signatures": [{
                            "code": "deparam(url)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "url",
                                    "description": "<p>A URL to extract data from.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p>An object containing the extracted data.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/route/route.js",
                    "line": 184,
                    "id": 90
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.route.link",
                    "parent": "can.route",
                    "body": "<p>Creates and returns an anchor tag with an href of the route \nattributes passed into it, as well as any properies desired\nfor the tag.</p>\n\n<pre><code>can.route.link( \"My videos\", { type: \"videos\" }, {}, false )\n     // -&gt; &lt;a href=\"#!type=videos\"&gt;My videos&lt;/a&gt;\n</code></pre>\n\n<p>Other attributes besides href can be added to the anchor tag\nby passing in a data object with the attributes desired.</p>\n\n<pre><code>can.route.link( \"My videos\", { type: \"videos\" }, \n  { className: \"new\" }, false ) \n     // -&gt; &lt;a href=\"#!type=videos\" class=\"new\"&gt;My Videos&lt;/a&gt;\n</code></pre>\n\n<p>It is possible to utilize the current route options when making anchor\ntags in order to make your code more reusable. If merge is set to true,\nthe route options passed into <code>can.route.link</code> will be passed into the\ncurrent ones.</p>\n\n<pre><code>location.hash = \"#!type=videos\" \ncan.route.link( \"The zoo\", { id: 5 }, true )\n     // -&gt; &lt;a href=\"#!type=videos&amp;id=5\"&gt;The zoo&lt;/true&gt;\n\nlocation.hash = \"#!type=pictures\" \ncan.route.link( \"The zoo\", { id: 5 }, true )\n     // -&gt; &lt;a href=\"#!type=pictures&amp;id=5\"&gt;The zoo&lt;/true&gt;\n</code></pre>",
                    "description": "",
                    "title": "",
                    "signatures": [{
                            "description": "<p>`link(innerText, options, props[, merge])</p>",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "innerText",
                                    "description": "<p>The text inside the link.</p>"
                                }, {
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "options",
                                    "description": "<p>The data to populate the route with.</p>"
                                }, {
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "props",
                                    "description": "<p>Properties for the anchor other than <code>href</code>.</p>"
                                }, {
                                    "types": [{
                                            "type": "Boolean"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "merge",
                                    "description": "<p>Whether the given options should be merged into the current state of the route.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "String"
                                    }
                                ],
                                "description": "<p>A string with an anchor tag that points to the populated route.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/route/route.js",
                    "line": 342,
                    "id": 95
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.route.param",
                    "parent": "can.route",
                    "body": "<p>Parameterizes the raw JS object representation provided in data.</p>\n\n<pre><code>can.route.param( { type: \"video\", id: 5 } ) \n     // -&gt; \"type=video&amp;id=5\"\n</code></pre>\n\n<p>If a route matching the provided data is found, that URL is built\nfrom the data. Any remaining data is added at the end of the\nURL as &amp; separated key/value parameters.</p>\n\n<pre><code>can.route(\":type/:id\")\n\ncan.route.param( { type: \"video\", id: 5 } ) // -&gt; \"video/5\"\ncan.route.param( { type: \"video\", id: 5, isNew: false } ) \n     // -&gt; \"video/5&amp;isNew=false\"\n</code></pre>",
                    "description": "<p>Get a route URL from given data. </p>",
                    "title": "",
                    "signatures": [{
                            "code": "param(data)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "data"
                                        }
                                    ],
                                    "name": "object",
                                    "description": "<p>The data to populate the route with.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "String"
                                    }
                                ],
                                "description": "<p>The route, with the data populated in it.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/route/route.js",
                    "line": 96,
                    "id": 89
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.route.ready",
                    "parent": "can.route",
                    "body": "<p>Indicates that all routes have been added and sets can.route.data\nbased upon the routes and the current hash.</p>\n\n<p>By default, ready is fired on jQuery's ready event.  Sometimes\nyou might want it to happen sooner or earlier.  To do this, call:</p>\n\n<pre><code>can.route.ready(false); //prevents firing by the ready event\ncan.route.ready(true); // fire the first route change\n</code></pre>",
                    "description": "",
                    "title": "",
                    "signatures": [{
                            "code": "ready(readyYet)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Boolean"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "readyYet",
                                    "description": "<p>Whether the ready event should be fired yet.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "can.route"
                                    }
                                ],
                                "description": "<p>The <code>can.route</code> object.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/route/route.js",
                    "line": 285,
                    "id": 93
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.route.url",
                    "parent": "can.route",
                    "body": "<p>Similar to [can.route.link], but instead of creating an anchor tag, <code>can.route.url</code> creates \nonly the URL based on the route options passed into it.</p>\n\n<pre><code>can.route.url( { type: \"videos\", id: 5 } ) \n     // -&gt; \"#!type=videos&amp;id=5\"\n</code></pre>\n\n<p>If a route matching the provided data is found the URL is built from the data. Any remaining\ndata is added at the end of the URL as &amp; separated key/value parameters.</p>\n\n<pre><code>can.route(\":type/:id\")\n\ncan.route.url( { type: \"videos\", id: 5 } ) // -&gt; \"#!videos/5\"\ncan.route.url( { type: \"video\", id: 5, isNew: false } ) \n     // -&gt; \"#!video/5&amp;isNew=false\"\n</code></pre>",
                    "description": "",
                    "title": "",
                    "signatures": [{
                            "code": "url(options[, merge])",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "options",
                                    "description": "<p>The data to populate the route with.</p>"
                                }, {
                                    "types": [{
                                            "type": "Boolean"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "merge",
                                    "description": "<p>Whether the given options should be merged into the current state of the route.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "String"
                                    }
                                ],
                                "description": "<p>The route URL and query string.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/route/route.js",
                    "line": 312,
                    "id": 94
                }
            ]
        }, {
            "active": false,
            "type": "page",
            "name": "can.util",
            "body": "",
            "description": "<p>Utility methods supported by CanJS</p>",
            "title": "can.util",
            "parent": "canjs",
            "src": "can/util/util.md",
            "id": 111,
            "children": [{
                    "active": false,
                    "body": "<p><code>can.$(element)</code> returns the the underlying\nlibrary's NodeList.  It can be passed\na css selector, a HTMLElement or an array of HTMLElements.</p>\n\n<p>The following lists how the NodeList is created by each library:</p>\n\n<ul>\n<li><strong>jQuery</strong> <code>jQuery( HTMLElement )</code></li>\n<li><strong>Zepto</strong> <code>Zepto( HTMLElement )</code></li>\n<li><strong>Dojo</strong> <code>new dojo.NodeList( HTMLElement )</code></li>\n<li><strong>Mootools</strong> <code>$$( HTMLElement )</code></li>\n<li><strong>YUI</strong> <code>Y.all(selector)</code> or <code>Y.NodeList</code></li>\n</ul>",
                    "description": "<p>Make a library's nodelist. </p>",
                    "title": "",
                    "name": "can.$",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.$(element)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }, {
                                            "type": "Element"
                                        }, {
                                            "type": "NodeList"
                                        }
                                    ],
                                    "name": "element",
                                    "description": "<p>The selector, HTML element, or nodelist\nto pass to the underlying library.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "NodeList"
                                    }
                                ],
                                "description": "<p>The nodelist as constructed by the underlying library.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 394,
                    "id": 128
                }, {
                    "active": false,
                    "body": "<p><code>can.addClass( nodelist, className )</code> adds the specified class(es) to\nnodelist's HTMLElements.  It does NOT replace any existing class(es)\nalready defined.</p>\n\n<pre><code class=\"lang-javascript\">// Before\n<div id=\"foo\" class=\"monkey\" />\n\ncan.addClass(can.$(\"#foo\"),\"bar\")\n\n// After\n<div id=\"foo\" class=\"monkey bar\" /></code></pre>\n\n<p>You can also pass multiple class(es) and it will add them to the existing\nset also.</p>\n\n<pre><code class=\"lang-javascript\">// Before\n<div id=\"foo\" class=\"monkey\" />\n\ncan.addClass(can.$(\"#foo\"),\"bar man\")\n\n// After\n<div id=\"foo\" class=\"monkey bar man\" /></code></pre>\n\n<p>This works similarly to [http://api.jquery.com/addClass/ jQuery.fn.addClass].</p>",
                    "description": "<p>Add a class to elements. </p>",
                    "title": "",
                    "name": "can.addClass",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.addClass(nodeList, className)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "NodeList"
                                        }
                                    ],
                                    "name": "nodeList",
                                    "description": "<p>The list of HTML elements to add the class to.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "className",
                                    "description": "<p>The class to add.</p>"
                                }
                            ]
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 504,
                    "id": 133
                }, {
                    "active": false,
                    "body": "<p><code>can.ajax( settings )</code> is used to make an asynchronous HTTP (Ajax) request\nsimilar to [http://api.jquery.com/jQuery.ajax/ jQuery.ajax].</p>\n\n<pre><code class=\"lang-javascript\">can.ajax({\n  url: 'ajax/farm/animals',\n    success: function(animals) {\n        can.$('.farm').html(animals);\n    }\n});</code></pre>",
                    "description": "<p>Make an AJAX request. </p>",
                    "title": "",
                    "name": "can.ajax",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.ajax(settings)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "settings",
                                    "description": "<p>Configuration options for the AJAX request.\nThe list of configuration options is the same as for <a href=\"http://api.jquery.com/jQuery.ajax/#jQuery-ajax-settings\">jQuery.ajax()</a>.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Deferred"
                                    }
                                ],
                                "description": "<p>A can.Deferred that resolves to the data.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 371,
                    "id": 127
                }, {
                    "active": false,
                    "body": "<p><code>can.append( wrappedNodeList, html )</code> inserts content to the end of each wrapped node list item(s) passed.</p>\n\n<pre><code class=\"lang-javascript\">// Before\n<div id=\"demo\" />\n\ncan.append( can.$('#demo'), 'Demos are fun!' );\n\n// After\n<div id=\"demo\">Demos are fun!</div></code></pre>",
                    "description": "<p>Append content to elements. </p>",
                    "title": "",
                    "name": "can.append",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.append(nodeList, html)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "NodeList"
                                        }
                                    ],
                                    "name": "nodeList",
                                    "description": "<p>A nodelist of the elements to append content to.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "html",
                                    "description": "<p>The HTML to append to the end of the elements in <strong>nodeList</strong>.</p>"
                                }
                            ]
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 430,
                    "id": 130
                }, {
                    "active": false,
                    "body": "<p><code>can.bind(eventName, handler)</code> binds a callback handler\non an object for a given event.  It works on:</p>\n\n<ul>\n<li>HTML elements and the window</li>\n<li>Objects</li>\n<li>Objects with bind / unbind methods</li>\n</ul>\n\n<p>The idea is that bind can be used on anything that produces events\nand it will figure out the appropriate way to\nbind to it.  Typically, <code>can.bind</code> is only used internally to\nCanJS; however, if you are making libraries or extensions, use\n<code>can.bind</code> to listen to events independent of the underlying library.</p>\n\n<p><strong>Binding to an object</strong></p>\n\n<pre><code class=\"lang-javascript\">var obj = {};\ncan.bind.call(obj,\"something\", function(ev, arg1, arg){\n     arg1 // 1\n     arg2 // 2\n   })\ncan.trigger(obj,\"something\",[1,2])</code></pre>\n\n<p><strong>Binding to an HTMLElement</strong></p>\n\n<pre><code class=\"lang-javascript\">var el = document.getElementById('foo')\ncan.bind.call(el, \"click\", function(ev){\n   this // el\n });</code></pre>",
                    "description": "<p>Listen for events on an object. </p>",
                    "title": "",
                    "name": "can.bind",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.bind.call(target, eventName, handler)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "target",
                                    "description": "<p>The object that emits events.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "eventName",
                                    "description": "<p>The name of the event to listen for.</p>"
                                }, {
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": []
                                        }
                                    ],
                                    "name": "handler",
                                    "description": "<p>The function to execute when the event occurs.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p>The <strong>target</strong>.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 197,
                    "id": 122
                }, {
                    "active": false,
                    "body": "<p><code>can.buildFragment(html, node)</code> returns a document fragment for the HTML passed.</p>",
                    "description": "<p>Make a document fragment. </p>",
                    "title": "",
                    "name": "can.buildFragment",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.buildFragment(html, node)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "html",
                                    "description": "<p>A string of HTML.</p>"
                                }, {
                                    "types": [{
                                            "type": "DOM"
                                        }, {
                                            "type": "Node"
                                        }
                                    ],
                                    "name": "node",
                                    "description": "<p>A node used to access a document to make the fragment with.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "DocumentFragment"
                                    }
                                ],
                                "description": "<p>A document fragment made from <strong>html</strong>.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 417,
                    "id": 129
                }, {
                    "active": false,
                    "body": "<p><code>can.data</code> enables the associatation of arbitrary data with DOM nodes and JavaScript objects.</p>\n\n<h3>Setting Data</h3>\n\n<p>can.data( can.$('#elm'), key, value )</p>\n\n<ul>\n<li><strong>wrappedNodeList</strong> node list to associate data to.</li>\n<li><strong>key</strong> string name of the association.</li>\n<li><strong>value</strong> tdata value; it can be any Javascript type including Array or Object.</li>\n</ul>\n\n<h3>Accessing Data</h3>\n\n<p>can.data( can.$('#elm'), key )</p>\n\n<ul>\n<li><strong>wrappedNodeList</strong> node list to retrieve association data from.</li>\n<li><strong>key</strong> string name of the association.</li>\n</ul>\n\n<p>Due to the way browsers security restrictions with plugins and external code,\nthe <em>data</em> method cannot be used on <code>object</code> (unless it's a Flash plugin), <code>applet</code> or <code>embed</code> elements.</p>",
                    "description": "<p>Associate data with or retrieve data from DOM nodes. </p>",
                    "title": "",
                    "name": "can.data",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.data(nodeList, key, value)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "NodeList"
                                        }
                                    ],
                                    "name": "nodeList",
                                    "description": "<p>The list of nodes to add this data to.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "key",
                                    "description": "<p>The key to store this data under.</p>"
                                }, {
                                    "types": [{
                                            "type": "*"
                                        }
                                    ],
                                    "name": "value",
                                    "description": "<p>The data to store.</p>"
                                }
                            ]
                        }, {
                            "code": "can.data(nodeList, key)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "NodeList"
                                        }
                                    ],
                                    "name": "nodeList",
                                    "description": "<p>The list of nodes data was stored under.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "key",
                                    "description": "<p>The key to retrieve.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "*"
                                    }
                                ],
                                "description": "<p>The data stored under <strong>key</strong>.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 468,
                    "id": 132
                }, {
                    "active": false,
                    "body": "<p><code>can.delegate(selector, eventName, handler)</code> binds a delegate handler\non an object for a given event.  It works on:</p>\n\n<ul>\n<li>HTML elements and the window</li>\n</ul>\n\n<p>The idea is that delegate can be used on anything that produces delegate events\nand it will figure out the appropriate way to\nbind to it.  Typically, <code>can.delegate</code> is only used internally to\nCanJS; however, if you are making libraries or extensions, use\n<code>can.delegate</code> to listen to events independent of the underlying library.</p>\n\n<p><strong>Delegate binding to an HTMLElement</strong></p>\n\n<pre><code class=\"lang-javascript\">var el = document.getElementById('foo')\ncan.delegate.call(el, \".selector\", \"click\", function(ev){\n   this // el\n})</code></pre>",
                    "description": "<p>Listen for events from the children of an element. </p>",
                    "title": "",
                    "name": "can.delegate",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.delegate.call(element, selector, eventName, handler)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "HTMLElement"
                                        }
                                    ],
                                    "name": "element",
                                    "description": "<p>The HTML element to bind to.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "selector",
                                    "description": "<p>A selector for delegating downward.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "eventName",
                                    "description": "<p>The name of the event to listen for.</p>"
                                }, {
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": []
                                        }
                                    ],
                                    "name": "handler",
                                    "description": "<p>The function to execute when the event occurs.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p>The <strong>element</strong>.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 292,
                    "id": 124
                }, {
                    "active": false,
                    "body": "<p><code>can.each(collection, callback)</code> iterates through an array or object like\nlike [http://api.jquery.com/jQuery.each/ jQuery.each].</p>\n\n<pre><code class=\"lang-javascript\">can.each([{prop: \"val1\"}, {prop: \"val2\"}],\n function( value, index ) {\n   // function called with\n   // index=0 value={prop: \"val1\"}\n   // index=1 value={prop: \"val2\"}\n }\n);</code></pre>",
                    "description": "<p>Iterate through an array or object. </p>",
                    "title": "",
                    "name": "can.each",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.each(collection, callback)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "collection",
                                    "description": "<p>The object to iterate through.</p>"
                                }, {
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": []
                                        }
                                    ],
                                    "name": "callback",
                                    "description": "<p>A function to call for each item in <strong>collection</strong>.\n<strong>callback</strong> will recieve the item's value first and its key second.</p>"
                                }
                            ]
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 72,
                    "id": 116
                }, {
                    "active": false,
                    "body": "<p><code>can.extend(target, objectN)</code> merges the contents of two or more objects together into the first object\nsimilarly to [http://api.jquery.com/jQuery.extend/ jQuery.extend].</p>\n\n<pre><code class=\"lang-javascript\">var first = {},\nsecond = {a: \"b\"},\nthird = {c: \"d\"};\n\ncan.extend(first, second, third); //-> first\n\nfirst  //-> {a: \"b\", c: \"d\"}\nsecond //-> {a: \"b\"}\nthird  //-> {c: \"d\"}</code></pre>",
                    "description": "<p>Merge objects together. </p>",
                    "title": "",
                    "name": "can.extend",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.extend(target, ...obj)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "target",
                                    "description": "<p>The object to merge properties into.</p>"
                                }, {
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "obj",
                                    "description": "<p>Objects containing properties to merge.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p><strong>target</strong>, post-merge.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 96,
                    "id": 117
                }, {
                    "active": false,
                    "body": "<p><code>can.isArray(object)</code> returns if the object is an Array.</p>\n\n<pre><code class=\"lang-javascript\">can.isArray([]);    // true\ncan.isArray(false); // false</code></pre>",
                    "description": "<p>Check if an object is an array. </p>",
                    "title": "",
                    "name": "can.isArray",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.isArray(obj)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "*"
                                        }
                                    ],
                                    "name": "obj",
                                    "description": "<p>The object to check.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Boolean"
                                    }
                                ],
                                "description": "<p>Whether <strong>obj</strong> is an Array.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 55,
                    "id": 115
                }, {
                    "active": false,
                    "body": "<p><code>can.isDeferred</code> returns if an object is an instance of [can.Deferred].</p>\n\n<h2>Example</h2>\n\n<p>Convert any value to a Deferred:</p>\n\n<pre><code class=\"lang-javascript\">function convertDeferred(dfd) {\n    return can.isDeferred(dfd) ? dfd : can.Deferred(dfd);\n}</code></pre>",
                    "description": "<p>Check if an object is a Deferred. </p>",
                    "title": "",
                    "name": "can.isDeferred",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.isDeferred(subject)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "*"
                                        }
                                    ],
                                    "name": "subject",
                                    "description": "<p>The object to check.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Boolean"
                                    }
                                ],
                                "description": "<p>Whether <strong>subject</strong> is a Deferred.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 0,
                    "id": 112
                }, {
                    "active": false,
                    "body": "<p><code>can.isEmptyObject(obj)</code> returns if an object has no properties similar to\n[http://api.jquery.com/jQuery.isEmptyObject/ jQuery.isEmptyObject].</p>\n\n<pre><code class=\"lang-javascript\">can.isEmptyObject({})      //-> true\ncan.isEmptyObject({a:\"b\"}) //-> false</code></pre>",
                    "description": "<p>Check if an object has no properties. </p>",
                    "title": "",
                    "name": "can.isEmptyObject",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.isEmptyObject(obj)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "obj",
                                    "description": "<p>The object to check.</p>"
                                }, {
                                    "types": [{
                                            "type": "Boolean"
                                        }
                                    ],
                                    "name": "Whether",
                                    "description": "<p>the object is empty.</p>"
                                }
                            ]
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 139,
                    "id": 119
                }, {
                    "active": false,
                    "body": "<p><code>can.isFunction(object)</code> returns if an object is a function similar to\n[http://api.jquery.com/jQuery.isFunction/ jQuery.isFunction].</p>\n\n<pre><code class=\"lang-javascript\">can.isFunction({})           //-> false\ncan.isFunction(function(){}) //-> true</code></pre>",
                    "description": "<p>Check if an Object is a function. </p>",
                    "title": "",
                    "name": "can.isFunction",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.isFunction(obj)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "obj",
                                    "description": "<p>The object to check.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Boolean"
                                    }
                                ],
                                "description": "<p>Whether <strong>obj</strong> is a function.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 179,
                    "id": 121
                }, {
                    "active": false,
                    "body": "<p><code>can.makeArray(arrLike)</code> converts an array-like object into a array.</p>\n\n<pre><code class=\"lang-javascript\">can.makeArray({0 : \"zero\", 1: \"one\", length: 2}); // [\"zero\",\"one\"]</code></pre>",
                    "description": "<p>Convert an array-like object to an Array. </p>",
                    "title": "",
                    "name": "can.makeArray",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.makeArray(arrLike)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "arrLike",
                                    "description": "<p>An array-like object.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Array"
                                    }
                                ],
                                "description": "<p>The converted object.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 39,
                    "id": 114
                }, {
                    "active": false,
                    "body": "<p>Parameterizes an object into a query string\nlike [http://api.jquery.com/jQuery.param/ jQuery.param].</p>\n\n<pre><code class=\"lang-javascript\">can.param({a: \"b\", c: \"d\"}) //-> \"a=b&c=d\"</code></pre>",
                    "description": "<p>Serialize an object into a query string. </p>",
                    "title": "",
                    "name": "can.param",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.param(obj)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "obj",
                                    "description": "<p>An array or object to serialize.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "String"
                                    }
                                ],
                                "description": "<p>The serialized string.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 122,
                    "id": 118
                }, {
                    "active": false,
                    "body": "<p><code>can.proxy(fn, context)</code> accepts a function and returns a\nnew one that will always have the context from which it was\ncalled.  This works similar to [http://api.jquery.com/jQuery.proxy/ jQuery.proxy].</p>\n\n<pre><code class=\"lang-javascript\">var func = can.proxy(function(one){\n      return this.a + one\n    }, {a: \"b\"});\nfunc(\"two\") //-> \"btwo\"</code></pre>",
                    "description": "<p>Bind a function to its context. </p>",
                    "title": "",
                    "name": "can.proxy",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.proxy(fn, context)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": []
                                        }
                                    ],
                                    "name": "fn",
                                    "description": "<p>The function to bind to a context.</p>"
                                }, {
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "context",
                                    "description": "<p>The context to bind the function to.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "function",
                                        "returns": {
                                            "types": [{
                                                    "type": "undefined"
                                                }
                                            ]
                                        },
                                        "params": []
                                    }
                                ],
                                "description": "<p>A function that calls <strong>fn</strong> in the context of <strong>context</strong>.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 157,
                    "id": 120
                }, {
                    "active": false,
                    "body": "<p><code>can.remove( wrappedNodeList )</code> removes the set of matched element(s) from the DOM.</p>\n\n<pre><code class=\"lang-javascript\"><div id=\"wrap\"/>\ncan.remove(can.$('#wrap')) //-> removes 'wrap'</code></pre>",
                    "description": "<p>Remove elements from the DOM. </p>",
                    "title": "",
                    "name": "can.remove",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.remode(nodeList)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "NodeList"
                                        }
                                    ],
                                    "name": "nodeList",
                                    "description": "<p>A nodelist of elements to remove.</p>"
                                }
                            ]
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 452,
                    "id": 131
                }, {
                    "active": false,
                    "body": "",
                    "description": "<p>Trigger an event. </p>",
                    "title": "",
                    "name": "can.trigger",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.trigger(target, eventName[, args])",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "target",
                                    "description": "<p>The object to trigger the event on.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "eventName",
                                    "description": "<p>The event to trigger.</p>"
                                }, {
                                    "types": [{
                                            "type": "Array",
                                            "template": [{
                                                    "types": [{
                                                            "type": "*"
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ],
                                    "optional": true,
                                    "name": "args",
                                    "description": "<p>The event data.</p>\n\n<p>Trigger an event on an element or object.</p>"
                                }
                            ]
                        }
                    ],
                    "src": "can/util/util.js",
                    "line": 359,
                    "id": 126
                }, {
                    "active": false,
                    "body": "<p><code>can.trim(str)</code> removes leading and trailing whitespace from a string.  It will also\nremove all newlines, spaces including non-breaking, and tabs.  If these occur in the middle\nof the string, then they will be persisted.</p>\n\n<pre><code class=\"lang-javascript\">can.trim(\" foo \") // \"foo\"</code></pre>",
                    "description": "<p>Trim whitespace off a string. </p>",
                    "title": "",
                    "name": "can.trim",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.trim(str)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "str",
                                    "description": "<p>The string to trim.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "String"
                                    }
                                ],
                                "description": "<p>The trimmed string.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 21,
                    "id": 113
                }, {
                    "active": false,
                    "body": "<p><code>can.unbind(eventName, handler)</code> unbinds a callback handler\nfrom an object for a given event.  It works on:</p>\n\n<ul>\n<li>HTML elements and the window</li>\n<li>Objects</li>\n<li>Objects with bind / unbind methods</li>\n</ul>\n\n<p>The idea is that unbind can be used on anything that produces events\nand it will figure out the appropriate way to\nunbind to it.  Typically, <code>can.unbind</code> is only used internally to\nCanJS; however, if you are making libraries or extensions, use\n<code>can.bind</code> to listen to events independent of the underlying library.</p>\n\n<p><strong>Binding/unbinding to an object</strong></p>\n\n<pre><code class=\"lang-javascript\">var obj = {},\nhandler = function(ev, arg1, arg){\n       arg1 // 1\n       arg2 // 2\n     };\ncan.bind.call(obj,\"something\", handler)\ncan.trigger(obj,\"something\",[1,2])\ncan.unbind.call(obj,\"something\", handler)</code></pre>\n\n<p><strong>Binding/unbinding to an HTMLElement</strong></p>\n\n<pre><code class=\"lang-javascript\">var el = document.getElementById('foo'),\nhandler = function(ev){\n       this // el\n     };\ncan.bind.call(el, \"click\", handler)\ncan.unbind.call(el, \"click\", handler)</code></pre>",
                    "description": "<p>Stop listening for events on an object. </p>",
                    "title": "",
                    "name": "can.unbind",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.unbind.call(target, eventName, handler)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "target",
                                    "description": "<p>The object that emits events.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "eventName",
                                    "description": "<p>The name of the event to listen for.</p>"
                                }, {
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": []
                                        }
                                    ],
                                    "name": "handler",
                                    "description": "<p>The function to unbind.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p>The <strong>target</strong>.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 243,
                    "id": 123
                }, {
                    "active": false,
                    "body": "",
                    "description": "<p>Stop listening for events from the children of an element. </p>",
                    "title": "",
                    "name": "can.undelegate",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.undelegate.call(element, selector, eventName, handler)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "HTMLElement"
                                        }
                                    ],
                                    "name": "element",
                                    "description": "<p>The HTML element to unbind from.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "selector",
                                    "description": "<p>A selector for delegating downward.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "eventName",
                                    "description": "<p>The name of the event to listen for.</p>"
                                }, {
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": []
                                        }
                                    ],
                                    "name": "handler",
                                    "description": "<p>The function that was bound.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Object"
                                    }
                                ],
                                "description": "<p>The <strong>element</strong>.</p>\n\n<p><code>can.undelegate(selector, eventName, handler)</code> unbinds a delegate handler\non an object for a given event.  It works on:</p>\n\n<ul>\n<li>HTML elements and the window</li>\n</ul>\n\n<p>The idea is that undelegate can be used on anything that produces delegate events\nand it will figure out the appropriate way to\nbind to it.  Typically, <code>can.undelegate</code> is only used internally to\nCanJS; however, if you are making libraries or extensions, use\n<code>can.undelegate</code> to listen to events independent of the underlying library.</p>\n\n<p><strong>Delegate/undelegate binding to an HTMLElement</strong></p>\n\n<pre><code class=\"lang-javascript\">var el = document.getElementById('foo'),\nhandler = function(ev){\n  this // el\n};\ncan.delegate.call(el, \".selector\", \"click\", handler)\ncan.undelegate.call(el, \".selector\", \"click\", handler)</code></pre>"
                            }
                        }
                    ],
                    "src": "can/util/util.js",
                    "line": 325,
                    "id": 125
                }, {
                    "active": false,
                    "body": "<p><code>can.when(deferred)</code> provides the ability to execute callback function(s)\ntypically based on a Deferred or AJAX object.</p>\n\n<pre><code class=\"lang-javascript\">can.when( can.ajax('api/farm/animals') ).then(function(animals){\n     alert(animals); //-> alerts the ajax response\n});</code></pre>\n\n<p>You can also use this for regular JavaScript objects.</p>\n\n<pre><code class=\"lang-javascript\">$.when( { animals: [ 'cat' ] } ).done(function(animals){\n    alert(animals[0]); //-> alerts 'cat'\n});</code></pre>",
                    "description": "<p>Call a callback when a Deferred resolves. </p>",
                    "title": "",
                    "name": "can.when",
                    "type": "function",
                    "parent": "can.util",
                    "signatures": [{
                            "code": "can.when(deferred)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Deferred"
                                        }, {
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "deferred",
                                    "description": "<p>The Deferred, AJAX, or normal Objects to call the callback on.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "Deferred"
                                    }
                                ],
                                "description": "<p><strong>deferred</strong> if <strong>deferred</strong> is a Deferred,\notherwise a Deferred that resolves to <strong>deferred</strong>.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/util/util.js",
                    "line": 543,
                    "id": 134
                }
            ]
        }, {
            "active": false,
            "type": "constructor",
            "name": "can.view",
            "body": "",
            "description": "",
            "title": "",
            "parent": "canjs",
            "signatures": [{
                    "code": "can.view(view, data, helpers)",
                    "description": "",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "name": "view",
                            "description": "<p>The URL to a template or the ID of a template.</p>"
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "data",
                            "description": "<p>Data to populate the template with.</p>"
                        }, {
                            "types": [{
                                    "type": "Object",
                                    "template": [{
                                            "types": [{
                                                    "type": "String"
                                                }
                                            ]
                                        }, {
                                            "types": [{
                                                    "type": "function",
                                                    "returns": {
                                                        "types": [{
                                                                "type": "undefined"
                                                            }
                                                        ]
                                                    },
                                                    "params": []
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ],
                            "name": "helpers",
                            "description": "<p>Helpers referenced in the template.</p>"
                        }
                    ],
                    "returns": {
                        "types": [{
                                "type": "String"
                            }
                        ],
                        "description": "<p>The template with the data interpolated into it.</p>"
                    }
                }
            ],
            "comment": " ",
            "src": "can/view/view.md",
            "id": 97,
            "children": [{
                    "active": false,
                    "name": "can.view.cache",
                    "type": "property",
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>By default, views are cached on the client.  If you'd like the\nthe views to reload from the server, you can set the <code>cache</code> attribute to <code>false</code>.</p>\n\n<pre><code>    //- Forces loads from server\n    can.view.cache = false; \n</code></pre>",
                    "types": [{
                            "type": "Boolean"
                        }
                    ],
                    "title": "cache",
                    "src": "can/view/view.js",
                    "line": 214,
                    "id": 103
                }, {
                    "active": false,
                    "name": "can.view.cached",
                    "type": "property",
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>Cached are put in this object</p>",
                    "types": [{
                            "type": "Object"
                        }
                    ],
                    "title": "cached",
                    "hide": true,
                    "src": "can/view/view.js",
                    "line": 205,
                    "id": 102
                }, {
                    "active": false,
                    "body": "<p><code>can.view.ejs([id,] template)</code> registers an EJS template string \nfor a given id programatically. The following\nregisters <code>myViewEJS</code> and renders it into a documentFragment.</p>\n\n<pre><code> can.view.ejs('myViewEJS', '&lt;h2&gt;&lt;%= message %&gt;&lt;/h2&gt;');\n\n var frag = can.view('myViewEJS', {\n     message : 'Hello there!'\n });\n\n frag // -&gt; &lt;h2&gt;Hello there!&lt;/h2&gt;\n</code></pre>\n\n<p>To convert the template into a render function, just pass \nthe template. Call the render function with the data\nyou want to pass to the template and it returns the \ndocumentFragment.</p>\n\n<pre><code> var renderer = can.view.ejs('&lt;div&gt;&lt;%= message %&gt;&lt;/div&gt;');\n renderer({\n     message : 'EJS'\n }); // -&gt; &lt;div&gt;EJS&lt;/div&gt;\n</code></pre>",
                    "description": "<p>Register an EJS template string or create a renderer function. </p>",
                    "title": "",
                    "name": "can.view.ejs",
                    "type": "function",
                    "parent": "can.view",
                    "signatures": [{
                            "code": "can.view.ejs(id, template)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "id",
                                    "description": "<p>An ID for the template.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "template",
                                    "description": "<p>An EJS template in string form.</p>"
                                }
                            ]
                        }, {
                            "code": "can.view.ejs(template)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "template",
                                    "description": "<p>An EJS template in string form.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "function",
                                        "returns": {
                                            "types": [{
                                                    "type": "undefined"
                                                }
                                            ]
                                        },
                                        "params": []
                                    }
                                ],
                                "description": "<p>A renderer function that takes data and helpers.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/view/view.js",
                    "line": 103,
                    "id": 98
                }, {
                    "active": false,
                    "name": "can.view.ext",
                    "type": "property",
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>The default suffix to use if none is provided in the view's url. <br />\nThis is set to <code>.ejs</code> by default.</p>\n\n<pre><code>    // Changes view ext to 'txt'\n    can.view.ext = 'txt';\n</code></pre>",
                    "types": [{
                            "type": "String"
                        }
                    ],
                    "title": "ext",
                    "src": "can/view/view.js",
                    "line": 267,
                    "id": 105
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.view.hook",
                    "parent": "can.view",
                    "body": "<p>Registers a hookup function that can be called back after the html is \nput on the page.  Typically this is handled by the template engine.  Currently\nonly EJS supports this functionality.</p>\n\n<pre><code>var id = can.view.hook(function(el){\n       //do something with el\n    }),\n    html = \"&lt;div data-view-id='\"+id+\"'&gt;\"\n$('.foo').html(html);\n</code></pre>",
                    "description": "<p>Create a hookup to insert into templates. </p>",
                    "title": "hook",
                    "signatures": [{
                            "code": "can.view.hook(callback)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": []
                                        }
                                    ],
                                    "name": "callback",
                                    "description": "<p>A callback function to be called with the element.</p>"
                                }
                            ]
                        }
                    ],
                    "comment": " ",
                    "src": "can/view/view.js",
                    "line": 183,
                    "id": 101
                }, {
                    "active": false,
                    "body": "",
                    "description": "<p>Register a Mustache template string or create a renderer function. </p>",
                    "title": "",
                    "name": "can.view.mustache",
                    "type": "function",
                    "parent": "can.view",
                    "signatures": [{
                            "code": "can.view.mustache(id, template)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "id",
                                    "description": "<p>An ID for the template.</p>"
                                }, {
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "template",
                                    "description": "<p>A Mustache template in string form.</p>"
                                }
                            ]
                        }, {
                            "code": "can.view.mustache(template)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }
                                    ],
                                    "name": "template",
                                    "description": "<p>A Mustache template in string form.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "function",
                                        "returns": {
                                            "types": [{
                                                    "type": "undefined"
                                                }
                                            ]
                                        },
                                        "params": []
                                    }
                                ],
                                "description": "<p>A renderer function that takes data and helpers.</p>\n\n<p><code>can.view.mustache([id,] template)</code> registers an Mustache template string \nfor a given id programatically. The following\nregisters <code>myStache</code> and renders it into a documentFragment.</p>\n\n<pre><code> can.view.ejs('myStache', '&lt;h2&gt;{{message}}&lt;/h2&gt;');\n\n var frag = can.view('myStache', {\n     message : 'Hello there!'\n });\n\n frag // -&gt; &lt;h2&gt;Hello there!&lt;/h2&gt;\n</code></pre>\n\n<p>To convert the template into a render function, just pass \nthe template. Call the render function with the data\nyou want to pass to the template and it returns the \ndocumentFragment.</p>\n\n<pre><code> var renderer = can.view.mustache('&lt;div&gt;{{message}}&lt;/div&gt;');\n renderer({\n     message : 'Mustache'\n }); // -&gt; &lt;div&gt;Mustache&lt;/div&gt;\n</code></pre>"
                            }
                        }
                    ],
                    "src": "can/view/view.js",
                    "line": 140,
                    "id": 99
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.view.preload",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "name": "id",
                            "description": ""
                        }, {
                            "types": [{
                                    "type": "function",
                                    "returns": {
                                        "types": [{
                                                "type": "undefined"
                                            }
                                        ]
                                    },
                                    "params": []
                                }
                            ],
                            "name": "renderer",
                            "description": ""
                        }
                    ],
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>Called by a production script to pre-load a renderer function\ninto the view cache.</p>",
                    "hide": true,
                    "src": "can/view/view.js",
                    "line": 287,
                    "id": 107
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.view.register",
                    "parent": "can.view",
                    "body": "<p>Registers a template engine to be used with \nview helpers and compression.  </p>\n\n<h2>Example</h2>\n\n<pre><code class=\"lang-javascript\">can.View.register({\n    suffix : \"tmpl\",\n plugin : \"jquery/view/tmpl\",\n    renderer: function( id, text ) {\n        return function(data){\n            return jQuery.render( text, data );\n        }\n    },\n    script: function( id, text ) {\n        var tmpl = can.tmpl(text).toString();\n        return \"function(data){return (\"+\n            tmpl+\n            \").call(jQuery, jQuery, data); }\";\n    }\n})</code></pre>     ",
                    "description": "<p>Register a templating language. </p>",
                    "title": "",
                    "signatures": [{
                            "code": "can.view.register(info)",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "Object",
                                            "options": [{
                                                    "name": "plugin",
                                                    "description": "The location of the templating language's plugin.",
                                                    "types": [{
                                                            "type": "String"
                                                        }
                                                    ]
                                                }, {
                                                    "name": "suffix",
                                                    "description": "Files with this suffix will use this templating language's plugin by default.",
                                                    "types": [{
                                                            "type": "String"
                                                        }
                                                    ]
                                                }, {
                                                    "name": "renderer",
                                                    "description": "A function that returns a function that, given data, will render the template with that data.\nThe __renderer__ function receives the id of the template and the text of the template.",
                                                    "types": [{
                                                            "type": "function",
                                                            "returns": {
                                                                "types": [{
                                                                        "type": "undefined"
                                                                    }
                                                                ]
                                                            },
                                                            "params": []
                                                        }
                                                    ]
                                                }, {
                                                    "name": "script",
                                                    "description": "A function that returns the string form of the processed template.\n",
                                                    "types": [{
                                                            "type": "function",
                                                            "returns": {
                                                                "types": [{
                                                                        "type": "undefined"
                                                                    }
                                                                ]
                                                            },
                                                            "params": []
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ],
                                    "name": "info",
                                    "description": "<p>Information about the templating language.</p>"
                                }
                            ]
                        }
                    ],
                    "comment": " ",
                    "src": "can/view/view.js",
                    "line": 226,
                    "id": 104
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.view.registerScript",
                    "params": [{
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "type",
                            "description": ""
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "id",
                            "description": ""
                        }, {
                            "types": [{
                                    "type": "Object"
                                }
                            ],
                            "name": "src",
                            "description": ""
                        }
                    ],
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>Returns the text that </p>",
                    "hide": true,
                    "src": "can/view/view.js",
                    "line": 278,
                    "id": 106
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.view.registerView",
                    "params": [{
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "name": "id",
                            "description": ""
                        }, {
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "name": "text",
                            "description": ""
                        }, {
                            "types": [{
                                    "type": "String"
                                }
                            ],
                            "name": "type",
                            "description": ""
                        }, {
                            "types": [{
                                    "type": "can.Deferred"
                                }
                            ],
                            "name": "def",
                            "description": ""
                        }
                    ],
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>Registers a view with <code>cached</code> object.  This is used\ninternally by this class and Mustache to hookup views.</p>",
                    "hide": true,
                    "src": "can/view/view.js",
                    "line": 448,
                    "id": 109
                }, {
                    "active": false,
                    "type": "function",
                    "name": "can.view.render",
                    "parent": "can.view",
                    "body": "<p><code>can.view.render(view, [data], [helpers], callback)</code> returns the rendered markup produced by the corresponding template\nengine as String. If you pass a deferred object in as data, render returns\na deferred resolving to the rendered markup.</p>\n\n<p><code>can.view.render</code> is commonly used for sub-templates.</p>\n\n<h2>Example</h2>\n\n<p><em>welcome.ejs</em> looks like:</p>\n\n<pre><code>&lt;h1&gt;Hello &lt;%= hello %&gt;&lt;/h1&gt;\n</code></pre>\n\n<p>Render it to a string like:</p>\n\n<pre><code>can.view.render(\"welcome.ejs\",{hello: \"world\"})\n  //-&gt; &lt;h1&gt;Hello world&lt;/h1&gt;\n</code></pre>\n\n<h2>Use as a Subtemplate</h2>\n\n<p>If you have a template like:</p>\n\n<pre><code>&lt;ul&gt;\n  &lt;% list(items, function(item){ %&gt;\n    &lt;%== can.view.render(\"item.ejs\",item) %&gt;\n  &lt;% }) %&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<h2>Using renderer functions</h2>\n\n<p>If you only pass the view path, `can.view will return a renderer function that can be called with\nthe data to render:</p>\n\n<pre><code>var renderer = can.view.render(\"welcome.ejs\");\n// Do some more things\nrenderer({hello: \"world\"}) // -&gt; Document Fragment\n</code></pre>",
                    "description": "<p>Render a template. </p>",
                    "title": "",
                    "signatures": [{
                            "code": "can.view.render(template[, callback])",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }, {
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "view",
                                    "description": "<p>The path of the view template or a view object.</p>"
                                }, {
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": []
                                        }
                                    ],
                                    "optional": true,
                                    "name": "callback",
                                    "description": "<p>A function executed after the template has been processed.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "function",
                                        "returns": {
                                            "types": [{
                                                    "type": "undefined"
                                                }
                                            ]
                                        },
                                        "params": []
                                    }, {
                                        "type": "can.Deferred"
                                    }
                                ],
                                "description": "<p>A renderer function to be called with data and helpers\nor a Deferred that resolves to a renderer function.</p>"
                            }
                        }, {
                            "code": "can.view.render(template, data[, [helpers,] callback])",
                            "description": "",
                            "params": [{
                                    "types": [{
                                            "type": "String"
                                        }, {
                                            "type": "Object"
                                        }
                                    ],
                                    "name": "view",
                                    "description": "<p>The path of the view template or a view object.</p>"
                                }, {
                                    "types": [{
                                            "type": "Object"
                                        }
                                    ],
                                    "optional": true,
                                    "name": "data",
                                    "description": "<p>The data to populate the template with.</p>"
                                }, {
                                    "types": [{
                                            "type": "Object",
                                            "template": [{
                                                    "types": [{
                                                            "type": "String"
                                                        }
                                                    ]
                                                }, {
                                                    "types": [{
                                                            "type": "function",
                                                            "returns": {
                                                                "types": [{
                                                                        "type": "undefined"
                                                                    }
                                                                ]
                                                            },
                                                            "params": []
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ],
                                    "optional": true,
                                    "name": "helpers",
                                    "description": "<p>Helper methods referenced in the template.</p>"
                                }, {
                                    "types": [{
                                            "type": "function",
                                            "returns": {
                                                "types": [{
                                                        "type": "undefined"
                                                    }
                                                ]
                                            },
                                            "params": []
                                        }
                                    ],
                                    "optional": true,
                                    "name": "callback",
                                    "description": "<p>A function executed after the template has been processed.</p>"
                                }
                            ],
                            "returns": {
                                "types": [{
                                        "type": "String"
                                    }, {
                                        "type": "can.Deferred"
                                    }
                                ],
                                "description": "<p>The template with interpolated data in string form\nor a Deferred that resolves to the template with interpolated data.</p>"
                            }
                        }
                    ],
                    "comment": " ",
                    "src": "can/view/view.js",
                    "line": 296,
                    "id": 108
                }, {
                    "active": false,
                    "name": "can.view.text",
                    "type": "property",
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>should return something like steal(\"dependencies\",function(EJS){\n     return can.view.preload(\"ID\", options.text)\n})</p>",
                    "hide": true,
                    "src": "can/view/view.js",
                    "line": 593,
                    "id": 110
                }, {
                    "active": false,
                    "name": "hookups",
                    "type": "property",
                    "parent": "can.view",
                    "body": "",
                    "description": "<p>A list of pending 'hookups'</p>",
                    "title": "",
                    "hide": true,
                    "src": "can/view/view.js",
                    "line": 176,
                    "id": 100
                }
            ]
        }
    ]
}