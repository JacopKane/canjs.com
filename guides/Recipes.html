<!DOCTYPE html>

<!--[if lt IE 7]>
<html class="no-js ie lt-ie9 lt-ie8 lt-ie7" lang="en">
<![endif]-->
<!--[if IE 7]>
<html class="no-js ie lt-ie9 lt-ie8" lang="en">
<![endif]-->
<!--[if IE 8]>
<html class="no-js ie lt-ie9" lang="en">
<![endif]-->
<!--[if IE 9]>
<html class="no-js ie ie9" lang="en">
<![endif]-->
<!--[if gt IE 9]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->
<head>
	<meta charset="utf-8">
	<title>CanJS </title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="">
	<meta name="author" content="">

	<link rel="stylesheet" type="text/css" href="../resources/styles.css" />
</head>

<body class="guides">
	<header>
		<nav class="container">

			<div class="logo-menu">
				<a class="brand canjs" href="../index.html">CanJS</a>
				<ul class="dropdown-menu">
					<li><a href="http://donejs.com">DoneJS</a></li>
					<li class="active"><a href="../index.html">CanJS</a></li>
					<li><a href="http://jquerypp.com">JQuery++</a></li>
					<li><a href="http://javascriptmvc.com/docs.html#!stealjs">StealJS</a></li>
					<li><a href="http://javascriptmvc.com/docs.html#!FuncUnit">FuncUnit</a></li>
					<li><a href="http://javascriptmvc.com/docs.html#!DocumentJS">DocumentJS</a></li>
				</ul>
			</div>

			<ul class="nav">
				<li class=""><a href="../index.html">Home</a></li>
				<li class="active"><a href="../guides/index.html">Guides</a></li>
				<li class=""><a href="../docs/index.html">Api</a></li>
				<li class=""><a href="../community.html">Community</a></li>
				<li class=""><a href="../download.html">Download</a></li>
			</ul>

			<div class="pull-right">
				<div class="bitovi-menu">
					<a href="http://bitovi.com" class="bitovi icon-bits">Bitovi</a>
					<ul class="dropdown-menu">
						<li><a href="http://bitovi.com">Bitovi.com</a></li>
						<li><a href="http://bitovi.com/blog/">Blog</a></li>
						<li><a href="http://bitovi.com/consulting/">Consulting</a></li>
						<li><a href="http://bitovi.com/training/">Training</a></li>
						<li><a href="http://bitovi.com/open-source/">Open Source</a></li>
						<li><a href="http://bitovi.com/people/">People</a></li>
						<li><a href="http://bitovi.com/contact/">Contact Us</a></li>
					</ul>
				</div>
			</div>
		</nav>
	</header>

	<div class="container api">
	<nav class="sidebar">
		<div class="search">
			<input type="text"/>
		</div>
		<ul class="api">
	
	<li class="active">
	<a href="Recipes.html">Recipes</a>
	
		
	
	</li>
	
	<li >
	<a href="Tutorial.html">Tutorial</a>
	
	</li>
	
</ul>
	</nav>

	<article class="content docs">
		<section class="title">
			<div class="pull-right">
	<ul class="tags">
		<li>page</li>
	</ul>
	<ul class="links">
		
			<li><a href="https://github.com/bitovi/canjs/tree/v1.1.5/../_guides/recipes.md">source</a></li>
		
		
		
	</ul>
</div>

	<h1>CanJS Recipes</h1><!-- <span class="module">Recipes</span>-->




		</section>

		<section class="description">
			
		</section>

		

		
		<section class="comment">
			<p>The following is a list of <strong>CanJS</strong> recipes to help you learn CanJS.  To
add your own, simply <a href="https://github.com/bitovi/canjs/edit/gh-pages/recipes.md">edit this file</a>. To
help create a JSFiddle, we've created the following fiddles you can fork:</p>

<ul>
<li><a href="http://jsfiddle.net/donejs/qYdwR/">jQuery and CanJS</a></li>
<li><a href="http://jsfiddle.net/donejs/7Yaxk/">Zepto and CanJS</a></li>
<li><a href="http://jsfiddle.net/donejs/9x96n/">Dojo and CanJS</a></li>
<li><a href="http://jsfiddle.net/donejs/w6m73/">YUI and CanJS</a></li>
<li><a href="http://jsfiddle.net/donejs/mnNJX/">Mootools and CanJS</a></li>
</ul>

<h2>Controls</h2>

<p>The following recipes explore making UI widgets with <code>can.control</code>.</p>

<h3>Tabs</h3>

<p>The following recipes builds a simple tabs widget.</p>

<iframe style="width: 100%; height: 300px" 
        src="http://jsfiddle.net/wSaGm/1/embedded/result,html,js,css" 
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<h4>How it works</h4>

<p>It creates a <code>Tabs</code> constructor function that shows and hides tabs
when it's <code>&lt;li&gt;</code>'s are clicked.</p>

<p>When <code>new Tabs()</code> is called, it adds <code>active</code> to the first <code>&lt;li&gt;</code>'s 
className. Then, using the <code>tab</code> helper function, it hides the content for 
all the other tab buttons.</p>

<pre><code class="lang-javascript">&lt;li>&lt;a href="#model">Model&lt;/a>&lt;/li></code></pre>

<p>Then gets it's <code>&lt;a&gt;</code> element, and then uses it's href (<code>#model</code>) to get the
content div for that button.</p>

<p>When a button is clicked, <code>Tabs</code> listens to it with:</p>

<pre><code class="lang-javascript">"li click" : function( el, ev ) { ... }</code></pre>

<p>This function, using the <code>tab</code> helper deactivates the active tab button and hides its content, 
then it activates and shows the new tab button and tab content.</p>

<h3>Tooltip</h3>

<p>The following recipe builds a simple tooltip.  It shows templated event binding and we will
explain how it keeps memory leaks from happening. Click on one of the items
to see a tooltip, click somewhere else to remove it.</p>

<iframe style="width: 100%; height: 300px" 
        src="http://jsfiddle.net/imjoshdean/2VQSb/embedded/result,html,js,css" 
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<h4>How it works</h4>

<p>This creates a <code>Tooltip</code> control that when created shows a tooltip.  When a <code>Tooltip</code> control
is created, it positions the <code>Tooltip</code> element relative to the <code>relativeTo</code> option and 
sets its inner html to the <code>html</code> option.</p>

<p>The tooltip also listens to clicks on the window.  If the user clicked on something other than the
<code>relativeTo</code> element and the tooltip element, it will remove the tooltip from the document.</p>

<p>When an element is removed from the DOM with any controls on it, the control's event handlers
are automatically removed.  Templated event binding lets us listen to events outside 
the element.  <code>"{window} click"</code> is a templated event binding.</p>

<p>Events outside an element would normally not be removed, but they are with <code>can.Control</code>.</p>

<h3>TreeCombo</h3>

<p>Select multiple items in a tree-like structure. This control uses <code>can.Observe.List</code> and <code>can.compute</code>
in a smart way to manage the state of the widget.</p>

<iframe style="width: 100%; height: 300px" 
        src="http://jsfiddle.net/sTLhX/35/embedded/result,html,js,css" 
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<p><a href="http://bitovi.com/blog/2013/01/weekly-widget-tree-combo.html">How it works</a></p>

<h2>Routing</h2>

<p>The following recipes explore using <code>can.route</code>.</p>

<h3>History Tabs</h3>

<p>This recipe shows how to make a history-based tabs widget and have routes
configured independently by can.route.</p>

<iframe style="width: 100%; height: 300px" 
        src="http://jsfiddle.net/Z9Cv5/2/embedded/result,html,js,css" 
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<h4>How it works</h4>

<p>The HTML is structured such that each tab button has an <code>&lt;a&gt;</code> element with an 
href property that matches the <code>id</code> attribute of the tab content 
panel it should show.  This means that even if JavaScript was disabled,
clicking a button would send the user to the tab panel (even though
HistoryTabs overwrites this behavior).</p>

<p>For example:</p>

<pre><code class="lang-javascript">&lt;li>&lt;a href="#model">can.Model&lt;/a>&lt;/li></code></pre>

<p>references:</p>

<pre><code class="lang-javascript">&lt;div id="model" class="tab"></code></pre>

<p>The JavaScript code begins by creating a <code>HistoryTabs</code> 
control.  When a new <code>HistoryTabs</code> instance is created, it gets
an <strong>attr</strong> option like:</p>

<pre><code class="lang-javascript">new HistoryTabs( '#components',{attr: 'component'});</code></pre>

<p>The <strong>attr</strong> method is used to configure which part of <code>can.route</code>'s data the 
history tab will be listening to.  </p>

<p>When <code>init</code> is called, it hides each tab button's content div, looking up
the content div with the <code>tab</code> helper method.  It then reads the current 
active tab with:</p>

<pre><code class="lang-javascript">var active = can.route.attr(this.options.attr);</code></pre>

<p>It passes that value to the <code>active</code> helper which will hide the old active
content (if <code>oldActive</code> is passed) and activate the new active button and
show it's content.</p>

<p><code>HistoryTab</code> updates the active tab by listening when a tab button is clicked with
<code>"li click"</code>.  It prevents the default behavior (which is changing the hash) and
updates it's route data attribute with the select tab's id:</p>

<pre><code class="lang-javascript">can.route.attr(this.options.attr, this.tab(el)[0].id)</code></pre>

<p><code>HistoryTabs</code> listens to these route changes with <code>"{can.route} {attr}"</code> and activates
the new tab.</p>

<p><strong>Configuring Routes</strong></p>

<p>The code ends by configuring the routes and creating the <code>HistoryTabs</code>.  Here's what each
route rule means:</p>

<pre><code class="lang-javascript">can.route(":component",{
  component: "model",
  person: "mihael"
});</code></pre>

<p>This matches the empty routes <code>("","#","#!")</code>, and a single "word" route.  If the route
is one of the empty routes, the route data will look 
like: <code>{component: "modal", person: "mihael"}</code>.  If it is a single "word" route like
<code>"#!view"</code>, the data will look like:  <code>{component: "view", person: "mihael"}</code>.</p>

<pre><code class="lang-javascript">can.route(":component/:person",{
  component: "model",
  person: "mihael"
});</code></pre>

<p>This matches two-word routes seperated by a slash ("/").  Each word can be empty. If both
words are empty "#!/", the data will look 
like: <code>{component: "model", person: "mihael"}</code>.  If the words are non-empty, that word
will replace the default value.</p>

<h3>Observe Backed Routes</h3>

<p>This recipe shows how to have multiple widgets listening on 
overlapping parts of the route. The app lets the user select a type of issue, show issues for that type,
and select a issue and see details about that issue.</p>

<iframe style="width: 100%; height: 300px" 
        src="http://jsfiddle.net/2UL6R/1/embedded/result,html,js,css" 
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<h4>How it works</h4>

<p>This functionality is broken down 
into <strong>Nav</strong>, <strong>Issues</strong>, and <strong>Details</strong> can.controls.  Here's how
each part works:</p>

<p><code>Nav</code> creates links using <code>can.route.link</code> that update the hash like:</p>

<pre><code class="lang-javascript">&lt;%== can.route.link("Critical",{filter: "critical"}) %></code></pre>

<p>When these are clicked on, they update the route's filter data.  </p>

<p><code>Issues</code> listens to filter changes like:</p>

<pre><code class="lang-javascript">"{can.route} filter" : function(route, ev, filter){ ... }</code></pre>

<p>It then retrieve's issue with <code>Issue.findAll</code> and renders 
them into the <code>#issues</code> element.</p>

<p>When an issue is clicked, <code>Issues</code> updates the route's issue data like:</p>

<pre><code class="lang-javascript">can.route.attr("issue", issue.id)</code></pre>

<p>It listens to changes in <code>issue</code> data and highlights the corresponding
issue in the list like:</p>

<pre><code class="lang-javascript">"{can.route} issue" : function(route, ev, issue){ ... }</code></pre>

<p><code>Details</code> listens to issue chagnes like:</p>

<pre><code class="lang-javascript">"{can.route} issue" : function(route, ev, issue){ ... }</code></pre>

<p>And updates the details panel.</p>

<h2>Live Binding</h2>

<p>The following recipes show how to use <code>can.EJS</code>'s live binding.</p>

<h3>Updating timestamps</h3>

<p>The following shows how to create an automatically updating <code>prettyDate</code>
helper for EJS that can be used like:</p>

<pre><code class="lang-javascript">&lt;%= prettyDate( new Date() ) %></code></pre>

<p>Notice how the <em>created</em> value changes every couple min or 
so. </p>

<p>The <code>prettyDate</code> method works with or without live-binding.  It doesn't need to take
an observe, just a date.  Code with EJS becomes live naturally ... amazing.</p>

<iframe style="width: 100%; height: 300px" 
        src="http://jsfiddle.net/qYdwR/36/embedded/result,html,js,css" 
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<h3>2-way binding Mustache helpers</h3>

<p>Learn how to make 2-way binding mustache helpers.  When you change the value of an input, it automatically
changes the value of an observe.  When you change the value of the observe, it changes the value of the 
input.</p>

<iframe style="width: 100%; height: 300px" 
        src="http://jsfiddle.net/ztWS5/5/embedded/result,html,js,css" 
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<p><a href="http://bitovi.com/blog/2013/01/weekly-widget-two-way-mustache-helpers.html">How it works</a></p>

<h2>Models</h2>

<p>The following recipes show how to use <code>can.Model</code> (and often the <code>can.fixture</code> plugin).</p>

<h3>Showing the same data in 2 places</h3>

<p>The following recipe shows how <code>can.Model</code>'s internal store and <code>can.view</code>'s live-binding
can easily solve the editing-data-that-is-represented-two-places problem.  It 
shows two task lists of overlaping data.  Notice how the <strong>"do dishes"</strong> is listed 
twice. But if you click one "do dishes" checkbox, it updates the other.</p>

<iframe style="width: 100%; height: 300px"
        src="http://jsfiddle.net/moschel/pCtxs/15/embedded/result,html,js,css" 
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<h4>How it works</h4>

<p>The code first sets up a <code>can.fixture</code> to return different, but overlapping lists of 
tasks from the server.  The fixture returns data from the following calls:</p>

<ul>
<li><code>/tasks?due=today</code></li>
<li><code>/tasks?type=critical</code></li>
</ul>

<p>You'll notice "do dishes" in both lists.</p>

<p>The code then creates a <code>Task</code> model that maps findAll to <code>/tasks</code>.  It then uses
<code>can.view</code> to render the retrieved tasks with the <code>tasksEJS</code> template. </p>

<p>Finally, it listens when an <code>input</code> element's value changes.  When it does,
it gets the task model instance from the <code>li</code> element's <code>$.data</code> and 
updates it's "complete" property.</p>

<p><strong><em>The Secret Sauce</em></strong></p>

<p>Model keeps an internal, non-leaking, store of instances your app loads.  When
<code>Task.findAll({type: "critical"})</code> and <code>Task.findAll({due: "today"})</code> get their
raw JSON data from the server, they convert it to instances.  But before they create
a new instance, they check if the same instance, matched by 
the <a href="http://donejs.com/docs.html#!can.Model.static.id">id</a> property already exists.  If it
does, it uses that instance. </p>

<p>This means that the <code>criticalTasks</code> list and <code>todaysTasks</code> list both point to the 
same instance. When <code>can.EJS</code> does it's live binding on <code>&lt;%= task.attr("complete") ? "checked" : "" %&gt;</code>
it's actually binding on the same "do dishes" intance once.  So updating "do dishes" updates
the DOM in two places!</p>

<h3>Caching Data in Local Storage</h3>

<p>The following recipe shows how <code>can.Model</code> can be used to create an ORM-like 
model layer for keeping a local copy of a restful API. This type of base model
is perfect for situations where you want a responsive UI, but may not want to 
wait for updates from the server before displaying data, or you need to make 
your data persist offline. Storing your responses in <code>localStorage</code> allows you 
to get data to the view as quickly as possible.</p>

<iframe style="width: 100%; height: 300px" 
        src="http://jsfiddle.net/moschel/73Xuk/14/embedded/result%2Cjs/" 
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<h4>How it works</h4>

<p>When creating your base model for other models to extend from, you can prefix 
static service methods with <code>make</code>, to allow the base model to define how the 
extending model's method will behave. In this example, our base model implements
a static method called <code>makeFindOne</code>. This method acts as a hook to define the 
extending model's <code>findOne</code> method. Using this, we can create a middleware-like
layer between the extending model and the base model that loads and saves model
data to <code>localStorage</code>, while still requesting out to the restful API to get 
updates.</p>

<p><strong><em>The Secret Sauce</em></strong></p>

<p>The secret sauce for this example is the static <code>makeFindOne</code> method along with
EJS's live binding. Because the live binding will automatically update the view when the 
bound model gets updated, we can write our code as usual and allow the base model
to deliver <code>localStorage</code> data instantly, while automatically upating with responses
from the server, with no extra effort.</p>

<h3>Real Time Chat</h3>

<p>Type a message in one page, it instantly shows up in the other.</p>

<iframe style="width: 100%; height: 300px" 
        src="http://jsfiddle.net/fbasrawala/yRMSa/embedded/result%2Cjs/" 
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<iframe style="width: 100%; height: 300px" 
        src="http://jsfiddle.net/fbasrawala/yRMSa/embedded/result%2Cjs/" 
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<p><a href="http://bitovi.com/blog/2013/02/weekly-widget-chat.html">How it works</a></p>

<h2>Everything Together</h2>

<p>The following recipes show a bunch of functionality working together.</p>

<h3>Basic Todo</h3>

<p>This recipe demonstrates the very basic todo app covered on [http://canjs.us]. You
can select a todo and edit it's text.  You can also delete a todo.  The app is
also history enabled, letting you move forward and back through different todos.</p>

<iframe style="width: 100%; height: 300px" 
        src="http://jsfiddle.net/moschel/5zpFz/94/embedded/result,html,js,css"
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<h4>How it works</h4>

<iframe width="640" height="480" src="http://www.youtube.com/embed/PfTbkzh07iE" 
frameborder="0" allowfullscreen="allowfullscreen">YouTube</iframe>

<p>The app starts by creating a <code>Todo</code> model that connects to a dummy data 
store (just an array). The <code>findAll</code>, <code>findOne</code>, <code>update</code> and <code>destroy</code> methods
simply returning the required deferreds.</p>

<p>It then creates a <code>Todos</code> control that manages a list of <code>todos</code>.  When a new Todos control is created
on an element via <code>new Todos("#todos")</code> it uses the <code>Todo</code> model to findAll todo instances,
renders them with <code>todosEJS</code> and inserts them into the <code>Todos</code> control instance's element.</p>

<p>The template <code>todosEJS</code> iterates through each todo instance using <code>list</code>.  For each todo,
it creates an <code>&lt;li&gt;</code> element.  It adds the instance's data to the <code>&lt;li&gt;</code> element's <code>$.data</code> 
with: <code>&lt;%= (el) -&gt; el.data('todo',todo) %&gt;</code>.  Within each <code>&lt;li&gt;</code> it creates a
checkbox, span to contain the name, and destroy link.  EJS's live-binding will be used to
update the checkbox's <code>checked</code> attribute, the span's class attribute, and the span's content.</p>

<p><code>Todos</code> also binds on various events such as <code>"li click"</code>, <code>"li .complete click"</code>, and 
<code>"li .destroy click"</code>. Here's what they do:</p>

<p><code>"li click"</code> triggers a synthetic <strong>selected</strong> event on the li clicked 
with the model data. This is a great technique for making reusable event-based widgets.  This
<strong>selected</strong> event is listened to by the <code>Routing</code> control.</p>

<p><code>"li .complete click"</code> gets the todo instance clicked from <code>$.data</code> and updates 
it's <strong>complete</strong> property.  EJSs live-binding will take care of updating the DOM for you.</p>

<p><code>"li .destroy click"</code> gets the todo instance from <code>$.data</code> and destroys it.  When an instance
in a list is destroyed, it is automatically removed from the list.  EJS's <code>list</code> method
listens for these changes and automatically updates the DOM.</p>

<p>Next, an <code>Editor</code> control constructor is created.  Editor is designed to take a todo instance and
edit it's name property.  First a new <code>Editor</code> is created on an element like:</p>

<pre><code class="lang-javascript">var editor = new Editor("#editor")</code></pre>

<p>And an instance to edit is passed like:</p>

<pre><code class="lang-javascript">editor.todo( todo );</code></pre>

<p>When <code>editor.todo( todo )</code> is called, it updates the editor's todo option and calls <code>this.on()</code>. This rebinds 
the editor's event handlers like <code>"{todo} updated"</code> and <code>"{todo} destroyed"</code> to bind to the 
updated todo option.  Then it calls <code>this.setName()</code> which updates the 
editor element's value.  </p>

<p><code>"{todo} updated"</code> listens when a todo has been updated on the server and updates the name.</p>

<p><code>"{todo} destroyed"</code> hides the editor if it's todo has been destroyed.</p>

<p><code>"change"</code> listens to the input element's value changing, updates the todo's <strong>name</strong> attribute and saves 
it to to the server.</p>

<p>Finally a <code>Routing</code> control constructor is created that manages the interaction between an <code>Editor</code> and
<code>Todos</code> control.  <code>Routing</code> is a traditional controller, while <code>Editor</code> and <code>Todos</code> are traditional
views. When a new <code>Routing</code> is created, it creates an <code>Editor</code> and <code>Todos</code> control.  It also
listens to changes in routes with <code>"route"</code> and <code>"todos/:id route"</code>.  </p>

<p><code>"route"</code> matches when the hash is empty and hides the editor.</p>

<p><code>"todos/:id route"</code> matches when the route is like <code>#!todos/5</code>.  When this happens, it shows the 
editor, loads that Todo with the model, and passed it to the editor.</p>

<p><code>Routing</code> also listens to an <code>"li selected"</code> event.  This is the event created by 
the <code>Todos</code> control.  When this event happens, <code>Routing</code> updates the hash with the select todo's id.</p>

<h3>Paginated Grid with Buttons</h3>

<p>Paginate through a list of links. This recipe shows how to use <code>can.Observe</code> can <code>can.compute</code> to
organize client state and pass it to child controls.</p>

<iframe style="width: 100%; height: 300px" 
        src="http://jsfiddle.net/SyEXx/4/embedded/result,html,js,css" 
        allowfullscreen="allowfullscreen" 
        frameborder="0">JSFiddle</iframe>

<p><a href="http://bitovi.com/blog/2013/02/weekly-widget-paginated-grid.html">How it works</a></p>
		</section>
		
	</article>
</div>

<script type="text/javascript">
	var docData = {
    "type": "page",
    "name": "Recipes",
    "body": "<p>The following is a list of <strong>CanJS</strong> recipes to help you learn CanJS.  To\nadd your own, simply <a href=\"https://github.com/bitovi/canjs/edit/gh-pages/recipes.md\">edit this file</a>. To\nhelp create a JSFiddle, we've created the following fiddles you can fork:</p>\n\n<ul>\n<li><a href=\"http://jsfiddle.net/donejs/qYdwR/\">jQuery and CanJS</a></li>\n<li><a href=\"http://jsfiddle.net/donejs/7Yaxk/\">Zepto and CanJS</a></li>\n<li><a href=\"http://jsfiddle.net/donejs/9x96n/\">Dojo and CanJS</a></li>\n<li><a href=\"http://jsfiddle.net/donejs/w6m73/\">YUI and CanJS</a></li>\n<li><a href=\"http://jsfiddle.net/donejs/mnNJX/\">Mootools and CanJS</a></li>\n</ul>\n\n<h2>Controls</h2>\n\n<p>The following recipes explore making UI widgets with <code>can.control</code>.</p>\n\n<h3>Tabs</h3>\n\n<p>The following recipes builds a simple tabs widget.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/wSaGm/1/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<p>It creates a <code>Tabs</code> constructor function that shows and hides tabs\nwhen it's <code>&lt;li&gt;</code>'s are clicked.</p>\n\n<p>When <code>new Tabs()</code> is called, it adds <code>active</code> to the first <code>&lt;li&gt;</code>'s \nclassName. Then, using the <code>tab</code> helper function, it hides the content for \nall the other tab buttons.</p>\n\n<pre><code class=\"lang-javascript\">&lt;li>&lt;a href=\"#model\">Model&lt;/a>&lt;/li></code></pre>\n\n<p>Then gets it's <code>&lt;a&gt;</code> element, and then uses it's href (<code>#model</code>) to get the\ncontent div for that button.</p>\n\n<p>When a button is clicked, <code>Tabs</code> listens to it with:</p>\n\n<pre><code class=\"lang-javascript\">\"li click\" : function( el, ev ) { ... }</code></pre>\n\n<p>This function, using the <code>tab</code> helper deactivates the active tab button and hides its content, \nthen it activates and shows the new tab button and tab content.</p>\n\n<h3>Tooltip</h3>\n\n<p>The following recipe builds a simple tooltip.  It shows templated event binding and we will\nexplain how it keeps memory leaks from happening. Click on one of the items\nto see a tooltip, click somewhere else to remove it.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/imjoshdean/2VQSb/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<p>This creates a <code>Tooltip</code> control that when created shows a tooltip.  When a <code>Tooltip</code> control\nis created, it positions the <code>Tooltip</code> element relative to the <code>relativeTo</code> option and \nsets its inner html to the <code>html</code> option.</p>\n\n<p>The tooltip also listens to clicks on the window.  If the user clicked on something other than the\n<code>relativeTo</code> element and the tooltip element, it will remove the tooltip from the document.</p>\n\n<p>When an element is removed from the DOM with any controls on it, the control's event handlers\nare automatically removed.  Templated event binding lets us listen to events outside \nthe element.  <code>\"{window} click\"</code> is a templated event binding.</p>\n\n<p>Events outside an element would normally not be removed, but they are with <code>can.Control</code>.</p>\n\n<h3>TreeCombo</h3>\n\n<p>Select multiple items in a tree-like structure. This control uses <code>can.Observe.List</code> and <code>can.compute</code>\nin a smart way to manage the state of the widget.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/sTLhX/35/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<p><a href=\"http://bitovi.com/blog/2013/01/weekly-widget-tree-combo.html\">How it works</a></p>\n\n<h2>Routing</h2>\n\n<p>The following recipes explore using <code>can.route</code>.</p>\n\n<h3>History Tabs</h3>\n\n<p>This recipe shows how to make a history-based tabs widget and have routes\nconfigured independently by can.route.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/Z9Cv5/2/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<p>The HTML is structured such that each tab button has an <code>&lt;a&gt;</code> element with an \nhref property that matches the <code>id</code> attribute of the tab content \npanel it should show.  This means that even if JavaScript was disabled,\nclicking a button would send the user to the tab panel (even though\nHistoryTabs overwrites this behavior).</p>\n\n<p>For example:</p>\n\n<pre><code class=\"lang-javascript\">&lt;li>&lt;a href=\"#model\">can.Model&lt;/a>&lt;/li></code></pre>\n\n<p>references:</p>\n\n<pre><code class=\"lang-javascript\">&lt;div id=\"model\" class=\"tab\"></code></pre>\n\n<p>The JavaScript code begins by creating a <code>HistoryTabs</code> \ncontrol.  When a new <code>HistoryTabs</code> instance is created, it gets\nan <strong>attr</strong> option like:</p>\n\n<pre><code class=\"lang-javascript\">new HistoryTabs( '#components',{attr: 'component'});</code></pre>\n\n<p>The <strong>attr</strong> method is used to configure which part of <code>can.route</code>'s data the \nhistory tab will be listening to.  </p>\n\n<p>When <code>init</code> is called, it hides each tab button's content div, looking up\nthe content div with the <code>tab</code> helper method.  It then reads the current \nactive tab with:</p>\n\n<pre><code class=\"lang-javascript\">var active = can.route.attr(this.options.attr);</code></pre>\n\n<p>It passes that value to the <code>active</code> helper which will hide the old active\ncontent (if <code>oldActive</code> is passed) and activate the new active button and\nshow it's content.</p>\n\n<p><code>HistoryTab</code> updates the active tab by listening when a tab button is clicked with\n<code>\"li click\"</code>.  It prevents the default behavior (which is changing the hash) and\nupdates it's route data attribute with the select tab's id:</p>\n\n<pre><code class=\"lang-javascript\">can.route.attr(this.options.attr, this.tab(el)[0].id)</code></pre>\n\n<p><code>HistoryTabs</code> listens to these route changes with <code>\"{can.route} {attr}\"</code> and activates\nthe new tab.</p>\n\n<p><strong>Configuring Routes</strong></p>\n\n<p>The code ends by configuring the routes and creating the <code>HistoryTabs</code>.  Here's what each\nroute rule means:</p>\n\n<pre><code class=\"lang-javascript\">can.route(\":component\",{\n  component: \"model\",\n  person: \"mihael\"\n});</code></pre>\n\n<p>This matches the empty routes <code>(\"\",\"#\",\"#!\")</code>, and a single \"word\" route.  If the route\nis one of the empty routes, the route data will look \nlike: <code>{component: \"modal\", person: \"mihael\"}</code>.  If it is a single \"word\" route like\n<code>\"#!view\"</code>, the data will look like:  <code>{component: \"view\", person: \"mihael\"}</code>.</p>\n\n<pre><code class=\"lang-javascript\">can.route(\":component/:person\",{\n  component: \"model\",\n  person: \"mihael\"\n});</code></pre>\n\n<p>This matches two-word routes seperated by a slash (\"/\").  Each word can be empty. If both\nwords are empty \"#!/\", the data will look \nlike: <code>{component: \"model\", person: \"mihael\"}</code>.  If the words are non-empty, that word\nwill replace the default value.</p>\n\n<h3>Observe Backed Routes</h3>\n\n<p>This recipe shows how to have multiple widgets listening on \noverlapping parts of the route. The app lets the user select a type of issue, show issues for that type,\nand select a issue and see details about that issue.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/2UL6R/1/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<p>This functionality is broken down \ninto <strong>Nav</strong>, <strong>Issues</strong>, and <strong>Details</strong> can.controls.  Here's how\neach part works:</p>\n\n<p><code>Nav</code> creates links using <code>can.route.link</code> that update the hash like:</p>\n\n<pre><code class=\"lang-javascript\">&lt;%== can.route.link(\"Critical\",{filter: \"critical\"}) %></code></pre>\n\n<p>When these are clicked on, they update the route's filter data.  </p>\n\n<p><code>Issues</code> listens to filter changes like:</p>\n\n<pre><code class=\"lang-javascript\">\"{can.route} filter\" : function(route, ev, filter){ ... }</code></pre>\n\n<p>It then retrieve's issue with <code>Issue.findAll</code> and renders \nthem into the <code>#issues</code> element.</p>\n\n<p>When an issue is clicked, <code>Issues</code> updates the route's issue data like:</p>\n\n<pre><code class=\"lang-javascript\">can.route.attr(\"issue\", issue.id)</code></pre>\n\n<p>It listens to changes in <code>issue</code> data and highlights the corresponding\nissue in the list like:</p>\n\n<pre><code class=\"lang-javascript\">\"{can.route} issue\" : function(route, ev, issue){ ... }</code></pre>\n\n<p><code>Details</code> listens to issue chagnes like:</p>\n\n<pre><code class=\"lang-javascript\">\"{can.route} issue\" : function(route, ev, issue){ ... }</code></pre>\n\n<p>And updates the details panel.</p>\n\n<h2>Live Binding</h2>\n\n<p>The following recipes show how to use <code>can.EJS</code>'s live binding.</p>\n\n<h3>Updating timestamps</h3>\n\n<p>The following shows how to create an automatically updating <code>prettyDate</code>\nhelper for EJS that can be used like:</p>\n\n<pre><code class=\"lang-javascript\">&lt;%= prettyDate( new Date() ) %></code></pre>\n\n<p>Notice how the <em>created</em> value changes every couple min or \nso. </p>\n\n<p>The <code>prettyDate</code> method works with or without live-binding.  It doesn't need to take\nan observe, just a date.  Code with EJS becomes live naturally ... amazing.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/qYdwR/36/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h3>2-way binding Mustache helpers</h3>\n\n<p>Learn how to make 2-way binding mustache helpers.  When you change the value of an input, it automatically\nchanges the value of an observe.  When you change the value of the observe, it changes the value of the \ninput.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/ztWS5/5/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<p><a href=\"http://bitovi.com/blog/2013/01/weekly-widget-two-way-mustache-helpers.html\">How it works</a></p>\n\n<h2>Models</h2>\n\n<p>The following recipes show how to use <code>can.Model</code> (and often the <code>can.fixture</code> plugin).</p>\n\n<h3>Showing the same data in 2 places</h3>\n\n<p>The following recipe shows how <code>can.Model</code>'s internal store and <code>can.view</code>'s live-binding\ncan easily solve the editing-data-that-is-represented-two-places problem.  It \nshows two task lists of overlaping data.  Notice how the <strong>\"do dishes\"</strong> is listed \ntwice. But if you click one \"do dishes\" checkbox, it updates the other.</p>\n\n<iframe style=\"width: 100%; height: 300px\"\n        src=\"http://jsfiddle.net/moschel/pCtxs/15/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<p>The code first sets up a <code>can.fixture</code> to return different, but overlapping lists of \ntasks from the server.  The fixture returns data from the following calls:</p>\n\n<ul>\n<li><code>/tasks?due=today</code></li>\n<li><code>/tasks?type=critical</code></li>\n</ul>\n\n<p>You'll notice \"do dishes\" in both lists.</p>\n\n<p>The code then creates a <code>Task</code> model that maps findAll to <code>/tasks</code>.  It then uses\n<code>can.view</code> to render the retrieved tasks with the <code>tasksEJS</code> template. </p>\n\n<p>Finally, it listens when an <code>input</code> element's value changes.  When it does,\nit gets the task model instance from the <code>li</code> element's <code>$.data</code> and \nupdates it's \"complete\" property.</p>\n\n<p><strong><em>The Secret Sauce</em></strong></p>\n\n<p>Model keeps an internal, non-leaking, store of instances your app loads.  When\n<code>Task.findAll({type: \"critical\"})</code> and <code>Task.findAll({due: \"today\"})</code> get their\nraw JSON data from the server, they convert it to instances.  But before they create\na new instance, they check if the same instance, matched by \nthe <a href=\"http://donejs.com/docs.html#!can.Model.static.id\">id</a> property already exists.  If it\ndoes, it uses that instance. </p>\n\n<p>This means that the <code>criticalTasks</code> list and <code>todaysTasks</code> list both point to the \nsame instance. When <code>can.EJS</code> does it's live binding on <code>&lt;%= task.attr(\"complete\") ? \"checked\" : \"\" %&gt;</code>\nit's actually binding on the same \"do dishes\" intance once.  So updating \"do dishes\" updates\nthe DOM in two places!</p>\n\n<h3>Caching Data in Local Storage</h3>\n\n<p>The following recipe shows how <code>can.Model</code> can be used to create an ORM-like \nmodel layer for keeping a local copy of a restful API. This type of base model\nis perfect for situations where you want a responsive UI, but may not want to \nwait for updates from the server before displaying data, or you need to make \nyour data persist offline. Storing your responses in <code>localStorage</code> allows you \nto get data to the view as quickly as possible.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/moschel/73Xuk/14/embedded/result%2Cjs/\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<p>When creating your base model for other models to extend from, you can prefix \nstatic service methods with <code>make</code>, to allow the base model to define how the \nextending model's method will behave. In this example, our base model implements\na static method called <code>makeFindOne</code>. This method acts as a hook to define the \nextending model's <code>findOne</code> method. Using this, we can create a middleware-like\nlayer between the extending model and the base model that loads and saves model\ndata to <code>localStorage</code>, while still requesting out to the restful API to get \nupdates.</p>\n\n<p><strong><em>The Secret Sauce</em></strong></p>\n\n<p>The secret sauce for this example is the static <code>makeFindOne</code> method along with\nEJS's live binding. Because the live binding will automatically update the view when the \nbound model gets updated, we can write our code as usual and allow the base model\nto deliver <code>localStorage</code> data instantly, while automatically upating with responses\nfrom the server, with no extra effort.</p>\n\n<h3>Real Time Chat</h3>\n\n<p>Type a message in one page, it instantly shows up in the other.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/fbasrawala/yRMSa/embedded/result%2Cjs/\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/fbasrawala/yRMSa/embedded/result%2Cjs/\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<p><a href=\"http://bitovi.com/blog/2013/02/weekly-widget-chat.html\">How it works</a></p>\n\n<h2>Everything Together</h2>\n\n<p>The following recipes show a bunch of functionality working together.</p>\n\n<h3>Basic Todo</h3>\n\n<p>This recipe demonstrates the very basic todo app covered on [http://canjs.us]. You\ncan select a todo and edit it's text.  You can also delete a todo.  The app is\nalso history enabled, letting you move forward and back through different todos.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/moschel/5zpFz/94/embedded/result,html,js,css\"\n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<iframe width=\"640\" height=\"480\" src=\"http://www.youtube.com/embed/PfTbkzh07iE\" \nframeborder=\"0\" allowfullscreen=\"allowfullscreen\">YouTube</iframe>\n\n<p>The app starts by creating a <code>Todo</code> model that connects to a dummy data \nstore (just an array). The <code>findAll</code>, <code>findOne</code>, <code>update</code> and <code>destroy</code> methods\nsimply returning the required deferreds.</p>\n\n<p>It then creates a <code>Todos</code> control that manages a list of <code>todos</code>.  When a new Todos control is created\non an element via <code>new Todos(\"#todos\")</code> it uses the <code>Todo</code> model to findAll todo instances,\nrenders them with <code>todosEJS</code> and inserts them into the <code>Todos</code> control instance's element.</p>\n\n<p>The template <code>todosEJS</code> iterates through each todo instance using <code>list</code>.  For each todo,\nit creates an <code>&lt;li&gt;</code> element.  It adds the instance's data to the <code>&lt;li&gt;</code> element's <code>$.data</code> \nwith: <code>&lt;%= (el) -&gt; el.data('todo',todo) %&gt;</code>.  Within each <code>&lt;li&gt;</code> it creates a\ncheckbox, span to contain the name, and destroy link.  EJS's live-binding will be used to\nupdate the checkbox's <code>checked</code> attribute, the span's class attribute, and the span's content.</p>\n\n<p><code>Todos</code> also binds on various events such as <code>\"li click\"</code>, <code>\"li .complete click\"</code>, and \n<code>\"li .destroy click\"</code>. Here's what they do:</p>\n\n<p><code>\"li click\"</code> triggers a synthetic <strong>selected</strong> event on the li clicked \nwith the model data. This is a great technique for making reusable event-based widgets.  This\n<strong>selected</strong> event is listened to by the <code>Routing</code> control.</p>\n\n<p><code>\"li .complete click\"</code> gets the todo instance clicked from <code>$.data</code> and updates \nit's <strong>complete</strong> property.  EJSs live-binding will take care of updating the DOM for you.</p>\n\n<p><code>\"li .destroy click\"</code> gets the todo instance from <code>$.data</code> and destroys it.  When an instance\nin a list is destroyed, it is automatically removed from the list.  EJS's <code>list</code> method\nlistens for these changes and automatically updates the DOM.</p>\n\n<p>Next, an <code>Editor</code> control constructor is created.  Editor is designed to take a todo instance and\nedit it's name property.  First a new <code>Editor</code> is created on an element like:</p>\n\n<pre><code class=\"lang-javascript\">var editor = new Editor(\"#editor\")</code></pre>\n\n<p>And an instance to edit is passed like:</p>\n\n<pre><code class=\"lang-javascript\">editor.todo( todo );</code></pre>\n\n<p>When <code>editor.todo( todo )</code> is called, it updates the editor's todo option and calls <code>this.on()</code>. This rebinds \nthe editor's event handlers like <code>\"{todo} updated\"</code> and <code>\"{todo} destroyed\"</code> to bind to the \nupdated todo option.  Then it calls <code>this.setName()</code> which updates the \neditor element's value.  </p>\n\n<p><code>\"{todo} updated\"</code> listens when a todo has been updated on the server and updates the name.</p>\n\n<p><code>\"{todo} destroyed\"</code> hides the editor if it's todo has been destroyed.</p>\n\n<p><code>\"change\"</code> listens to the input element's value changing, updates the todo's <strong>name</strong> attribute and saves \nit to to the server.</p>\n\n<p>Finally a <code>Routing</code> control constructor is created that manages the interaction between an <code>Editor</code> and\n<code>Todos</code> control.  <code>Routing</code> is a traditional controller, while <code>Editor</code> and <code>Todos</code> are traditional\nviews. When a new <code>Routing</code> is created, it creates an <code>Editor</code> and <code>Todos</code> control.  It also\nlistens to changes in routes with <code>\"route\"</code> and <code>\"todos/:id route\"</code>.  </p>\n\n<p><code>\"route\"</code> matches when the hash is empty and hides the editor.</p>\n\n<p><code>\"todos/:id route\"</code> matches when the route is like <code>#!todos/5</code>.  When this happens, it shows the \neditor, loads that Todo with the model, and passed it to the editor.</p>\n\n<p><code>Routing</code> also listens to an <code>\"li selected\"</code> event.  This is the event created by \nthe <code>Todos</code> control.  When this event happens, <code>Routing</code> updates the hash with the select todo's id.</p>\n\n<h3>Paginated Grid with Buttons</h3>\n\n<p>Paginate through a list of links. This recipe shows how to use <code>can.Observe</code> can <code>can.compute</code> to\norganize client state and pass it to child controls.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/SyEXx/4/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<p><a href=\"http://bitovi.com/blog/2013/02/weekly-widget-paginated-grid.html\">How it works</a></p>",
    "description": "",
    "title": "CanJS Recipes",
    "parent": "guides",
    "comment": " ",
    "src": "_guides/recipes.md",
    "id": 8
};

	console.log(docData);
</script>



	<footer>
		<nav class="container">
			<a class="brand canjs" href="index.html">CanJS</a>
			<ul class="pullright">
				<li><a href="../index.html">Home</a></li>
				<li><a href="../guides">Guides</a></li>
				<li><a href="../docs/index.html">Api</a></li>
				<li><a href="../community.html">Community</a></li>
				<li><a href="../download.html">Download</a></li>
			</ul>
		</nav>
	</footer>
	<div class="loading"></div>

	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
	<script src="../resources/production.min.js"></script>
</body>

</html>
