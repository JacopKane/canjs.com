{
    "active": false,
    "type": "page",
    "name": "guides",
    "body": "<p>This page contains recipes and tutorials that will get you started with building CanJS projects. Choose a section on the left to learn more about the components that make CanJS work and to see CanJS being used in real projects. If you're new to CanJS, a good starting point is [Why Why CanJS?]</p>",
    "description": "",
    "title": "Guides",
    "comment": " ",
    "src": "_guides/Guides.md",
    "id": 5,
    "children": [{
            "active": false,
            "type": "page",
            "name": "Recipes",
            "body": "<p>To the left is a list of <strong>CanJS</strong> recipes to help you learn CanJS.  To\nadd your own, simply <a href=\"https://github.com/bitovi/canjs/edit/gh-pages/recipes.md\">edit this file</a>. To\nhelp create a JSFiddle, we've created the following fiddles you can fork:</p>\n\n<ul>\n<li><a href=\"http://jsfiddle.net/donejs/qYdwR/\">jQuery and CanJS</a></li>\n<li><a href=\"http://jsfiddle.net/donejs/7Yaxk/\">Zepto and CanJS</a></li>\n<li><a href=\"http://jsfiddle.net/donejs/9x96n/\">Dojo and CanJS</a></li>\n<li><a href=\"http://jsfiddle.net/donejs/w6m73/\">YUI and CanJS</a></li>\n<li><a href=\"http://jsfiddle.net/donejs/mnNJX/\">Mootools and CanJS</a></li>\n</ul>",
            "description": "",
            "title": "CanJS Recipes",
            "parent": "guides",
            "order": 1,
            "comment": " ",
            "src": "_guides/recipes.md",
            "id": 14,
            "children": [{
                    "active": false,
                    "type": "page",
                    "name": "RecipesControls",
                    "body": "<p>The following recipes explore making UI widgets with <code>can.control</code>.</p>\n\n<h3>Tabs</h3>\n\n<p>The following recipes builds a simple tabs widget.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/wSaGm/1/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<p>It creates a <code>Tabs</code> constructor function that shows and hides tabs\nwhen it's <code>&lt;li&gt;</code>'s are clicked.</p>\n\n<p>When <code>new Tabs()</code> is called, it adds <code>active</code> to the first <code>&lt;li&gt;</code>'s \nclassName. Then, using the <code>tab</code> helper function, it hides the content for \nall the other tab buttons.</p>\n\n<pre><code class=\"lang-javascript\">&lt;li>&lt;a href=\"#model\">Model&lt;/a>&lt;/li></code></pre>\n\n<p>Then gets it's <code>&lt;a&gt;</code> element, and then uses it's href (<code>#model</code>) to get the\ncontent div for that button.</p>\n\n<p>When a button is clicked, <code>Tabs</code> listens to it with:</p>\n\n<pre><code class=\"lang-javascript\">\"li click\" : function( el, ev ) { ... }</code></pre>\n\n<p>This function, using the <code>tab</code> helper deactivates the active tab button and hides its content, \nthen it activates and shows the new tab button and tab content.</p>\n\n<h3>Tooltip</h3>\n\n<p>The following recipe builds a simple tooltip.  It shows templated event binding and we will\nexplain how it keeps memory leaks from happening. Click on one of the items\nto see a tooltip, click somewhere else to remove it.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/imjoshdean/2VQSb/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<p>This creates a <code>Tooltip</code> control that when created shows a tooltip.  When a <code>Tooltip</code> control\nis created, it positions the <code>Tooltip</code> element relative to the <code>relativeTo</code> option and \nsets its inner html to the <code>html</code> option.</p>\n\n<p>The tooltip also listens to clicks on the window.  If the user clicked on something other than the\n<code>relativeTo</code> element and the tooltip element, it will remove the tooltip from the document.</p>\n\n<p>When an element is removed from the DOM with any controls on it, the control's event handlers\nare automatically removed.  Templated event binding lets us listen to events outside \nthe element.  <code>\"{window} click\"</code> is a templated event binding.</p>\n\n<p>Events outside an element would normally not be removed, but they are with <code>can.Control</code>.</p>\n\n<h3>TreeCombo</h3>\n\n<p>Select multiple items in a tree-like structure. This control uses <code>can.Observe.List</code> and <code>can.compute</code>\nin a smart way to manage the state of the widget.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/sTLhX/35/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<p><a href=\"http://bitovi.com/blog/2013/01/weekly-widget-tree-combo.html\">How it works</a></p>",
                    "description": "",
                    "title": "Controls",
                    "parent": "Recipes",
                    "order": 0,
                    "comment": " ",
                    "src": "_guides/recipes_controls.md",
                    "id": 15
                }, {
                    "active": false,
                    "type": "page",
                    "name": "RecipesLiveBindings",
                    "body": "<p>The following recipes show how to use <code>can.EJS</code>'s live binding.</p>\n\n<h3>Updating timestamps</h3>\n\n<p>The following shows how to create an automatically updating <code>prettyDate</code>\nhelper for EJS that can be used like:</p>\n\n<pre><code class=\"lang-javascript\">&lt;%= prettyDate( new Date() ) %></code></pre>\n\n<p>Notice how the <em>created</em> value changes every couple min or \nso. </p>\n\n<p>The <code>prettyDate</code> method works with or without live-binding.  It doesn't need to take\nan observe, just a date.  Code with EJS becomes live naturally ... amazing.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/qYdwR/36/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h3>2-way binding Mustache helpers</h3>\n\n<p>Learn how to make 2-way binding mustache helpers.  When you change the value of an input, it automatically\nchanges the value of an observe.  When you change the value of the observe, it changes the value of the \ninput.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/ztWS5/5/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<p><a href=\"http://bitovi.com/blog/2013/01/weekly-widget-two-way-mustache-helpers.html\">How it works</a></p>",
                    "description": "",
                    "title": "Live Bindings",
                    "parent": "Recipes",
                    "order": 1,
                    "comment": " ",
                    "src": "_guides/recipes_livebindings.md",
                    "id": 17
                }, {
                    "active": false,
                    "type": "page",
                    "name": "RecipesRouting",
                    "body": "<p>The following recipes explore using <code>can.route</code>.</p>\n\n<h3>History Tabs</h3>\n\n<p>This recipe shows how to make a history-based tabs widget and have routes\nconfigured independently by can.route.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/Z9Cv5/2/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<p>The HTML is structured such that each tab button has an <code>&lt;a&gt;</code> element with an \nhref property that matches the <code>id</code> attribute of the tab content \npanel it should show.  This means that even if JavaScript was disabled,\nclicking a button would send the user to the tab panel (even though\nHistoryTabs overwrites this behavior).</p>\n\n<p>For example:</p>\n\n<pre><code class=\"lang-javascript\">&lt;li>&lt;a href=\"#model\">can.Model&lt;/a>&lt;/li></code></pre>\n\n<p>references:</p>\n\n<pre><code class=\"lang-javascript\">&lt;div id=\"model\" class=\"tab\"></code></pre>\n\n<p>The JavaScript code begins by creating a <code>HistoryTabs</code> \ncontrol.  When a new <code>HistoryTabs</code> instance is created, it gets\nan <strong>attr</strong> option like:</p>\n\n<pre><code class=\"lang-javascript\">new HistoryTabs( '#components',{attr: 'component'});</code></pre>\n\n<p>The <strong>attr</strong> method is used to configure which part of <code>can.route</code>'s data the \nhistory tab will be listening to.  </p>\n\n<p>When <code>init</code> is called, it hides each tab button's content div, looking up\nthe content div with the <code>tab</code> helper method.  It then reads the current \nactive tab with:</p>\n\n<pre><code class=\"lang-javascript\">var active = can.route.attr(this.options.attr);</code></pre>\n\n<p>It passes that value to the <code>active</code> helper which will hide the old active\ncontent (if <code>oldActive</code> is passed) and activate the new active button and\nshow it's content.</p>\n\n<p><code>HistoryTab</code> updates the active tab by listening when a tab button is clicked with\n<code>\"li click\"</code>.  It prevents the default behavior (which is changing the hash) and\nupdates it's route data attribute with the select tab's id:</p>\n\n<pre><code class=\"lang-javascript\">can.route.attr(this.options.attr, this.tab(el)[0].id)</code></pre>\n\n<p><code>HistoryTabs</code> listens to these route changes with <code>\"{can.route} {attr}\"</code> and activates\nthe new tab.</p>\n\n<p><strong>Configuring Routes</strong></p>\n\n<p>The code ends by configuring the routes and creating the <code>HistoryTabs</code>.  Here's what each\nroute rule means:</p>\n\n<pre><code class=\"lang-javascript\">can.route(\":component\",{\n  component: \"model\",\n  person: \"mihael\"\n});</code></pre>\n\n<p>This matches the empty routes <code>(\"\",\"#\",\"#!\")</code>, and a single \"word\" route.  If the route\nis one of the empty routes, the route data will look \nlike: <code>{component: \"modal\", person: \"mihael\"}</code>.  If it is a single \"word\" route like\n<code>\"#!view\"</code>, the data will look like:  <code>{component: \"view\", person: \"mihael\"}</code>.</p>\n\n<pre><code class=\"lang-javascript\">can.route(\":component/:person\",{\n  component: \"model\",\n  person: \"mihael\"\n});</code></pre>\n\n<p>This matches two-word routes seperated by a slash (\"/\").  Each word can be empty. If both\nwords are empty \"#!/\", the data will look \nlike: <code>{component: \"model\", person: \"mihael\"}</code>.  If the words are non-empty, that word\nwill replace the default value.</p>\n\n<h3>Observe Backed Routes</h3>\n\n<p>This recipe shows how to have multiple widgets listening on \noverlapping parts of the route. The app lets the user select a type of issue, show issues for that type,\nand select a issue and see details about that issue.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/2UL6R/1/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<p>This functionality is broken down \ninto <strong>Nav</strong>, <strong>Issues</strong>, and <strong>Details</strong> can.controls.  Here's how\neach part works:</p>\n\n<p><code>Nav</code> creates links using <code>can.route.link</code> that update the hash like:</p>\n\n<pre><code class=\"lang-javascript\">&lt;%== can.route.link(\"Critical\",{filter: \"critical\"}) %></code></pre>\n\n<p>When these are clicked on, they update the route's filter data.  </p>\n\n<p><code>Issues</code> listens to filter changes like:</p>\n\n<pre><code class=\"lang-javascript\">\"{can.route} filter\" : function(route, ev, filter){ ... }</code></pre>\n\n<p>It then retrieve's issue with <code>Issue.findAll</code> and renders \nthem into the <code>#issues</code> element.</p>\n\n<p>When an issue is clicked, <code>Issues</code> updates the route's issue data like:</p>\n\n<pre><code class=\"lang-javascript\">can.route.attr(\"issue\", issue.id)</code></pre>\n\n<p>It listens to changes in <code>issue</code> data and highlights the corresponding\nissue in the list like:</p>\n\n<pre><code class=\"lang-javascript\">\"{can.route} issue\" : function(route, ev, issue){ ... }</code></pre>\n\n<p><code>Details</code> listens to issue chagnes like:</p>\n\n<pre><code class=\"lang-javascript\">\"{can.route} issue\" : function(route, ev, issue){ ... }</code></pre>\n\n<p>And updates the details panel.</p>",
                    "description": "",
                    "title": "Routing",
                    "parent": "Recipes",
                    "order": 2,
                    "comment": " ",
                    "src": "_guides/recipes_routing.md",
                    "id": 19
                }, {
                    "active": false,
                    "type": "page",
                    "name": "RecipesModels",
                    "body": "<p>The following recipes show how to use <code>can.Model</code> (and often the <code>can.fixture</code> plugin).</p>\n\n<h3>Showing the same data in 2 places</h3>\n\n<p>The following recipe shows how <code>can.Model</code>'s internal store and <code>can.view</code>'s live-binding\ncan easily solve the editing-data-that-is-represented-two-places problem.  It \nshows two task lists of overlaping data.  Notice how the <strong>\"do dishes\"</strong> is listed \ntwice. But if you click one \"do dishes\" checkbox, it updates the other.</p>\n\n<iframe style=\"width: 100%; height: 300px\"\n        src=\"http://jsfiddle.net/moschel/pCtxs/15/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<p>The code first sets up a <code>can.fixture</code> to return different, but overlapping lists of \ntasks from the server.  The fixture returns data from the following calls:</p>\n\n<ul>\n<li><code>/tasks?due=today</code></li>\n<li><code>/tasks?type=critical</code></li>\n</ul>\n\n<p>You'll notice \"do dishes\" in both lists.</p>\n\n<p>The code then creates a <code>Task</code> model that maps findAll to <code>/tasks</code>.  It then uses\n<code>can.view</code> to render the retrieved tasks with the <code>tasksEJS</code> template. </p>\n\n<p>Finally, it listens when an <code>input</code> element's value changes.  When it does,\nit gets the task model instance from the <code>li</code> element's <code>$.data</code> and \nupdates it's \"complete\" property.</p>\n\n<p><strong><em>The Secret Sauce</em></strong></p>\n\n<p>Model keeps an internal, non-leaking, store of instances your app loads.  When\n<code>Task.findAll({type: \"critical\"})</code> and <code>Task.findAll({due: \"today\"})</code> get their\nraw JSON data from the server, they convert it to instances.  But before they create\na new instance, they check if the same instance, matched by \nthe <a href=\"http://donejs.com/docs.html#!can.Model.static.id\">id</a> property already exists.  If it\ndoes, it uses that instance. </p>\n\n<p>This means that the <code>criticalTasks</code> list and <code>todaysTasks</code> list both point to the \nsame instance. When <code>can.EJS</code> does it's live binding on <code>&lt;%= task.attr(\"complete\") ? \"checked\" : \"\" %&gt;</code>\nit's actually binding on the same \"do dishes\" intance once.  So updating \"do dishes\" updates\nthe DOM in two places!</p>\n\n<h3>Caching Data in Local Storage</h3>\n\n<p>The following recipe shows how <code>can.Model</code> can be used to create an ORM-like \nmodel layer for keeping a local copy of a restful API. This type of base model\nis perfect for situations where you want a responsive UI, but may not want to \nwait for updates from the server before displaying data, or you need to make \nyour data persist offline. Storing your responses in <code>localStorage</code> allows you \nto get data to the view as quickly as possible.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/moschel/73Xuk/14/embedded/result%2Cjs/\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<p>When creating your base model for other models to extend from, you can prefix \nstatic service methods with <code>make</code>, to allow the base model to define how the \nextending model's method will behave. In this example, our base model implements\na static method called <code>makeFindOne</code>. This method acts as a hook to define the \nextending model's <code>findOne</code> method. Using this, we can create a middleware-like\nlayer between the extending model and the base model that loads and saves model\ndata to <code>localStorage</code>, while still requesting out to the restful API to get \nupdates.</p>\n\n<p><strong><em>The Secret Sauce</em></strong></p>\n\n<p>The secret sauce for this example is the static <code>makeFindOne</code> method along with\nEJS's live binding. Because the live binding will automatically update the view when the \nbound model gets updated, we can write our code as usual and allow the base model\nto deliver <code>localStorage</code> data instantly, while automatically upating with responses\nfrom the server, with no extra effort.</p>\n\n<h3>Real Time Chat</h3>\n\n<p>Type a message in one page, it instantly shows up in the other.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/fbasrawala/yRMSa/embedded/result%2Cjs/\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/fbasrawala/yRMSa/embedded/result%2Cjs/\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<p><a href=\"http://bitovi.com/blog/2013/02/weekly-widget-chat.html\">How it works</a></p>",
                    "description": "",
                    "title": "Models",
                    "parent": "Recipes",
                    "order": 3,
                    "comment": " ",
                    "src": "_guides/recipes_models.md",
                    "id": 18
                }, {
                    "active": false,
                    "type": "page",
                    "name": "RecipesEverything",
                    "body": "<p>The following recipes show a bunch of functionality working together.</p>\n\n<h3>Basic Todo</h3>\n\n<p>This recipe demonstrates the very basic todo app covered on [http://canjs.us]. You\ncan select a todo and edit it's text.  You can also delete a todo.  The app is\nalso history enabled, letting you move forward and back through different todos.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/moschel/5zpFz/94/embedded/result,html,js,css\"\n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<h4>How it works</h4>\n\n<iframe width=\"640\" height=\"480\" src=\"http://www.youtube.com/embed/PfTbkzh07iE\" \nframeborder=\"0\" allowfullscreen=\"allowfullscreen\">YouTube</iframe>\n\n<p>The app starts by creating a <code>Todo</code> model that connects to a dummy data \nstore (just an array). The <code>findAll</code>, <code>findOne</code>, <code>update</code> and <code>destroy</code> methods\nsimply returning the required deferreds.</p>\n\n<p>It then creates a <code>Todos</code> control that manages a list of <code>todos</code>.  When a new Todos control is created\non an element via <code>new Todos(\"#todos\")</code> it uses the <code>Todo</code> model to findAll todo instances,\nrenders them with <code>todosEJS</code> and inserts them into the <code>Todos</code> control instance's element.</p>\n\n<p>The template <code>todosEJS</code> iterates through each todo instance using <code>list</code>.  For each todo,\nit creates an <code>&lt;li&gt;</code> element.  It adds the instance's data to the <code>&lt;li&gt;</code> element's <code>$.data</code> \nwith: <code>&lt;%= (el) -&gt; el.data('todo',todo) %&gt;</code>.  Within each <code>&lt;li&gt;</code> it creates a\ncheckbox, span to contain the name, and destroy link.  EJS's live-binding will be used to\nupdate the checkbox's <code>checked</code> attribute, the span's class attribute, and the span's content.</p>\n\n<p><code>Todos</code> also binds on various events such as <code>\"li click\"</code>, <code>\"li .complete click\"</code>, and \n<code>\"li .destroy click\"</code>. Here's what they do:</p>\n\n<p><code>\"li click\"</code> triggers a synthetic <strong>selected</strong> event on the li clicked \nwith the model data. This is a great technique for making reusable event-based widgets.  This\n<strong>selected</strong> event is listened to by the <code>Routing</code> control.</p>\n\n<p><code>\"li .complete click\"</code> gets the todo instance clicked from <code>$.data</code> and updates \nit's <strong>complete</strong> property.  EJSs live-binding will take care of updating the DOM for you.</p>\n\n<p><code>\"li .destroy click\"</code> gets the todo instance from <code>$.data</code> and destroys it.  When an instance\nin a list is destroyed, it is automatically removed from the list.  EJS's <code>list</code> method\nlistens for these changes and automatically updates the DOM.</p>\n\n<p>Next, an <code>Editor</code> control constructor is created.  Editor is designed to take a todo instance and\nedit it's name property.  First a new <code>Editor</code> is created on an element like:</p>\n\n<pre><code class=\"lang-javascript\">var editor = new Editor(\"#editor\")</code></pre>\n\n<p>And an instance to edit is passed like:</p>\n\n<pre><code class=\"lang-javascript\">editor.todo( todo );</code></pre>\n\n<p>When <code>editor.todo( todo )</code> is called, it updates the editor's todo option and calls <code>this.on()</code>. This rebinds \nthe editor's event handlers like <code>\"{todo} updated\"</code> and <code>\"{todo} destroyed\"</code> to bind to the \nupdated todo option.  Then it calls <code>this.setName()</code> which updates the \neditor element's value.  </p>\n\n<p><code>\"{todo} updated\"</code> listens when a todo has been updated on the server and updates the name.</p>\n\n<p><code>\"{todo} destroyed\"</code> hides the editor if it's todo has been destroyed.</p>\n\n<p><code>\"change\"</code> listens to the input element's value changing, updates the todo's <strong>name</strong> attribute and saves \nit to to the server.</p>\n\n<p>Finally a <code>Routing</code> control constructor is created that manages the interaction between an <code>Editor</code> and\n<code>Todos</code> control.  <code>Routing</code> is a traditional controller, while <code>Editor</code> and <code>Todos</code> are traditional\nviews. When a new <code>Routing</code> is created, it creates an <code>Editor</code> and <code>Todos</code> control.  It also\nlistens to changes in routes with <code>\"route\"</code> and <code>\"todos/:id route\"</code>.  </p>\n\n<p><code>\"route\"</code> matches when the hash is empty and hides the editor.</p>\n\n<p><code>\"todos/:id route\"</code> matches when the route is like <code>#!todos/5</code>.  When this happens, it shows the \neditor, loads that Todo with the model, and passed it to the editor.</p>\n\n<p><code>Routing</code> also listens to an <code>\"li selected\"</code> event.  This is the event created by \nthe <code>Todos</code> control.  When this event happens, <code>Routing</code> updates the hash with the select todo's id.</p>\n\n<h3>Paginated Grid with Buttons</h3>\n\n<p>Paginate through a list of links. This recipe shows how to use <code>can.Observe</code> can <code>can.compute</code> to\norganize client state and pass it to child controls.</p>\n\n<iframe style=\"width: 100%; height: 300px\" \n        src=\"http://jsfiddle.net/SyEXx/4/embedded/result,html,js,css\" \n        allowfullscreen=\"allowfullscreen\" \n        frameborder=\"0\">JSFiddle</iframe>\n\n<p><a href=\"http://bitovi.com/blog/2013/02/weekly-widget-paginated-grid.html\">How it works</a></p>",
                    "description": "",
                    "title": "Everything Together",
                    "parent": "Recipes",
                    "order": 4,
                    "comment": " ",
                    "src": "_guides/recipes_everything.md",
                    "id": 16
                }
            ]
        }, {
            "active": false,
            "type": "page",
            "name": "Tutorial",
            "body": "<p>This tutorial will walk you though the basics of CanJS by building a small\nto-do app with CanJS and jQuery.</p>\n\n<p>To get started, click [Constructs Constructs] in the navigation to the left. Or, if this\ntutorial isn't your thing, or if you prefer to watch, try the <a href=\"http://www.youtube.com/watch?feature=player_embedded&amp;v=GdT4Oq6ZQ68\">video</a> tutorial instead. Also, take a look around and see some nifty [Recipes recipes] for building functionality with CanJS, check out\nour <a href=\"../docs/index.html\">API</a>, or dive right in and poke around the <a href=\"http://canjs.com/release/latest/docs/can.jquery.html\">annotated source</a> for CanJS.</p>",
            "description": "",
            "title": "Get Started with CanJS",
            "parent": "guides",
            "order": 0,
            "comment": " ",
            "src": "_guides/tutorial.md",
            "id": 21,
            "children": [{
                    "active": false,
                    "type": "page",
                    "name": "Constructs",
                    "body": "<p>Constructor functions made with [can.Construct] are used to create objects with\nshared properties, and they make managing inheritance in JavaScript much easier.\n[Observes] (and through Observes, [Models] and [Controls]) are based off of\nConstructs, so learning how they work is fundamental to understanding CanJS.</p>\n\n<p>To create a constructor function of your own, call <code>can.Construct</code> and pass in\nan object of static properties (which will be attached directly to the \nconstructor) and an object of instance properties (which will be attached to\neach instance of the Construct):</p>\n\n<pre><code class=\"lang-javascript\">var Todo = can.Construct({ }, {\n    description: 'Something to do.',\n    author: 'Unknown',\n    allowedToEdit: function() {\n        return true;\n    }\n});\n\nvar t = new Todo();\n\nt.description; // 'Something to do.'\nt.author; // 'Unknown'\nt.allowedToEdit(); // true</code></pre>\n\n<p>There are a few other ways to create classes with  <code>can.Construct</code>; see\n[the API] for all the details.</p>\n\n<h2>Inheritance</h2>\n\n<p>can.Construct sets up the prototype chain so that Constructs are easy to\nsubclass. Call the constructor function of the class you want to extend and give\nit the arguments you would pass to <code>can.Construct</code>:</p>\n\n<pre><code class=\"lang-javascript\">// If only one argument is passed, they are considered instance properties.\nvar PrivateTodo = Todo({\n    description: 'Something secret!',\n    allowedToEdit: function(account) {\n        return account.owns(this);\n    }\n});\n\nvar p = new PrivateTodo();\np.author; // 'Unknown'\np.description; // 'Something secret!'\np.allowedToEdit({owns: function(){ return false; }}); // false</code></pre>\n\n<h2>Initialization</h2>\n\n<p>As you can see above, when a constructor function is called with <code>new</code>,\ncan.Construct creates a new instance of that class. If you've supplied an\ninstance method called <code>[init]</code>, can.Construct will call that as well, passing\nit the arguments you passed to the constructor.</p>\n\n<p>This helps make our Todo a little more configurable:</p>\n\n<pre><code class=\"lang-javascript\">var Todo = can.Construct({\n    description: 'Something to do.',\n    author: 'Unknown',\n\n    init: function(options) {\n        this.author = options.author || this.author;\n        this.description = options.description || this.description;\n    }\n});\n\nvar t = new Todo({author: 'Me!'});\nt.author; // 'Me!'\nt.description; // 'Something to do.'</code></pre>\n\n<p>If you're extending a Construct, you probably want to make sure you call the\nbase's <code>init</code> method inside the child's <code>init</code>:</p>\n\n<pre><code class=\"lang-javascript\">var PrivateTodo = can.Construct({\n    init: function(options) {\n        this.\n    }\n});</code></pre>",
                    "description": "",
                    "title": "Constructs",
                    "parent": "Tutorial",
                    "order": 0,
                    "comment": " ",
                    "src": "_guides/constructs.md",
                    "id": 7
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Observes",
                    "body": "<p>Observes made with can.Observe will let you set and remove properties like on\nnormal objects, but they also emit events when properties change that you can\nlisten to. Observes also make it easy to work with nested properties and get the\nevents you expect. Both [can.Route] and [Models] are based on can.Observe, but\nObserves are also useful on their own: for example, to maintain client-side\nstate like pagination data.</p>\n\n<p>To create an Observe, call <code>new can.Observe(obj)</code>. This will give you an Observe\nwith the same properties and values as <em>obj</em>. can.Observe also provides\n<a href=\"can.Observe.List\">observable arrays called Lists</a>. To create a List, call <code>new\ncan.Observe.List(array)</code>, which will give you a List with the same elements as\n<em>array</em>.</p>\n\n<pre><code class=\"lang-javascript\">var pagination = new can.Observe({page: 1, perPage: 25, count: 1388});\npagination.perPage; // 25\n\nvar hobbies = new can.Observe.List(['programming', 'basketball', 'partying']);\nhobbies[2]; // 'partying'</code></pre>\n\n<h2>Getting and setting properties</h2>\n\n<p>Though you can read properties from an Observe in the normal way, if you want to\nset the value of a property, you'll need to use <code>[attr]()</code>. There are a couple\nways to use attr to set a property, and it can also be used to get property\nvalues, or get a regular object back from an Observe:</p>\n\n<pre><code class=\"lang-javascript\">pagination.attr('perPage');     // 25\npagination.attr('perPage', 50);\npagination.perPage;             // 50\n\npagination.attr({page: 10, lastVisited: 1});\npagination.attr(); // {page: 10, perPage: 50, count: 1388, lastVisited: 1}</code></pre>\n\n<p>It might not make sense to get properties from an Observe using <code>attr</code> when you\ncan read them directly, but when reading properties for use in a template with\n[can.view Views] or when using a property in a Compute, using <code>attr</code> tells the\ntemplate or compute you want to watch that value in case it changes.</p>\n\n<p>Properties can be removed from Observes with <code>removeAttr</code>. This is the\nequivalent of the <code>delete</code> keyword:</p>\n\n<pre><code class=\"lang-javascript\">pagination.removeAttr('count');\npagination.attr(); // {page: 10, perPage: 50, lastVisited: 1}</code></pre>\n\n<h2>Listening to events</h2>\n\n<p>When a property on an Observe is changed with <code>attr</code>, the Observe will emit two\nevents: a <em>change</em> event and an event with the same name as the property that\nwas changed. You can listen for these events by using\n<code>[bind](can.Observe.bind)</code>:</p>\n\n<pre><code class=\"lang-javascript\">paginate.bind('change', function(event, attr, how, newVal, oldVal) {\n    attr;   // 'perPage'\n    how;    // 'set'\n    newVal; // 30\n    oldVal; // 50\n});\npaginate.bind('perPage', function(event, newVal, oldVal) {\n    newVal; // 30\n    oldVal; // 50\n});\n\npaginate.attr('perPage', 30);</code></pre>\n\n<p>You can similarly stop listening to these events by using <a href=\"can.Observe.unbind\">unbind</a>:</p>\n\n<pre><code class=\"lang-javascript\">var timesChanged = 0,\n    changeHandler = function() { timesChanged++; },\n    obs = new can.Observe({value: 10});\n\nobs.bind('change', changeHandler);\nobs.attr('value', 20);\ntimesChanged; // 1\n\nobs.unbind('change', changeHandler);\nobs.attr('value', 30);\ntimesChanged; // 1</code></pre>\n\n<h2>Iterating though an Observe</h2>\n\n<p>If you want to iterate through the properties on an Observe, use <code>each</code>:</p>\n\n<pre><code class=\"lang-javascript\">paginate.each(function(val, key) {\n    console.log(key + ': ' + val);\n});\n\n// The console shows:\n// page: 10\n// perPage: 30\n// lastVisited: 1</code></pre>\n\n<h2>Observable arrays</h2>\n\n<p>As mentioned above, CanJS also provides observable arrays with can.Observe.List.\ncan.Observe.List inherits from can.Observe, so a List works much the same way an\nObserve does, with the addition of several methods useful for working with\narrays:</p>\n\n<ul>\n<li><a href=\"can.Observe.List.prototype.indexOf\">indexOf</a>, which looks for an item in a\nList.</li>\n<li><a href=\"can.Observe.List.prototype.pop\">pop</a>, which removes the last item from a\nList.</li>\n<li><a href=\"can.Observe.List.prototype.push\">push</a>, which adds an item to the end of a\nList.</li>\n<li><a href=\"can.Observe.List.prototype.shift\">shift</a>, which removes the first item from\na List.</li>\n<li><a href=\"can.Observe.List.prototype.unshift\">unshift</a>, which adds an item to the front\nof a List.</li>\n<li><a href=\"can.Observe.List.prototype.splice\">splice</a>, which removes and inserts items\nanywhere in a List.</li>\n</ul>\n\n<p>When these methods are used to modify a List, the appropriate events are emitted. See <a href=\"can.Observe.List\">the API for Lists</a> for more information on the\narguments passed to those event handlers.</p>\n\n<h2>Observable values</h2>\n\n<p>CanJS also provides a way to make values themselves observable with\n<a href=\"can.compute\">can.compute</a>. A Compute represents a value that can be read, set,\nand listened to just like an Observe.</p>\n\n<h3>Static Computes</h3>\n\n<p>A simple Compute contains a single value, and is created by calling\n<code>can.compute(value)</code>. This value can be read, set, and listened to:</p>\n\n<pre><code class=\"lang-javascript\">// create a Compute\nvar age = can.compute(25),\n    previousAge = 0;\n\n// read the Compute's value\nage(); // 25\n\n// listen for changes in the Compute's value\nage.bind('change', function(ev, newVal, oldVal) {\n    previousAge = oldVal;\n});\n\n// set the Compute's value\nage(26);\n\nage();       // 26\npreviousAge; // 25</code></pre>\n\n<h3>Composite Computes</h3>\n\n<p>Computes can also get values derived from other observable values. This type of\nCompute is created by calling <code>can.compute(getterFunction)</code>. When the values\nthe Compute is derived from changes, the value of the Compute changes:</p>\n\n<pre><code class=\"lang-javascript\">var name = new can.Observe({\n    first: 'Alice',\n    last: 'Liddell'\n});\nvar fullName = can.compute(function() {\n    // We use attr to read the values so the compute knows what to listen to.\n    return name.attr('first') + ' ' + name.attr('last');\n});\nvar previousName = '';\n\nfullName();   // 'Alice Liddell'\n\nfullName.bind('change', function(ev, newVal, oldVal) {\n    previousName = oldVal;\n});\n\nname.attr({\n    first: 'Allison',\n    last: 'Wonderland'\n});\n\nfullname();   // 'Allison Wonderland'\npreviousName; // 'Alice Liddell'</code></pre>\n\n<p>Since the value of the Compute is cached any time a constituent value is\nchanged, reading the value is fast.</p>\n\n<h3>Converted Computes</h3>\n\n<p>Computes are useful for creating a link to a property in an Observe, and one of\nthe most frequent examples of this is when converting from one unit to another.</p>\n\n<pre><code class=\"lang-javascript\">// progress ranges from 0 to 1.\nvar project = new can.Observe({ progress: 0.3 });\nvar progressPercentage = can.compute(function(newVal) {\n    if(newVal !== undefined) {\n        // set a value\n        project.attr('progress', newVal / 100);\n    } else {\n        // get the value\n        return project.attr('progress') * 100;\n    }\n});\n\npercentage();     // 30\n\n// Setting percentage...\npercentage(75);\n// ...updates project.progress!\nproject.progress; // .75</code></pre>",
                    "description": "",
                    "title": "Observes",
                    "parent": "Tutorial",
                    "order": 1,
                    "comment": " ",
                    "src": "_guides/observes.md",
                    "id": 13
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Models",
                    "body": "<p>Models are Observes that connect to a RESTful interface. They come with a set of\nmethods designed to make it easy to manage changes remotely. To create a Model\nclass, call <code>can.Model</code> and supply it with specific static properties that tell\nit how to interact with the server, along with any instance properties or helper\nmethods the Model may need. The important static properties are:</p>\n\n<ul>\n<li><a href=\"can.Model.static.findAll\">findAll</a>, which describes how to get a group of\nitems.</li>\n<li><a href=\"can.Model.static.findOne\">findOne</a>, which describes how to get a specific\nitem.</li>\n<li><a href=\"can.Model.static.create\">create</a>, which describes how to save a new item.</li>\n<li><a href=\"can.Model.static.update\">update</a>, which describes how to update an\nexisting item.</li>\n<li><a href=\"can.Model.static.destroy\">destroy</a>, which describes how to delete an item.</li>\n</ul>\n\n<p>When accessing a straightforward RESTful API, creating a Model class and an\ninstance of that Model class might be as simple as this:</p>\n\n<pre><code class=\"lang-javascript\">var Todo = can.Model({\n    findAll: 'GET /todos',\n    findOne: 'GET /todos/{id}',\n    create:  'POST /todos',\n    update:  'PUT /todos/{id}',\n    destroy: 'DELETE /todos/{id}'\n}, {});\n\nvar dishesTask = new Todo({description: 'Do the dishes.'});</code></pre>\n\n<p>Because Models are Observes, don't forget to set all your properties with <code>attr</code>.</p>\n\n<h2>Talking to the server</h2>\n\n<p>By supplying the <code>findAll</code>, <code>findOne</code>, <code>create</code>, <code>update</code>, and <code>destroy</code>\nproperties, you show a Model class how to communicate with the server. You can\ncall <code>findAll</code> and <code>findOne</code> on the Model class to retrieve Models and <code>save</code>\nand <code>destroy</code> on Models to create, update, and delete them.</p>\n\n<h3>Retrieving items from a server</h3>\n\n<p><code>can.Model.findAll</code> retrieves a group of Models by making a call to a server.\nHere's how you call <code>findAll</code> on our Todo class above:</p>\n\n<pre><code class=\"lang-javascript\">Todo.findAll({}, function(todos) {\n    // todos is a can.Model.List of Todo Models.\n}, function(xhr) {\n    // handle errors\n});</code></pre>\n\n<p>This will make a <code>GET</code> request to <code>/todos</code>, which should return JSON that looks\nsimilar to:</p>\n\n<pre><code class=\"lang-javascript\">{\n    \"data\": [\n        {\"id\":1, \"description\":\"Do the dishes.\"},\n        {\"id\":2, \"description\":\"Mow the lawn.\"},\n        {\"id\":3, \"description\":\"Finish the laundry.\"}\n    ]\n}</code></pre>\n\n<p>(<code>findAll</code> will also accept an array from the service, but <a href=\"http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\">you probably should not be returning an array from a JSON service</a>.)</p>\n\n<p>When the service has returned, <code>findAll</code> will massage the data into Model\ninstances, put them in a can.Model.List (which is like a can.Observe.List for\nModels), and pass the List to the callback in its second parameter. If there was\nan error, <code>findAll</code> will call the callback in its third parameter and pass it the\nXmlHttpRequest object used to make the call.</p>\n\n<p><code>findAll</code> returns a <a href=\"can.Deferred\">can.Deferred</a> that will resolve to a Model\nList of items if the call succeeds and rejects to the XmlHttpRequest object if\nthere is an error.</p>\n\n<p><code>can.Model.findOne</code> works similarly to <code>findAll</code>, except that it retrieves a\nsingle Model from a server:</p>\n\n<pre><code class=\"lang-javascript\">Todo.findOne({id: 1}, function(todo) {\n    // todo is an instance of Todo\n});</code></pre>\n\n<p>This makes a <code>GET</code> request to <code>/todos/1</code>, which should return JSON that looks\nsimilar to:</p>\n\n<pre><code class=\"lang-javascript\">{\n    \"id\":1,\n    \"description\":\"Do the dishes\"\n}</code></pre>\n\n<p><code>findOne</code> returns a Deferred that resolves to the Todo if the call succeeds and\nrejects to the XmlHttpRequest object if there is an error.</p>\n\n<h3>Modifying items</h3>\n\n<p>You can call <code>[save](can.Model.prototype.save)</code> on a Model instance to save it\nback to the server. If the Model has an <strong>id</strong>, it will be updated using the\nfunction specified under <code>update</code>. Otherwise, can.Model assumes the Model is new\nand creates the item on the server using the function in <code>create</code>.</p>\n\n<p>Either way, the callback in the first parameter will be called on a successful\nsave with the updated Model; if an error occurs, the callback in the second\nparameter will be called with the XmlHttpRequest object. Like <code>findAll</code>, <code>save</code>\nreturns a Deferred that resolves to the updated Model on success and rejects to\nthe XmlHttpRequest object on failure.</p>\n\n<pre><code class=\"lang-javascript\">var shopping = new Todo({description: \"Go grocery shopping.\"});\nshopping.save(function(saved) {\n    // saved is the saved Todo\n    saved.attr('description', 'Remember the milk.');\n    saved.save();\n});</code></pre>\n\n<p>In the code above, the first time <code>shopping.save()</code> is called, can.Model will\nmake a <code>POST</code> request to <code>/todos</code> with a request body of <code>description=Go\ngrocery shopping.</code>. When the response comes back, it should have an <strong>id</strong>\n(say, 5) and that <strong>id</strong> property will be reflected in <code>todo</code>.</p>\n\n<p>The second time <code>saved.save()</code> is called, <code>saved</code> has an <strong>id</strong>, so can.Model\nwill make a <code>PUT</code> request to <code>/todos/5</code> with a request body of\n<code>description=Remember the milk.</code>.</p>\n\n<h3>Deleting items</h3>\n\n<p>When you need to delete a Model's counterpart on the server, just call <code>destroy</code>\non the Model, passing it success and error handlers just like <code>save</code>, except\nthat the success handler will be passed the Model that has been deleted.\n<code>destroy</code> also retuns a Deferred, which resolves to the deleted Model and\nrejects to the XmlHttpRequest object.</p>\n\n<pre><code class=\"lang-javascript\">var cats = new Todo({description: \"Feed the cats.\"});\ncats.save(function(saved) {\n    saved.destroy(function(destroyed) {\n        // destroyed is the Todo that was destroyed\n    });\n});</code></pre>\n\n<p>When <code>destroy</code> is called in the above code, can.Model makes a <code>DELETE</code> request\nto <code>/todos/6</code>.</p>\n\n<h2>Listening to events</h2>\n\n<p>Because Models are Observes, you can bind to the same events as on any other\nObserve. In addition to those events, Models emit three new kinds of events:</p>\n\n<ul>\n<li><em>created</em>, when an instance is created on the server.</li>\n<li><em>updated</em>, when an instance is updated on the server.</li>\n<li><em>destroyed</em>, when an instance is destroyed on the server.</li>\n</ul>\n\n<p>For example, here is how you listen for an instance being created on the server:</p>\n\n<pre><code class=\"lang-javascript\">var mop = new Todo({description: 'Mop the floor.'});\nmop.bind('created', function(ev, created) {\n    // created is the created Todo\n});\nmop.save();</code></pre>\n\n<p>You can also bind directly onto the Model class to listen for any time <strong>any</strong>\ninstance is created, updated, or destroyed:</p>\n\n<pre><code class=\"lang-javascript\">Todo.bind('created', function(ev, created) {\n    // created is the created Todo\n});</code></pre>\n\n<h2>Model Lists</h2>\n\n<p>Model Lists (provided by <code>can.Model.List</code>) are Lists whose items are Models.\nWhen one of a Model List's elements are destroyed, that element is removed from\nthe list.</p>\n\n<pre><code class=\"lang-javascript\">Todo.findAll({}, function(todos) {\n    todos.length; // 5\n    todos[0].destroy(function() {\n        todos.length; // 4\n    }\n});</code></pre>",
                    "description": "",
                    "title": "Models",
                    "parent": "Tutorial",
                    "order": 2,
                    "comment": " ",
                    "src": "_guides/models.md",
                    "id": 11
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Templates",
                    "body": "<p><code>[can.view](can.view)</code> loads and renders templates with the data you provide, and\nreturns a documentFragment with the populated template. can.view supports many\ntemplating languages, but <a href=\"can.EJS\">EJS</a> and <a href=\"can.Mustache\">Mustache</a> allow you\nto live-bind Observes into templates.</p>\n\n<h2>Loading templates</h2>\n\n<p>You can load templates from a URL or directly from an existent script tag. To\nload from a script tag, pass <code>can.view</code> the tag's ID as the first parameter. To\nload from a URL, pass the URL as the first parameter. Use the second parameter to\npass the data to populate the template with.</p>\n\n<p>In order to register a template with can.view, create a script tag on the page\nwith an ID, a <code>type</code> attribute that matches the templating language, and the\ncontent of the template inside:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/ejs\" id=\"todoList\">\n<% can.each(this, function(val, key) { %>\n    &lt;li><%= val.description %>&lt;/li>\n<% }); %>\n&lt;/script></code></pre>\n\n<p>Then load the template using the script tag's ID and pass the template data:</p>\n\n<pre><code class=\"lang-javascript\">Todo.findAll({}, function(todos) {\n    $('#nav').html(can.view('todoList', todos))\n});</code></pre>\n\n<p>Or you can load a template without registering it first (or including it on the\npage) by giving the URL to <code>can.view</code>:</p>\n\n<pre><code class=\"lang-javascript\">Todo.findAll({}, function(todos) {\n    $('#nav').html(can.view('todos/todos.ejs', todos))\n});</code></pre>\n\n<h2>Passing Deferreds</h2>\n\n<p>If the second parameter you pass to <code>can.view</code> contains Deferreds, can.view will\ninstead return a Deferred that resolves to the documentFragment containing the\npopulated template after all the deferreds have resolved.</p>\n\n<p>This aspect is most useful because <code>can.Model.findAll</code> returns a Deferred, which\nmeans it's easy to lead a template, retrieve one or more Models, and render the\nresulting documentFragment when everything has been loaded:</p>\n\n<pre><code class=\"lang-javascript\">can.view('todos.ejs', {\n    todos: Todo.findAll().\n    user: User.findOne({id: 5})\n}).then(function(fragment) {\n    document.getElementById('todos').appendChild(fragment);\n});</code></pre>\n\n<h2>Rendering to string</h2>\n\n<p>To render to a string instead of a documentFragment, use <code>can.view.render</code>. This\nis mainly used to include templates inside of other templates:</p>\n\n<pre><code class=\"lang-javascript\"><% can.each(todos, function(todo, key) { %>\n    &lt;li><%== can.view.render('todos.ejs', todo); %>&lt;/li>\n<% }) %></code></pre>",
                    "description": "",
                    "title": "Templates",
                    "parent": "Tutorial",
                    "order": 3,
                    "comment": " ",
                    "src": "_guides/views.md",
                    "id": 24
                }, {
                    "active": false,
                    "type": "page",
                    "name": "EJS",
                    "body": "<p><a href=\"can.EJS\">EJS</a> is CanJS's default template language, which provides live\nbinding when used with Observes. EJS is very easy to use; you write the HTML you\nwant to be in the template, along with a few magic tags where you want dynamic\nbehavior.</p>\n\n<p>Here's an example of a template that might render a list of Todos:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/ejs\" id=\"todoList\">\n<% for(var i = 0; i < todos.length; ++i) { %>\n    &lt;li><%= this[i].description &lt;/li>\n<% } %>\n&lt;/script></code></pre>\n\n<p>And you can use <code>can.view</code> to render the template:</p>\n\n<pre><code class=\"lang-javascript\">Todo.findAll({}, function(todos) {\n    document.getElementById('list').appendChild(can.view('todoList', todos));\n});</code></pre>\n\n<p>As you can see from the template and the call to <code>can.view</code>, <code>todos</code> becomes\n<code>this</code> inside the template. EJS can also access the properties of the <code>this</code>\nobject without having to prefix it with <code>this.</code>:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/ejs\" id=\"todosAndUser\">\n&lt;h2> <%= user.name %>&lt;/h2>\n<% for(var i = 0; i < todos.length; ++i) { %>\n    &lt;li><%= this[i].description &lt;/li>\n<% } %>\n&lt;/script></code></pre>\n\n<p>Which can be inserted in the document with:</p>\n\n<pre><code class=\"lang-javascript\">can.view('todosAndUser', {\n    todos: Todo.findAll(),\n    user: User.findOne({id: 5})\n}).then(function(frag) {\n    document.getElementById('todos').appendChild(fragment);\n});</code></pre>\n\n<h2>Magic tags</h2>\n\n<p>There are five kinds of magic tags used in EJS:</p>\n\n<p><code>&lt;% %&gt;</code> will run any JavaScript code inside of it. This tag doesn't modify or\npopulate the template, but allows you to use for loops, if/else statements, \nswitch statements, and variable declarations inside the EJS template. Because\nalmost any JavaScript code is valid in <code>&lt;% %&gt;</code>, EJS is incredibly powerful.</p>\n\n<pre><code class=\"lang-javascript\"><% if(todos.attr('length') > 0) { %>\n    &lt;div>You have no to-dos.&lt;/div>\n<% } else { %>\n    &lt;ul>\n        <% todos.each(function(todo) { %>\n        &lt;li>todo.description&lt;/li>\n        <% }); %>\n    &lt;/ul>\n<% } %></code></pre>\n\n<p><code>&lt;%= %&gt;</code> will evaluate a JavaScript statement and write the HTML-escaped result\ninto the populated template. For example, an EJS template like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;div>My favorite element is <%= '&lt;b>blink&lt;/b>' %>.&lt;/div></code></pre>\n\n<p>will result in HTML like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;div>My favorite element is &amp;lt;b&amp;gt;blink&amp;lt;/b&amp;gt;.&lt;/div></code></pre>\n\n<p>This is almost always the tag you want to use when writing values to your\ntemplate, because it protects you against <a href=\"http://en.wikipedia.org/wiki/Cross-site_scripting\">cross-site scripting attacks</a>.</p>\n\n<p><code>&lt;%== %&gt;</code> will evaluate a JavaScript statement and write the raw result into the\npopulated template. This is like <code>&lt;%= %&gt;</code> but without escaping the result first.\nFor example, an EJS template like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;div>My favorite element is <%== '&lt;b>blink&lt;/b>' %>.&lt;/div></code></pre>\n\n<p>will result in HTML like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;div>My favorite element is &lt;b>blink&lt;/b>.&lt;/div></code></pre>\n\n<p>The most common use of <code>&lt;%== %&gt;</code> is to include templates in other templates:</p>\n\n<pre><code class=\"lang-javascript\"><% todos.each(function(todo) { %>\n    &lt;li><%== can.view.render('todoEJS', todo); %>&lt;/li>\n<% }); %></code></pre>\n\n<p>The other two magic tags are less commonly used and can be found in the\n<a href=\"can.EJS\">documentation for EJS</a>.</p>\n\n<h2>Live binding</h2>\n\n<p>You can make your EJS templates automatically update themselves when the data\nthey are populated with changes. To do this, populate your templates with\nObserves and use <code>attr</code> to read properties. In this template, using <code>attr</code> sets\nup live binding on the <code>description</code> property of <code>todo</code>:</p>\n\n<pre><code class=\"lang-javascript\">&lt;li><%= todo.attr('description') %>&lt;/li></code></pre>\n\n<p>If you change the Todo's description, the template's output will automatically\nupdate:</p>\n\n<pre><code class=\"lang-javascript\">todo.attr('description', 'Clean up the bathroom.');</code></pre>\n\n<p>Live binding works by wrapping the code inside the magic tags with a function\nto call when the attributes inside the magic tags change. This means that a\ntemplate like this will not work:</p>\n\n<pre><code class=\"lang-javascript\"><% for(var i = 0; i < todos.length; ++i) { %>\n    &lt;li><%= todos[i].attr('name') %>&lt;/li>\n<% } %></code></pre>\n\n<p>This will not work because when the function wrapping <code>todos[i].attr('name')</code> is\ncalled, <code>i</code> will still be <em>3</em> (as that is what <code>i</code> is set to after the loop is\nrun). You can fix this by using a closure and the <code>each</code> method of Observes:</p>\n\n<pre><code class=\"lang-javascript\"><% todos.each(function() { %>\n    &lt;li><%= todo.attr('name') %>&lt;/li>\n<% }); %></code></pre>\n\n<p><code>each</code> will also watch the length of the list it is passed, so elements are\nadded or removed from it, it will update the output of the template.</p>\n\n<h2>Element callbacks</h2>\n\n<p>If the code inside <code>&lt;%= %&gt;</code> or <code>&lt;%== %&gt;</code> evaluates to a function, the function\nwill be called back with the element it's inside as its first argument. This is\nuseful to initialize functionality on an element within the template, like\nstarting an element hidden:</p>\n\n<pre><code class=\"lang-javascript\">&lt;img src=\"surprise.gif\" <%= function(element) { element.style.display = 'none'; } %>/></code></pre>\n\n<p>This is so common that EJS also supports <a href=\"http://wiki.ecmascript.org/doku.php?id=strawman:arrow_function_syntax\">ECMAScript 5 arrow functions</a>\nthat get passed a library-wrapped NodeList containing the element. Because we\nare using jQuery, the example above can be more simply written like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;img src=\"surprise.gif\" <%= (el) -> el.hide() %>/></code></pre>\n\n<p>You can use this functionality to easily attach data to an element. A common\nreason to do this is to attach a Model to the element that represents it:</p>\n\n<pre><code class=\"lang-javascript\"><% todos.each(function(todo) { %>\n&lt;li <%= (el) -> can.data(el, 'todo', todo) %>>\n    <%= todo.attr('description') %>\n&lt;/li>\n<% }) %></code></pre>",
                    "description": "",
                    "title": "EJS",
                    "parent": "Tutorial",
                    "order": 4,
                    "comment": " ",
                    "src": "_guides/ejs.md",
                    "id": 10
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Mustache",
                    "body": "<p><a href=\"can.Mustache\">Mustache</a> provides logic-less templates that will live-bind to\nObserves. You can get Mustache functionality as a <a href=\"http://canjs.us/release/latest/can.view.mustache.js\">plugin</a>\nfor CanJS. Mustach and Handlebar templates are both compatible with CanJS's\nMustache implementation, so you can reuse any existing templates you have.</p>\n\n<p>Mustache is easy to get started with. Templates look like normal HTML, except\nthey contain special tags for inserting data into the template, iterating\nthrough lists, and filtering blocks.</p>\n\n<p>Here's an example of a template that might render a list of Todos:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/mustache\" id=\"todosList\">\n{{#todos}}\n&lt;li>{{description}}&lt;/li>\n{{/todos}}\n&lt;/script></code></pre>\n\n<p>And you can use <code>can.view</code> to render the template:</p>\n\n<pre><code class=\"lang-javascript\">Todo.findAll({}, function(todos) {\n    document.getElementById('list')\n        .appendChild(can.view('todoList', {todos: todos}));\n});</code></pre>\n\n<h2>Magic tags</h2>\n\n<p>There are three kinds of magic tags used in Mustache:</p>\n\n<ul>\n<li><code>{{ }}</code> will HTML-escape the value enclosed inside the tags and write it to\nthe template.</li>\n<li><code>{{{ }}}</code> will write the value enclosed inside the tags and write it directly\nto the template without escaping it.</li>\n<li><code>{{! }}</code> will write nothing to the template and is mostly used for comments.</li>\n</ul>\n\n<h3>Keys</h3>\n\n<p>Keys insert data into the template. They reference variables in the current\ncontext.</p>\n\n<p>This template:</p>\n\n<pre><code class=\"lang-javascript\">Name: {{name}}</code></pre>\n\n<p>given this data:</p>\n\n<pre><code class=\"lang-javascript\">{name: 'Alice'}</code></pre>\n\n<p>will render thusly:</p>\n\n<pre><code class=\"lang-javascript\">Name: Alice</code></pre>\n\n<h3>Sections</h3>\n\n<p>Sections contain text blocks and are conditionally rendered based on the value\nenclosed in the opening tag. They also change the context inside them to the\nkey referenced in the opening tag.</p>\n\n<p>For the following examples, we will assume the template is being populated with\nthis set of data:</p>\n\n<pre><code class=\"lang-javascript\">{\n    name: 'Alice Liddell',\n    nickname: '',\n    friends: ['Bob', 'Eve'],\n    enemies: []\n}</code></pre>\n\n<p>If the key is <code>undefined</code>, <code>null</code>, <code>false</code>, <code>''</code>, or <code>[]</code>, it is considered\na falsey value and the section is not rendered at all. Neither of these sections\nwill render:</p>\n\n<pre><code class=\"lang-javascript\">{{#enemies}}\n&lt;li>{{.}}&lt;/li>\n{{/enemies}}</code></pre>\n\n<pre><code class=\"lang-javascript\">{{#nickname}}{{.}}{{/nickname}}</code></pre>\n\n<p>If the key is a non-empty array, the section will be rendered once for each\nelement in the array. If it is truthy but not an array, the section is rendered\nonce.</p>\n\n<p>This template:</p>\n\n<pre><code class=\"lang-javascript\">&lt;h1>{{#name}}{{.}}{{/name}}&lt;/h1>\n&lt;ul>\n    {{#friends}}\n    &lt;li>{{.}}&lt;/li>\n    {{/friends}}\n&lt;/ul></code></pre>\n\n<p>will render like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;h1>Alice Liddell&lt;/h1>\n&lt;ul>\n    &lt;li>Bob&lt;/li>\n    &lt;li>Eve&lt;/li>\n&lt;/ul></code></pre>\n\n<p>You can also make inverted sections that render if the key referenced in the\nopening tag is falsey:</p>\n\n<pre><code class=\"lang-javascript\">&lt;ul>\n    {{#friends}}\n    &lt;li>{{.}}&lt;/li>\n    {{/friends}}\n    {{^friends}}\n    &lt;li>You have no friends.&lt;/li>\n    {{/friends}}\n&lt;/ul></code></pre>\n\n<h3>Context</h3>\n\n<p>When Mustache is resolving an object in a section, it sets the current context\nto the object value for which it is iterating. (If the key in the opening tag\nof a section was not an array, it sets the context to the value of that key.)\nYou can reference the current context as <code>.</code>.</p>\n\n<p>Internally, Mustache keeps a stack of contexts as the template enters nested\nsections and helpers. If a key is not found in the current context, Mustache\nwill look for the the in each successive parent context until it resolves the\nkey or runs out of parent contexts.</p>\n\n<p>For example, with this data:</p>\n\n<pre><code class=\"lang-javascript\">{\n    brothers: [{name: 'Bob'}, {name: 'David'}],\n    sisters: [{name: 'Alice'}, {name: 'Eve'}]\n}</code></pre>\n\n<p>and this template:</p>\n\n<pre><code class=\"lang-javascript\">{{#brothers}}\n    {{#sisters}}\n        {{name}}\n    {{/sisters}}\n{{/brothers}}</code></pre>\n\n<p>the rendered result will be:</p>\n\n<pre><code class=\"lang-javascript\">Alice\nEve\nAlice\nEve</code></pre>\n\n<p>Since there is no <code>sisters</code> key in the context of the elements of the <code>brothers</code>\narray, Mustache jumps up to the parent context and resolves <code>sisters</code> there.</p>\n\n<h2>Helpers</h2>\n\n<p>Mustache lets you register functions to be called from inside the template called\nhelpers. Since Mustache template are logic-less, all your view logic will be\ninside helpers.</p>\n\n<p>To use a helper that is local to the template you're rendering, pass it as the\nthird argument to <code>can.view</code> in an object where the key is the name of the helper\nand the value is the helper function:</p>\n\n<pre><code class=\"lang-javascript\">var fragment = can.view('todosList', {todos: todos}, {\n    uppercase: function(str) {\n        return str.toUppercase();\n    }\n});</code></pre>\n\n<p>This might be used in a template like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/mustache\" id=\"todosList\">\n{{#todos}}\n&lt;li>{{uppercase description}}&lt;/li>\n{{/todos}}\n&lt;/script></code></pre>\n\n<p>If a property of an observe is passed to a helper function, the helper will\nbecome a <code>[can.compute](can.compute)</code>. As an example, if you had this template:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/mustache\" id=\"prefixedName\">\n&lt;div>{{addMs lastName}}&lt;/div>\n&lt;/script></code></pre>\n\n<p>And you ran this code:</p>\n\n<pre><code class=\"lang-javascript\">var name = new can.Observe({firstName: 'Alice', lastName: 'Liddell'});\ndocument.getElementById('name')\n    .appendChild(can.view('prefixedName', name, {\n        addMs: function(lastName) {\n            return 'Ms. ' + lastName;\n        }\n    }));\nname.attr({firstName: 'Allison', lastName: 'Wonderland'});</code></pre>\n\n<p>The contents of the &lt;div> would be <code>Ms. Wonderland</code>.</p>\n\n<h3>Global helpers</h3>\n\n<p>You can register global helpers using <code>can.Mustache.registerHelper</code>:</p>\n\n<pre><code class=\"lang-javascript\">can.Mustache.registerHelper('i10n', function(str, options) {\n    return (Globalize != undefined ? Globalize.localize(str) : str);\n});</code></pre>\n\n<h3>Data helpers</h3>\n\n<p>You can use the <code>data</code> helper in Mustache to associate data to an element. This\nhelper will associate the current context (<code>.</code>) with a key you pass to the\nhelper.</p>\n\n<p>For example, this template:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/mustache\" id=\"nameDiv\">\n&lt;div id=\"person\" {{data 'name'}}>{{firstName}} {{lastName}}&lt;/div>\n&lt;/script></code></pre>\n\n<p>lets you do this in code:</p>\n\n<pre><code class=\"lang-javascript\">document.body.appendChild(can.view('nameDiv', {\n    firstName: 'Alice',\n    lastName: 'Liddell'\n}));\n\nvar obj = can.data(document.getElementById('person'), 'name');\nobj; // { firstName: 'Alice', lastName: 'Liddell'}</code></pre>\n\n<h2>Partials</h2>\n\n<p>You can embed templates in other templates by using partials. Partials inherit\nthe context where they are called. They are evaluated at render time, so you\nshould be careful to avoid infinite loops. To include a partial, put its URL or\nID inside <code>{{&gt; }}</code>.</p>\n\n<p>With these templates:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/mustache\" id=\"names\">\n&lt;ul>\n{{#names}}\n    {{>user}}\n{{/names}}\n&lt;/ul>\n&lt;/script>\n&lt;script type=\"text/mustache\" id=\"user\">\n&lt;li>{{firstName}} {{lastName}}&lt;/li>\n&lt;/script></code></pre>\n\n<p>the expanded template at render time would look similar to:</p>\n\n<pre><code class=\"lang-javascript\">&lt;ul>\n{{#names}}\n    &lt;li>{{firstName}} {{lastName}}&lt;/li>\n{{/names}}\n&lt;/ul></code></pre>",
                    "description": "",
                    "title": "Mustache",
                    "parent": "Tutorial",
                    "order": 5,
                    "comment": " ",
                    "src": "_guides/mustache.md",
                    "id": 12
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Controls",
                    "body": "<p>Controls made with can.Control are organized, memory-leak free,\nperformant, stateful UI controls. can.Control lets you create controls like\ntabs, grids, context menus, and forms, and helps you organize them into\nhigher-order business units, tying them all together with <a href=\"can.route\">can.route</a>.\nControls fill the traditional MVC controller role, managing data through Models\nmade with can.Model and directing it to be displayed through views made with\ncan.view.</p>\n\n<p>Because Controls are Constructs, you can create control constructors and\ninstances just like with can.Construct. Here's what the constructor for a Control\nthat manages a Todo list might look like:</p>\n\n<pre><code class=\"lang-javascript\">var Todos = can.Control({\n    init: function(el, options) {\n        var self = this;\n        Todo.findAll({}, function(todos) {\n            self.element.html(can.view('todoList', todos));\n        });\n    }\n});</code></pre>\n\n<p>When you instantiate a control, pass it a selector, element, or library-wrapped\nNodeList that corresponds to the DOM element you want the Control to set to\n<code>this.element</code> for that Control. Also pass the control an object with any options\nfor that particular instance. These options will be extended off of the Control's\nconstructor's static defaults and set as <code>this.options</code> for that Control.</p>\n\n<p>Here we'll initiate a Todos controller to hang off of the element with ID <em>todos</em>\nand with no options supplied:</p>\n\n<pre><code class=\"lang-javascript\">var todosList = new Todos('#todos', {});</code></pre>\n\n<p>If you specify a method called <code>init</code> when creating your Control's constructor,\nthat method will be called when a new instance of that Control is created. The\n<code>init</code> method gets passed a library-wrapped NodeList containing <code>this.element</code>\nas the first parameter and <code>this.options</code> as the second parameter. Any other\nparameters you passed to the constructor during instantiation will also be passed\nto <code>init</code>.</p>\n\n<p>To demonstrate this, here is another version of the Todo list Control constructor\nthat can have its view overridden, and the instantiation of that Control:</p>\n\n<pre><code class=\"lang-javascript\">var Todos = can.Control({\n    defaults: {\n        view: 'todos.ejs'\n    }\n},{\n    init: function(el, options) {\n        var self = this;\n        Todo.findAll({}, function(todos) {\n            self.element.html(can.view(this.options.view, todos));\n        });\n    }\n});\n\n// this Control will use todos.ejs\nnew Todos(document.body.firstChild);\n\n// this Control will use todos2.ejs\nnew Todos('#todoList', {view: 'todos2.ejs'});</code></pre>\n\n<h2>Listening to events</h2>\n\n<p>Controls will automatically bind instance methods that look like event handlers.\nOn this Control, <em>click</em> events on &lit;li> elements inside <code>this.element</code> will\ntrigger the console log to be written to:</p>\n\n<pre><code class=\"lang-javascript\">var Todos = can.Control({\n    init: function(el, options) {\n        var self = this;\n        Todo.findAll({}, function(todos) {\n            self.element.html(can.view('todoList', todos));\n        });\n    },\n    'li click': function(el, ev) {\n        console.log('You clicked ' + el.text());\n    }\n});</code></pre>\n\n<p>The event handlers are passed a library-wrapped NodeList containing the element\nthat was clicked, and the event. can.Control uses event delegation, so you don't\nneed to rebind handlers when you add or remove elements.</p>\n\n<p>One of the things we want to do with our to-do list is delete Todos. This is\nmade easy with event handling in can.Control. Let's say that our view template looks like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/ejs\" id=\"todoList\">\n<% this.each(function(todo) { %>\n&lt;li <%= (el) -> el.data('todo', todo) %>>\n    <%= todo.attr('description'); %>\n    &lt;a class=\"destroy\">X</a>\n&lt;/li>\n<% }) %>\n&lt;/script></code></pre>\n\n<p>We should put an event listener on our Todos Control to remove a Todo when its\ndestruction link is clicked:</p>\n\n<pre><code class=\"lang-javascript\">var Todos = can.Control({\n    init: function(el, options) {\n        var self = this;\n        Todo.findAll({}, function(todos) {\n            self.element.html(can.view('todoList', todos));\n        });\n    },\n    'li click': function(el, ev) {\n        console.log('You clicked ' + el.text());\n    },\n    'li .destroy click': function(el, ev) {\n        var li = el.closest('li'),\n            todo = li.data('todo');\n\n        todo.destroy();\n    }\n});</code></pre>\n\n<p>Destroying the Todo will take it out of the list of Todos being rendered\n(because the list of Todos passed into the template is a Model List), which will\ncause the template to re-render itself. This means that EJS's live binding will\nremove the appropriate &lt;li> automatically.</p>\n\n<h2>Templating event handlers</h2>\n\n<p>If a variable is placed in braces in the event handler key, can.Control will\nlook up that key in the Control's <code>options</code>, and then on <code>window</code>. You can use\nthis to customize the events that cause handlers to fire:</p>\n\n<pre><code class=\"lang-javascript\">var Todos = can.Control({\n    defaults: {\n        destroyEvent: 'click'\n    }\n},{\n    init: function(el, options) {\n        var self = this;\n        Todo.findAll({}, function(todos) {\n            self.element.html(can.view(this.options.view, todos));\n        });\n    },\n    'li .destroy {destroyEvent}': function(el, ev) {\n        var li = el.closest('li'),\n            todo = li.data('todo');\n\n        todo.destroy();\n    }\n});\n\nnew Todos('#todos', {destroyEvent; 'mouseenter'});</code></pre>\n\n<p>You can also use this to bind events to objects other that <code>this.element</code>\nwithin Controls. This is critical for avoiding memory leaks that are\ncommonplace with other MVC applications and frameworks because it ensures that\nthese handlers get unbound when the control is destroyed:</p>\n\n<pre><code class=\"lang-javascript\">var Tooltip = can.Control({\n    '{window} click': function(el, ev) {\n        // hide only if we clicked outside the tooltip\n        if(! this.element.has(ev.target).length) {\n            this.element.remove();\n        }\n    }\n});</code></pre>\n\n<p>This is useful for listening to changes on models. Say that our live-binding did\nnot take care of removing &lt;li>s after the corresponding Model was destroyed.\nIn that case, we could implement that functionality by listening to when Todos\nare destroyed:</p>\n\n<pre><code class=\"lang-javascript\">var Todos = can.Control({\n    defaults: {\n        destroyEvent: 'click'\n    }\n},{\n    init: function(el, options) {\n        var self = this;\n        self.todosList = todos;\n        Todo.findAll({}, function(todos) {\n            self.element.html(can.view(this.options.view, todos));\n        });\n    },\n    'li .destroy {destroyEvent}': function(el, ev) {\n        var li = el.closest('li'),\n            todo = li.data('todo');\n\n        todo.destroy();\n    },\n    '{Todo} destroyed': function(Todo, ev, destroyed) {\n        // find where the element is in the list\n        var index = this.todosList.indexOf(destroyed);\n        this.element.children(':nth-child(' + (index + 1) + ')').remove();\n        this.todosList.splice(index, 1);\n    }\n});</code></pre>\n\n<h2>Rebinding events</h2>\n\n<p>You can unbind and rebind all a Control's event handlers by calling <code>on</code> on it.\nThis is useful when a Control starts listening to a specific Model, and you want\nto change which model it is listening to.</p>\n\n<p>In the example below, an Editor Control keeps a reference to the specific Todo\nit is editing. Its <code>todo</code> method calls <code>on</code> when the Todo being edited switches,\nbecause it needs to rebind <code>{todo} updated</code>.</p>\n\n<pre><code class=\"lang-javascript\">var Editor = can.Control({\n    setDesc: function() {\n        this.element.val(this.options.todo.description);\n    },\n    // change what Todo this Control points at\n    todo: function(todo) {\n        this.options.todo = todo;\n        this.on();\n        this.setDesc();\n    },\n    // listen for changes in the Todo\n    '{todo} updated': function() {\n        this.setDesc();\n    },\n    // when the input changes, update the Todo\n    ' change': function(el, ev) {\n        this.options.todo.attr('description', el.val());\n        this.options.todo.save();\n    }\n});\n\nvar todo1 = new Todo({id: 7, description: 'Take out the trash.'}),\n    todo2 = new Todo({id: 8, description: 'Wash the dishes.'}),\n    editor = new Editor('#editor');\n\n// start editing the first Todo\neditor.todo(todo1);\n\n// switch to editing the second Todo\neditor.todo(todo2);</code></pre>\n\n<h2>Destrying Controls</h2>\n\n<p>Calling <code>destroy</code> on a Control unbinds the Control's event handlers and removes\nits association with its element, but it does not remove the element from the\npage.</p>\n\n<pre><code class=\"lang-javascript\">var list = new Todos('#todos');\n$('#todos').length; // 1\nlist.destroy();\n$('#todos').length; // 1</code></pre>\n\n<p>However, when a Control's element is removed from the page, <code>destroy</code> is called\non the Control.</p>\n\n<p>Taken together, templated event binding and Control's automatic cleanup make it\nnearly impossible to write applications with memory leaks. An application that\nuses only templated event handlers on the controls within the body could free\nup all the data it uses by calling <code>$(document.body).empty()</code>.</p>",
                    "description": "",
                    "title": "Controls",
                    "parent": "Tutorial",
                    "order": 6,
                    "comment": " ",
                    "src": "_guides/controls.md",
                    "id": 8
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Deferreds",
                    "body": "<p>Deferreds in CanJS are explained in greater detail in the <a href=\"can.Deferred\">API</a>.\nBelow is a quick tour through can.Deferred, which should look familiar to you\nif you have experience with the Deferred pattern.</p>\n\n<pre><code class=\"lang-javascript\">// Create a new Deferred:\nvar dfd = new can.Deferred();\n\n// Add a done callback:\ndfd.done(function(foo) {\n    console.log('Resolved!');\n});\n// Add a fail callback:\ndfd.fail(function(bar) {\n    console.log('Rejected!');\n});\n// Add a callback that fires whether the\n// Deferred is resolve or rejected.\ndfd.always(function(obj) {\n    console.log('Apathetic!');\n});\n\nvar dfd2 = new can.Deferred();\n// Add done and fail callbacks:\ndfd2.then(functon(foo) {\n    console.log('Also resolved.');\n}, function(bar) {\n    console.log('Also rejected.');\n});\n\n// Create a Deferred that resolves when\n// all passed Deferreds resolve:\nvar endDfd = can.when(dfd, dfd2).then(function() {\n    console.log('I open at the close.');\n});\n\n// Resolve a Deferred (and call all its done callbacks):\ndfd.resolve('foo');\n\n// Reject a Deferred (and call all its fail callbacks):\ndfd.reject('bar');</code></pre>",
                    "description": "",
                    "title": "Deferreds",
                    "parent": "Tutorial",
                    "order": 7,
                    "comment": " ",
                    "src": "_guides/deferred.md",
                    "id": 9
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Routing",
                    "body": "",
                    "description": "<p><code>can.route</code> is the core of CanJS's routing functionality. It is a special\nObserve that updates <code>window.location.hash</code> when its properties change and\nupdates its properties when <code>window.location.hash</code> changes. You can give\n<code>can.route</code> a template to translate URLs into property values, but if no route\nis provided, it just serializes the route into standard URL-encoded notation.</p>\n\n<p>Here is how you might use <code>can.route</code> without a template:</p>\n\n<pre><code class=\"lang-javascript\">// Before we start, empty the hash.\nwindow.location.hash = '';\n\n// This means that can.route is empty.\ncan.route.attr(); // {}\n\n// Set the hash...\nwindow.location.hash = '#!id=7';\n// ...and can.route reflects that.\ncan.route.attr(); // {id: 7}\n\n// Set the route...\ncan.route.attr({type: 'todos'}, true);\n// ...and the hash reflects that.\nwindow.location.hash; // #!type=todos\n\n// Set a new property on the route...\ncan.route.attr('id', 6);\n// ...and the has changes again to reflect multiple properties.\nwindow.location.hash; // #!type=todos&id=6</code></pre>\n\n<p>If you give <code>can.route</code> a template, you can make pretty URLs:</p>\n\n<pre><code class=\"lang-javascript\">// Give can.route a template.\ncan.route(':type/:id');\n\n// If you set a hash that looks like the route...\nwindow.location.hash = '#!todos/5';\n// ... the route data changes accordingly.\ncan.route.attr(); // {type: 'todos', id: 5}\n\n// If the route data is changed...\ncan.route.attr({type: 'users', id: 29});\n// ...the hash is changed using the template.\nwindow.location.hash; // '#!users/7'\n\n// You can also supply defaults for routes.\ncan.route('', {type: 'recipe'});\n\n// Then if you change the hash...\nwindow.location.hash = '';\n// ...the route data reflects the defaults.\ncan.route.attr(); // {type: 'recipe'}</code></pre>\n\n<h2>Listening to events</h2>\n\n<p>Because <code>can.route</code> is an Observe, you can bind to it just like normal Observes:</p>\n\n<pre><code class=\"lang-javascript\">can.route.bind('id', function(ev, newVal, oldVal) {\n    console.log('The hash\\'s id changed.');\n});</code></pre>\n\n<p>You can listen to routing events in Controls with the <em>route</em> event:</p>\n\n<pre><code class=\"lang-javascript\">var Routing = can.Control({\n    'route': function() {\n        // Matches every routing change, but gets passed no data.\n    },\n    'todos/:id route': function(data) {\n        // Matches routes like #!todos/5,\n        // and will get passed {id: 5} as data.\n    },\n    ':type/:id route': function(data) {\n        // Matches routes like #!recipes/5,\n        // and will get passed {id: 5, type: 'recipes'} as data.\n    },\n})</code></pre>\n\n<h2>Making URLs and links</h2>\n\n<p><code>can.route.url</code> takes a set of properties and makes a URL according to\n<code>can.route</code>'s current route.</p>\n\n<pre><code class=\"lang-javascript\">can.route(':type/:id', {type: 'todos'});\ncan.route.url({id: 7}); // #!todos/7</code></pre>\n\n<p><code>can.route.link</code> does the same thing as <code>can.route.url</code>, but it returns an\nanchor element (in string form) ready to be inserted into HTML. You can also\nspecify extra propertires to be set on the element.</p>\n\n<pre><code class=\"lang-javascript\">var a = can.route.link(\n    'Todo 5',\n    {id: 7},\n    {className: 'button'}\n);\n\na; // <a href=\"#!todos/7\" class=\"button\">Todo 5</a></code></pre>",
                    "title": "Routing",
                    "parent": "Tutorial",
                    "order": 8,
                    "src": "_guides/route.md",
                    "id": 20
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Utilities",
                    "body": "<p>CanJS provides a plethora of utility methods. These methods are usually mapped\nto similar methods in the library that underlies CanJS, but for libraries that\ndo not have the given methods, CanJS provides them for you. This way, you can\ncreate plugins for CanJS that work no matter what library someone else is using.</p>\n\n<h2>String utilities</h2>\n\n<p><code>can.trim</code> removes leading and trailing whitespace.</p>\n\n<pre><code class=\"lang-javascript\">can.trim(' foo '); // 'foo'</code></pre>\n\n<p><code>can.esc</code> escapes HTML code.</p>\n\n<pre><code class=\"lang-javascript\">can.esc('&lt;foo>&lt;bar>'); // '&amp;lt;foo&amp;gt;&amp;&amp;lt;bar&amp;gt;'</code></pre>\n\n<p><code>can.getObject</code> looks up an object by path.</p>\n\n<pre><code class=\"lang-javascript\">can.('foo.bar', [{foo: {bar: 'baz'}}]); // 'baz'</code></pre>\n\n<p><code>can.capitalize</code> capitalizes a string.</p>\n\n<pre><code class=\"lang-javascript\">can.('fooBar'); // 'FooBar'</code></pre>\n\n<p><code>can.sub</code> allows micro-templating.</p>\n\n<pre><code class=\"lang-javascript\">can.sub('{greet}, world!', {greet: 'Hello'}); // 'Hello, world!'</code></pre>\n\n<p><code>can.deparam</code> transforms a form-encoded string into an object..</p>\n\n<pre><code class=\"lang-javascript\">can.deparam('foo=bar&hello=world'); // {foo: 'bar', hello: 'world'}</code></pre>\n\n<h2>Array utilities</h2>\n\n<p><code>can.makeArray</code> converts array-like objects into real Arrays.</p>\n\n<pre><code class=\"lang-javascript\">can.makeArray({0: 'foo', 1: 'bar', length: 2}); // ['foo', 'bar']</code></pre>\n\n<p><code>can.isArray</code> checks if an object is an Array.</p>\n\n<pre><code class=\"lang-javascript\">can.isArray([]); // true</code></pre>\n\n<p><code>can.map</code> converts an array into another array using a callback.</p>\n\n<pre><code class=\"lang-javascript\">can.map(['foo', 'bar'], function(element, index) {\n    return el.toUppercase();\n}); // ['FOO', 'BAR']</code></pre>\n\n<p><code>can.each</code> iterates through an array.</p>\n\n<pre><code class=\"lang-javascript\">can.each([{prop: 'foo'}, {prop: 'bar'}], function(element, index) {\n    // this callback will be called with:\n    // element = {prop: 'foo'}, index = 0\n    // element = {prop: 'bar'}, index = 1\n});</code></pre>\n\n<h2>Object utilites</h2>\n\n<p><code>can.extend</code> extends one object with the properties of another.</p>\n\n<pre><code class=\"lang-javascript\">var first  = {},\n    second = {a: 'b', c: 'd'},\n    third  = {c: 'e'};\n\nvar extended = can.extend(first, second, third);\nextended === first; // true\nfirst;  // {a: 'b', c: 'e'}\nsecond; // {a: 'b', c: 'd'}\nthird;  // {c: 'e'}</code></pre>\n\n<p><code>can.param</code> turns an object into a query string.</p>\n\n<pre><code class=\"lang-javascript\">can.param({a: 'b', c: 'd'}); // 'a=b&c=d'</code></pre>\n\n<p><code>can.isEmptyObject</code> checks whether an object is empty.</p>\n\n<pre><code class=\"lang-javascript\">can.isEmptyObject({});           // true\ncan.isEmptyObject({foo: 'bar'}); // false</code></pre>\n\n<h2>Function utilites</h2>\n\n<p><code>can.proxy</code> returns a function that calls another function with a set context.</p>\n\n<pre><code class=\"lang-javascript\">var f = can.proxy(function(str) {\n    return this.a + str;\n}, {a: 'b'});\nf('bar'); // 'bbar'</code></pre>\n\n<p><code>can.isFunction</code> checks whether an object is a function.</p>\n\n<pre><code class=\"lang-javascript\">can.isFunction({});             // false\ncan.isFunction(function() { }); // true</code></pre>\n\n<h2>Event utilities</h2>\n\n<p><code>can.bind</code> binds a callback to an event on an object.</p>\n\n<pre><code class=\"lang-javascript\">can.bind(obj, eventName, handler); // Binds handler on obj's eventName event.</code></pre>\n\n<p><code>can.unbind</code> unbinds a callback from an event on an object.</p>\n\n<pre><code class=\"lang-javascript\">can.unbind(obj, eventName, handler); // Unbinds handler from obj's eventName event.</code></pre>\n\n<p><code>can.delegate</code> binds a callback to an event on an all elements that match a selector.</p>\n\n<pre><code class=\"lang-javascript\">can.delegate(obj, eventName, handler); // Binds handler on eventName events from all elements under obj that match selector.</code></pre>\n\n<p><code>can.undelegate</code> unbinds a callback from an event on an all elements that\nmatch a selector.</p>\n\n<pre><code class=\"lang-javascript\">can.undelegate(obj, eventName, handler); // Unbinds handler from eventName events from all elements under obj that match selector.</code></pre>\n\n<p><code>can.trigger</code> triggers an event on an object.</p>\n\n<pre><code class=\"lang-javascript\">can.trigger(obj, eventName, args); // Executes all handlers attached to obj for eventName with args as additional arguments.</code></pre>\n\n<h2>AJAX utilites</h2>\n\n<p><code>can.ajax</code> will make an AJAX call and return a Deferred that resolves when the\ncall has returned.</p>\n\n<pre><code class=\"lang-javascript\">can.ajax({\n    url: '/path/to/url',\n    type: 'GET',\n    async: true,\n    dataType: 'json',\n    success: function(json) { },\n    error: function(xhr) { }\n});</code></pre>\n\n<h2>Element utilities</h2>\n\n<p><code>can.$</code> creates a library-wrapped NodeList.</p>\n\n<pre><code class=\"lang-javascript\">can.$(div.bar); // (in jQuery, a jQuery.fn object)</code></pre>\n\n<p><code>can.append</code> appends elements to the elements in a NodeList.</p>\n\n<pre><code class=\"lang-javascript\">can.append(nodelist, content); // Appends content to each element in nodelist.</code></pre>",
                    "description": "",
                    "title": "Utilities",
                    "parent": "Tutorial",
                    "order": 9,
                    "comment": " ",
                    "src": "_guides/util.md",
                    "id": 23
                }
            ]
        }, {
            "active": false,
            "type": "page",
            "name": "Why",
            "body": "<h2>Flexible</h2>\n\n<p>Your library should not break-down as your application and organization grow and technologies change. CanJS’s flexibility will keep it valuable to you far into the future.</p>\n\n<h3>Supports multiple libraries and frameworks</h3>\n\n<p>Want to share code between a Zepto mobile app and a jQuery desktop app? No problem. CanJS code (especially models) can be shared across libraries, and so can skill sets! Working on a Dojo project today and a YUI one tomorrow? Don’t throw away all of your skills.</p>\n\n<h3>Designed for plugins</h3>\n\n<p>CanJS is extracted from <a href=\"http://javascriptmvc.com/\">JavaScriptMVC</a>, but currently supports almost all of its MVC functionality through plugins. Start small, with its basic functionality, and extend it with <a href=\"http://canjs.com/#plugins\">plugins</a> that handle things like:</p>\n\n<ul>\n<li>setters</li>\n<li>serialization / deserialization</li>\n<li>jQuery plugin generation</li>\n<li>validations</li>\n<li>calling super methods</li>\n</ul>\n\n<p>These plugins have forced the core to be quite extendable, making 3rd party plugin development easy.</p>\n\n<h3>Engineered limber</h3>\n\n<p>CanJS’s tools are designed to work under almost every situation. Your server sends back XML with strange urls? That’s ok, overwrite <a href=\"../docs/can.Model.static.findAll.html\">can.Model.findAll</a> or <a href=\"../docs/can.Model.static.models.html\">can.Model.models</a>. Want some special teardown code for a control? Overwrite <a href=\"../docs/can.Model.prototype.destroy.html\">can.Control:destroy</a>.</p>\n\n<p>But our favorite bit of flexibility is how <a href=\"../docs/can.Observe.html\">can.Observe</a> works with nested data. It converts nested objects into observes automatically. For example:</p>\n\n<pre><code class=\"lang-javascript\">var person = new can.Observe({\n  name: { first: 'Justin', last: 'Meyer' },\n  hobbies: [ 'programming', 'party rocking' ]\n})\n\nperson.attr( 'name.first' ) //-> 'Justin'\nperson.attr( 'hobbies.0' ) //-> 'programming'</code></pre>\n\n<p>But most important, <code>change</code> events bubble, letting observes listen for when a nested property changes:</p>\n\n<pre><code class=\"lang-javascript\">person.bind( 'change', function( ev, attr, how, newVal, oldVal ) {\n  attr   //-> 'name.last'\n  how    //-> 'set'\n  newVal //-> 'Meyer'\n  oldVal //-> 'Myer'\n});\n\nperson.attr( 'name.last', 'Meyer' );</code></pre>\n\n<h2>Powerful</h2>\n\n<h3>Safety</h3>\n\n<p>Memory safety is really important, especially in long-lived, dynamic pages. CanJS combats this menace in two important and unique ways:</p>\n\n<h4>Controls that unbind event handlers auto-magically</h4>\n\n<p>Using templated event binding, Controls can listen to events on objects other than their element. For example, a tooltip listening to the window looks like:</p>\n\n<pre><code class=\"lang-javascript\">var Tooltip = can.Control({\n  '{window} click': function( el, ev ) {\n    // hide only if we clicked outside the tooltip\n    if (!this.element.has( ev.target ) {\n      this.element.remove();\n    }\n  }\n})\n\n// create a Tooltip\nvar tooltipElement = $( '&lt;div>INFO&lt;/div>' ).appendTo( el )\nvar tooltipInstance = new Tooltip( tooltipElement );</code></pre>\n\n<p><code>window</code> now has a reference to the control which keeps the <code>tooltipInstance</code> and everything the tooltip instance might reference in memory. CanJS overwrites each library’s element remove functionality to <a href=\"http://canjs.com/#can_control-destroy\">destroy</a> controls. Destroying a control unbinds all of its event handlers, removing any memory leaks auto-magically.</p>\n\n<h4>A model store that does not leak</h4>\n\n<p>It’s relatively common to load the same model instance multiple times on a single page. For example, an app might request todos due today and high-priority todos and render them like:</p>\n\n<pre><code class=\"lang-javascript\">can.view( 'todosList.ejs', {\n  todaysTodos: Todo.findAll( { due: 'today' } ),\n  criticalTodos: Todo.findAll( { type: 'critical' } )\n}).then(function( frag ) {\n  $( '#todos' ).html( frag );\n})</code></pre>\n\n<p><code>todosList.ejs</code> might look like:</p>\n\n<pre><code class=\"lang-javascript\">&lt;h2>Due Today&lt;/h2>\n&lt;% list( todaysTodos, function( todo ) { %>\n  &lt;li &lt;%= (el) -> el.data( 'todo', todo ) %>>\n    &lt;%= todo.attr( 'name' ) %>\n  &lt;/li>\n&lt;% } ) %>\n&lt;h2>Critical Todos</h2>\n&lt;% list( criticalTodos, function( todo ) { %>\n  &lt;li <%= (el) -> el.data( 'todo', todo ) %>>\n    &lt;%= todo.attr( 'name' ) %>\n  &lt;/li>\n&lt;% } ) %></code></pre>\n\n<p>If the result for of <code>Todo.findAll( { due: 'today' } )</code> and <code>Todo.findAll( { type: 'critical' } )</code> both share a todo instance like:</p>\n\n<pre><code class=\"lang-javascript\">{ \n    \"id\" : 5, \n    \"name\" : \"do dishes\",\n    \"due\" : \"today\",\n    \"type\" : \"critical\"\n}</code></pre>\n\n<p>[Models can.Model] knows that this data represents the same todo and only creates one instance. This means that a single model instance is in both lists. By changing the todo’s name or destroying it, both lists will be changed.</p>\n\n<p>However, model only stores these model instances while something is binding to them. Once nothing is bound to the model instance, they are removed from the store, freeing their memory for garbage collection.</p>\n\n<h3>Ease of use</h3>\n\n<p>This site highlights the most important features of CanJS. The library comes with thorough documentation and examples on the <a href=\"/docs\">CanJS documentation page</a>. There are example apps for each library and several example for jQuery.</p>\n\n<p>CanJS is also supported by <a href=\"http://bitovi.com/\">Bitovi</a>. We are extremely active on the <a href=\"https://forum.javascriptmvc.com/#Forum/canjs\">forums</a>. And should the need arise, we provide support, training, and development.</p>\n\n<h2>Fast</h2>\n\n<h3>Size</h3>\n\n<p>On top of jQuery, CanJS is ~11k. Here’s some other frameworks for comparison:</p>\n\n<ul>\n<li>Backbone 8.97kb (with Underscore.js)</li>\n<li>Angular 24kb</li>\n<li>Knockout 13kb</li>\n<li>Ember 37kb</li>\n<li>Batman 15kb</li>\n</ul>\n\n<p>Size is not everything. It really is what’s inside that counts. And that’s where we think CanJS really delivers a lot of bang for your buck.</p>\n\n<h3>Speed</h3>\n\n<p>The importance of performance is almost impossible to exaggerate. CanJS’s guts are highly optimized. See how:</p>\n\n<h4>Control initialization</h4>\n\n<p>[Controls can.Control] pre-processes event handlers so binding is super fast. Compare <a href=\"http://jsperf.com/tabs-timing-test/7\">initializing a can.Control, Backbone.View and Ember.View tabs</a> widget:\n<a href=\"http://jsperf.com/tabs-timing-test/7\"><img src=\"http://bitovi.com/images/introducing-canjs/performance_control.png\" alt=\"Control performance\" title=\"\" /></a></p>\n\n<h4>Tabs initialization performance</h4>\n\n<p>This makes a big difference for page initialization if your site has lots of controls.</p>\n\n<h4>Live binding</h4>\n\n<p>CanJS’s live-binding is very fast. It only updates what’s necessary when it’s necessary. Compare its <a href=\"http://jsperf.com/canjs-ejs-performance/5\">template rendering performance with three other common MVC frameworks</a>:\n<a href=\"http://jsperf.com/canjs-ejs-performance/5\"><img src=\"http://bitovi.com/images/introducing-canjs/performance_livebind.png\" alt=\"Live binding performance\" title=\"\" /></a></p>\n\n<p>In this test, CanJS has the fastest live-binding. Backbone and YUI are not doing live-binding, but CanJS is still the fastest.</p>\n\n<p>In the <a href=\"http://jsfiddle.net/JMWf4/47/\">popular counting circle example</a>, Knockout visually appears the fastest, followed by CanJS.</p>\n\n<p>This means that CanJS and Knockout are slightly faster at different things, but are likely tied for the fastest live-binding libraries.</p>\n\n<p><em>Note: AngularJS throttles updates, which means it doesn’t fit well with these tests.</em></p>\n\n<h4>Model and view deferred support for parallel loading</h4>\n\n<p>[Deferreds Deferreds] are simply awesome for handling asynchronous behavior. [Models can.Model] produces deferreds and <a href=\"../docs/can.view.html\">can.view</a> consumes them. With the view modifiers plugin, you can load a template and its data in parallel and render it into an element with:</p>\n\n<pre><code class=\"lang-javascript\">$( '#todos' ).html( 'todos.ejs', Todo.findAll() );</code></pre>\n\n<p>Hot. You can do this without the view modifiers plugin like:</p>\n\n<pre><code class=\"lang-javascript\">can.view( 'todos.ejs', Todo.findAll() ).then(function( frag ) {\n  $( '#todos' ).html( frag );\n})</code></pre>\n\n<h4>Opt-in data binding</h4>\n\n<p>Although [EJS can.EJS’s] live-binding is super fast, setting up live data binding can be too slow in certain situations (like rendering a list of 1000 items). EJS’s live binding is opt-in. It only turns on if you are using the <code>attr</code> method. If the following template binds to a <code>todo</code>'s <code>name</code> …</p>\n\n<pre><code class=\"lang-javascript\">&lt;li> &lt;%= todo.attr('name') %> &lt;/li></code></pre>\n\n<p>… the following doesn’t setup live-binding and renders much faster …</p>\n\n<pre><code class=\"lang-javascript\">&lt;li> &lt;%= todo.name %> &lt;/li></code></pre>",
            "description": "",
            "title": "Why CanJS?",
            "parent": "guides",
            "order": 2,
            "comment": " ",
            "src": "_guides/why.md",
            "id": 25
        }, {
            "active": false,
            "type": "page",
            "name": "Using",
            "body": "",
            "description": "<p>CanJS can be used with jQuery, Dojo, Mootools, YUI and Zepto and as AMD modules with any of these libraries.</p>\n\n<h2>AMD</h2>\n\n<p>The <a href=\"http://canjs.us/downloads/can.js.{{page.version}}.zip\">CanJS Download</a> contains an <code>amd</code> folder which allows\nyou to load any CanJS component and plugin using an AMD module loader like <a href=\"http://requirejs.org/\">RequireJS</a>.\njQuery will be the default library so make sure the <code>jquery</code> module id points to the jQuery source.\nHere is an example for jQuery and RequireJS:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/javascript\" src=\"require.js\">&lt;/script>\n&lt;script type=\"text/javascript\">\n  require.config({\n    paths : {\n      \"jquery\" : \"http://code.jquery.com/jquery-1.8.2\"\n    }\n  });\n\n  require(['can/view/ejs', 'can/control'], function(can) {\n    // Use EJS and Control\n  });\n&lt;/script></code></pre>\n\n<p>The <code>can</code> module is a shortcut that loads CanJS's core plugins (Construct, Control, route, Model, view, and EJS)\nand returns the <code>can</code> namespace.</p>\n\n<pre><code class=\"lang-javascript\">require(['can'], function(can) {\n  // Use can.Control, can.view, can.Model etc.\n});</code></pre>\n\n<p>If you would like to use another library, map the <code>can/util/library</code> module to <code>can/util/dojo</code>, <code>can/util/zepto</code>,\n<code>can/util/yui</code> or <code>can/util/mootools</code>.</p>\n\n<p>With RequireJS and Zepto, it loks like this:</p>\n\n<pre><code class=\"lang-javascript\">require.config({\n  map : {\n    '*' : {\n          \"can/util/library\" : \"can/util/zepto\"\n      }\n  },\n  paths: {\n    \"zepto\" : \"http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min\"\n  }\n});</code></pre>\n\n<h2>jQuery</h2>\n\n<p>CanJS supports jQuery 1.8+. Include a copy of jQuery along with CanJS to get started.</p>\n\n<pre><code class=\"lang-javascript\">&lt;script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.js\">\n&lt;/script>\n&lt;script src=\"can.jquery.js\">&lt;/script>\n&lt;script>\n  // start using CanJS\n  can.Model('Todo', {\n    ...\n  });\n&lt;/script></code></pre>\n\n<p>CanJS supports binding to any jQuery objects (like jQuery UI widgets) that use standard\njQuery events. The jQuery UI Datepicker doesn't have built-in support for standard\njQuery events, so for those cases, a workaround should be applied:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.js\">\n&lt;/script>\n&lt;script src=\"jquery.ui.core.js\">&lt;/script>\n&lt;script src=\"jquery.ui.datepicker.js\">&lt;/script>\n&lt;script src=\"can.jquery.js\">&lt;/script>\n&lt;script>\n  // create models\n  Todo = can.Model({ ... });\n  Todo.List = can.Model.List({ ... });\n\n  // create control\n  Todos = can.Control({\n    // listen to the calendar widget's datepickerselect event\n    '{calendar} datepickerselect': function(calendar, ev){\n      // do something with the selected date\n      var selectedDate = this.options.calendar.datepicker('getDate');\n      ...\n    }\n  });\n\n  // Initialize the app\n  Todo.findAll({}, function(todos) {\n    new Todos('#todoapp', {\n      todos: todos,\n      calendar: $('#calendar').hide().datepicker({\n        // Adding a workaround for date selection since the\n        // jQuery UI datepicker widget doesn't fire the\n        // \"datepickerselect\" event\n        onSelect: function(dateText, datepicker) {\n          $(this).trigger({\n            type: 'datepickerselect',\n            text: dateText,\n            target: datepicker\n          });\n        }\n      })\n    });\n  });\n&lt;/script></code></pre>\n\n<h2>Dojo</h2>\n\n<p>CanJS supports Dojo 1.8+ using its new AMD loader in asynchronous or synchronous mode. Everything described in the\n<a href=\"#using_canjs-amd\">using CanJS and AMD</a> section applies to Dojo as well. An example configuration that uses the AMD files\nfrom the CanJS CDN can look like this:</p>\n\n<pre><code class=\"lang-javascript\">require({\n    aliases:[\n        ['can/util/library', 'can/util/dojo']\n    ],\n    baseUrl : 'http://canjs.us/release/latest/amd/can.js',\n});\n\nrequire(['can/control'], function(Control) {\n  // Use Control\n});</code></pre>\n\n<h2>Mootools</h2>\n\n<p>CanJS supports Mootools 1.4+. Include a copy of Mootools Core along with CanJS to get started.</p>\n\n<p>Mootools Core has an issue where <strong>focus</strong> and <strong>blur</strong> events are not fired for delegate event listeners.\nInclude Mootools More's Event.Pseudos module for <strong>focus</strong> and <strong>blur</strong> support.</p>\n\n<pre><code class=\"lang-javascript\">&lt;script src=\"https://ajax.googleapis.com/ajax/libs/mootools/1.4.5/\nmootools.js\">&lt;/script>\n&lt;!-- Mootools More Event.Pseudos module -->\n&lt;script src=\"mootools-more-event_pseudos-1.4.0.1.js\">&lt;/script>\n&lt;script src=\"can.mootools.js\">&lt;/script>\n&lt;script>\n  // start using CanJS\n  Todo = can.Model({\n    ...\n  });\n&lt;/script></code></pre>\n\n<h2>YUI</h2>\n\n<p>CanJS supports YUI 3.4+ with both dynamically or statically loaded modules.\nCanJS depends on the following YUI modules: <strong>node</strong>, <strong>io-base</strong>, <strong>querystring</strong>, <strong>event-focus</strong>, and <strong>array-extras</strong>. The <strong>selector-css2</strong> and <strong>selector-css3</strong> YUI modules are optional, but necessary for IE7 and other browsers that don't support <strong>querySelectorAll</strong>.</p>\n\n<p>To use with dynamically loaded modules, include the YUI loader along with CanJS.\nAdd <code>'can'</code> to your normal list of modules with <code>YUI().use('can', ...)</code> wherever CanJS will be used.</p>\n\n<pre><code class=\"lang-javascript\">&lt;script src=\"http://yui.yahooapis.com/3.4.1/build/yui/yui-min.js\">&lt;/script>\n&lt;script src=\"can.yui.js\">&lt;/script>\n&lt;script>\n  // CanJS with support for modern browsers\n  YUI().use('can', function(Y) {\n    // start using CanJS\n    Todo = can.Model({\n      ...\n    });\n  });\n\n  // CanJS with support for IE7 and other browsers without querySelectorAll\n  YUI({ loadOptional: true }).use('can', function(Y) {\n    // start using CanJS\n    Todo = can.Model({\n      ...\n    });\n  });\n&lt;/script></code></pre>\n\n<p>To use with statically loaded modules, include a static copy of YUI (with the\npreviously mentioned YUI dependencies) along with CanJS. CanJS will automatically\nbe included wherever <code>YUI().use('*')</code> is used.</p>\n\n<pre><code class=\"lang-javascript\">&lt;!-- YUI Configurator: http://yuilibrary.com/yui/configurator/ -->\n&lt;script src=\"http://yui.yahooapis.com/combo?3.7.3/build/yui-base/yui-base-min.\njs&3.7.3/build/oop/oop-min.js&3.7.3/build/event-custom-base/event-custom-base-\nmin.js&3.7.3/build/features/features-min.js&3.7.3/build/dom-core/dom-core-min.\njs&3.7.3/build/dom-base/dom-base-min.js&3.7.3/build/selector-native/selector-n\native-min.js&3.7.3/build/selector/selector-min.js&3.7.3/build/node-core/node-c\nore-min.js&3.7.3/build/node-base/node-base-min.js&3.7.3/build/event-base/event\n-base-min.js&3.7.3/build/event-delegate/event-delegate-min.js&3.7.3/build/node\n-event-delegate/node-event-delegate-min.js&3.7.3/build/pluginhost-base/pluginh\nost-base-min.js&3.7.3/build/pluginhost-config/pluginhost-config-min.js&3.7.3/b\nuild/node-pluginhost/node-pluginhost-min.js&3.7.3/build/dom-style/dom-style-mi\nn.js&3.7.3/build/dom-screen/dom-screen-min.js&3.7.3/build/node-screen/node-scr\neen-min.js&3.7.3/build/node-style/node-style-min.js&3.7.3/build/querystring-st\nringify-simple/querystring-stringify-simple-min.js&3.7.3/build/io-base/io-base\n-min.js&3.7.3/build/array-extras/array-extras-min.js&3.7.3/build/querystring-p\narse/querystring-parse-min.js&3.7.3/build/querystring-stringify/querystring-st\nringify-min.js&3.7.3/build/event-custom-complex/event-custom-complex-min.js&3.\n4.1/build/event-synthetic/event-synthetic-min.js&3.7.3/build/event-focus/event\n-focus-min.js\">&lt;/script>\n&lt;script src=\"can.yui.js\">&lt;/script>\n&lt;script>\n    // start using CanJS\n    Todo = can.Model({\n      ...\n    });\n&lt;/script></code></pre>\n\n<p>CanJS can also bind to YUI widget events. The following example shows how to\nbind to the <strong>selectionChange</strong> event for a YUI Calendar widget:</p>\n\n<pre><code class=\"lang-javascript\">YUI().use('can', 'calendar', function(Y) {\n  // create models\n  Todo = can.Model({ ... });\n  Todo.List = can.Model.List({ ... });\n\n  // create control\n  Todos = can.Control({\n    // listen to the calendar widget's selectionChange event\n    '{calendar} selectionChange': function(calendar, ev){\n      // do something with the selected date\n      var selectedDate = ev.newSelection[0];\n      ...\n    }\n  });\n\n  // initialize the app\n  Todo.findAll({}, function(todos) {\n    new Todos('#todoapp', {\n      todos: todos,\n      calendar: new Y.Calendar({\n        contentBox: \"#calendar\"\n      }).render()\n    });\n  });\n});</code></pre>\n\n<h2>Zepto</h2>\n\n<p>CanJS supports Zepto 0.8+. Include a copy of Zepto along with CanJS to get started.</p>\n\n<p>Zepto 0.8 has an issue where <strong>focus</strong> and <strong>blur</strong> events are not fired for delegate event listeners.\nThere is a fix included for Zepto > 0.8, but you can apply\n<a href=\"https://github.com/madrobby/zepto/commit/ab2a3ef0d18beaf768903f0943efd019a29803f0\">this patch</a>\nto <strong>zepto.js</strong> when using Zepto 0.8.</p>\n\n<pre><code class=\"lang-javascript\">&lt;!-- Zepto 0.8 with focus/blur patch applied -->\n&lt;script src=\"zepto.0.8-focusblur.js\">&lt;/script>\n&lt;script src=\"can.zepto.js\">&lt;/script>\n&lt;script>\n  // start using CanJS\n  Todo = can.Model({\n    ...\n  });\n&lt;/script></code></pre>",
            "title": "Using CanJS",
            "parent": "guides",
            "order": 3,
            "src": "_guides/using.md",
            "id": 22
        }, {
            "active": false,
            "type": "page",
            "name": "contributing",
            "body": "",
            "description": "<!--\n-->\n\n<h2>Contributing</h2>\n\n<p>When contributing, include tests with new features or bug fixes in a feature branch until you're ready to submit the code for consideration; then fork the repository, push to the fork, and issue a pull request.</p>\n\n<p>Clone the branch and create a new feature branch.</p>\n\n<pre><code>$ git clone git://github.com/bitovi/canjs.git\n$ git branch html5-fix\n$ git checkout html5-fix\n</code></pre>\n\n<p>Add the new remote to your local repository on your local machine.</p>\n\n<pre><code>$ git remote add github git@github.com:bitovi/canjs.git\n</code></pre>\n\n<p>Once your happy with your changes, push to the feature branch.</p>\n\n<pre><code>$ git push github html5-fix\n</code></pre>\n\n<p>Now that we have pushed all the changes to the repo, we need to submit a Pull Request to the main branch.  Navigate to <a href=\"https://github.com/bitovi/canjs/pulls\">Pull Requests</a> and click 'Pull Request' in the top navigation bar.  Fill in some details about your potential patch including a meaningful title. When finished, press \"Send pull request\". The core team will be notified about your submission and let you know of any problems or targeted release date.</p>\n\n<h2>Developing</h2>\n\n<p>After installing CanJS, you’ll find a folder for each feature of CanJS: <code>construct</code>, <code>control</code>, <code>model</code>, etc.</p>\n\n<p>Within each feature folder, for example <code>construct</code>, you’ll find a file for:</p>\n\n<ul>\n<li>the implementation of the feature - <code>construct.js</code></li>\n<li>a demo of the feature - <code>construct.html</code></li>\n<li>an overview documentation page - <code>construct.md</code></li>\n<li>the feature’s tests - <code>construct_test.js</code></li>\n<li>a page to run those tests - <code>qunit.html</code></li>\n</ul>\n\n<p>Any plugins for that feature will be folders within the feature’s folder. Ex: <code>proxy</code>, <code>super</code>.</p>\n\n<p>The <code>can/test</code> folder contains:</p>\n\n<ul>\n<li>a <code>test.html</code> page which tests jQuery by default. Load e.g. <code>test.html?library=mootools</code> to test another library.</li>\n<li>a test page that tests all libraries and plugins: <code>index.html</code></li>\n<li>a file that loads all feature tests: <code>can_test.js</code></li>\n<li>a <code>plugin_test.html</code> file that tests all plugins</li>\n</ul>\n\n<p>The <code>can/util</code> folder contains the compatibility layer for each library.</p>\n\n<p>To develop CanJS:</p>\n\n<ol>\n<li>Edit the feature’s file.</li>\n<li>Add tests to the feature’s test file.</li>\n<li>Open the feature’s test page. Make sure it passes.</li>\n<li>Open can/test/index.html in every browser to test everything.</li>\n<li>Submit a pull request!</li>\n</ol>\n\n<h2>Documentation</h2>\n\n<p>If your pull request affects the public API, make relevant changes to the documentation.  Documentation is found either inline or in markdown files in the respective directory.</p>\n\n<h2>Reporting Bugs</h2>\n\n<p>To report a bug, please visit <a href=\"https://github.com/bitovi/canjs/issues\">GitHub Issues</a>.  </p>\n\n<p>When filing a bug, its helpful to include:</p>\n\n<ul>\n<li>Small examples using tools like <a href=\"http://jsbin.com/\">JSBin</a></li>\n<li>Breaking unit tests</li>\n<li>Proposed fix solutions</li>\n<li>Search for previous tickets, if there is one add to that one rather than creating another.</li>\n</ul>\n\n<p>You can also post on the <a href=\"https://forum.javascriptmvc.com/canjs\">Forums</a> or talk to us in <a href=\"http://webchat.freenode.net/?channels=canjs\">IRC #canjs channel</a>.</p>\n\n<h2>Running Tests Locally</h2>\n\n<p>Its important that all tests pass before sending a pull request.  TravisCI will determine if your commits pass the tests, but while your developing you can run the QUnit tests locally.  </p>\n\n<p>Open <code>~/can/test/tests.html</code> in a web browser to run the tests locally.  Each module has its own tests too, you can run them by opening the <code>qunit.html</code> in each folder.</p>\n\n<p>CanJS supports the following browsers:</p>\n\n<ul>\n<li>Chrome Current-1</li>\n<li>Safari Current-1</li>\n<li>Firefox Current-1</li>\n<li>IE 7+</li>\n<li>Opera Current-1</li>\n</ul>\n\n<h2>Style Guide</h2>\n\n<h3>Linting</h3>\n\n<p>Grunt provides a JSHint task to verify some basic, practical soundness of the codebase. The options are preset.</p>\n\n<h3>Spacing</h3>\n\n<p>Indentation with tabs, not spaces.</p>\n\n<p><code>if/else/for/while/try</code> always have braces, with the first brace on the same line.  For example:</p>\n\n<pre><code>if(foo){\n\n}\n</code></pre>\n\n<p>Spaces after commas.  For example:</p>\n\n<pre><code>myfn = function(foo, bar, moo){ ... }\n</code></pre>\n\n<h3>Assignments</h3>\n\n<p>Assignments should always have a semicolon after them.</p>\n\n<p>Assignments in a declaration should always be on their own line. Declarations that don't have an assignment should be listed together at the start of the declaration. For example:</p>\n\n<pre><code>// Bad\nvar foo = true;\nvar bar = false;\nvar a;\nvar b;\n\n// Good\nvar a, b,\n    foo = true,\n    bar = false;\n</code></pre>\n\n<h3>Equality</h3>\n\n<p>Strict equality checks <code>===</code> should be used in favor of <code>==</code>. The only exception is when checking for undefined and null by way of null.</p>\n\n<pre><code>// Bad\nif(bar == \"can\"){ ... }\n\n// Good\nif(bar === \"can\"){ ... }\n</code></pre>\n\n<p>If the statement is a truthey or falsey, use implied operators.  Falseys are when variables return <code>false</code>, <code>undefined</code>, <code>null</code>, or <code>0</code>.  Trutheys are when variables return <code>true</code>, <code>1</code>, or anything defined.</p>\n\n<p>For example:</p>\n\n<pre><code>// Bad\nif(bar === false){ ... }\n\n// Good \nif(bar){ ... }\n\n// Good\nvar foo = [];\nif(!foo.length){ ... }\n</code></pre>\n\n<h3>Quotes</h3>\n\n<p>Use double quotes.</p>\n\n<pre><code>var double = \"I am wrapped in double quotes\";\n</code></pre>\n\n<p>Strings that require inner quoting must use double outside and single inside.</p>\n\n<pre><code>var html = \"&lt;div id='my-id'&gt;&lt;/div&gt;\";\n</code></pre>\n\n<h3>Comments</h3>\n\n<p>Single line comments go OVER the line they refer to:</p>\n\n<pre><code>// We need an explicit \"bar\", because later in the code foo is checked.\nvar foo = \"bar\";\n</code></pre>\n\n<p>For long comments, use:</p>\n\n<pre><code>/* myFn\n * Four score and seven—pause—minutes ago...\n  */\n</code></pre>\n\n<h2>List of heroes</h2>\n\n<p>The following lists everyone who's contributed something to CanJS.  If we've forgotten you, please add yourself.</p>\n\n<p>First, thanks to everyone who's contributed to <a href=\"https://github.com/bitovi/javascriptmvc/contributors\">JavaScriptMVC</a>\nand <a href=\"https://github.com/jupiterjs/jquerymx/contributors\">jQueryMX</a>, and the people at\n<a href=\"http://bitovi.com/people/\">Bitovi</a>.  You deserve heaps of recognition as CanJS is direcly based\noff JavaScriptMVC.  This page is for contributors after CanJS's launch. Thank you</p>\n\n<ul>\n<li><a href=\"https://github.com/iamnoah\">noah</a>\n(<a href=\"https://github.com/bitovi/canjs/commit/8193e359cde3b77a44c683ca9f8a5268fc9df44b\">1</a>,\n<a href=\"https://github.com/bitovi/canjs/commit/b865588710e7e7dd8a9588ebf8e8c0f4d19fd800\">2</a>,\n<a href=\"https://github.com/bitovi/canjs/commit/83a48e7bcb05ed9f179159f540b181db4dcf6e9c\">3</a>,\n<a href=\"https://github.com/Spredfast/canjs/commit/dc7ddd2dc619619f3955c31be1435c6f927b7a35\">4</a>,\n<a href=\"https://github.com/bitovi/canjs/pull/214\">5</a>, <a href=\"https://github.com/bitovi/canjs/pull/310\">6</a>)</li>\n<li><a href=\"https://github.com/thecountofzero\">thecountofzero</a>\n(<a href=\"https://github.com/bitovi/canjs/commit/e920434fa53975013688d065ce2e304f225fae75\">1</a>,\n<a href=\"https://github.com/bitovi/canjs/commit/8e98186e00b7d6b88869baeb97244877f143034e\">2</a>,\n<a href=\"https://github.com/bitovi/canjs/pull/315\">3</a>)</li>\n<li><a href=\"https://github.com/roissard\">roissard</a> (<a href=\"https://github.com/bitovi/canjs/commit/44bc72063e429bbc3f8a9a696a3ae4a7e57d12c8\">1</a>,\n<a href=\"https://github.com/bitovi/canjs/commit/c711fe05e1cdc99c72df8ac0f415c2ccb536d197\">2</a>)</li>\n<li><a href=\"https://github.com/makebbekus\">Michael Kebbekus</a>\n(<a href=\"https://github.com/bitovi/canjs/commit/d658d4910e8f3f391e9394449efe2f0c67581dbe\">1</a>)</li>\n<li>Daniel Salet (<a href=\"https://github.com/bitovi/canjs/commit/92487178255360d40b75be49681dc65cbfbf3e18\">1</a>)</li>\n<li><a href=\"https://github.com/daniel-franz\">Daniel Franz</a>\n(<a href=\"https://github.com/bitovi/canjs/commit/4aae36eea9d671a12f9c459733c48b6fd1e99af4\">1</a>)</li>\n<li><a href=\"https://github.com/trickeyone\">trickeyone</a>\n(<a href=\"https://github.com/trickeyone/canjs/commit/2c11f56e0a0511749243055276e3b806984b15fa\">1</a>)</li>\n<li><a href=\"https://github.com/rjgotten\">rjgotten</a>\n(<a href=\"https://github.com/bitovi/canjs/commit/92c98e7c80d5fd7357eae69a60313d3d06efbdcb\">1</a>)</li>\n<li>Amy Chen (<a href=\"https://github.com/bitovi/canjs/commit/3eee6ba9c69410ac549b909b1c8f860e6d591612\">1</a>)</li>\n<li><a href=\"https://github.com/ms\">Max Sadrieh</a>\n(<a href=\"https://github.com/bitovi/canjs/commit/06c5a4b3d50d14c5881ee55642fa10f37b71af0b\">1</a>)</li>\n<li><a href=\"https://github.com/dimaf\">dimaf</a>\n(<a href=\"https://github.com/bitovi/canjs/commit/fc8a4d57c99a280025eb7c613cef92de28c3c160\">1</a>,\n<a href=\"https://github.com/bitovi/canjs/pull/145\">2</a>)</li>\n<li><a href=\"https://github.com/yusufsafak\">yusufsafak</a> (<a href=\"https://github.com/bitovi/canjs/pull/30\">1</a>)</li>\n<li><a href=\"https://github.com/verto\">verto</a> (<a href=\"https://github.com/bitovi/canjs/pull/32\">1</a>)</li>\n<li><a href=\"https://github.com/WearyMonkey\">WearyMonkey</a> (<a href=\"https://github.com/bitovi/canjs/issues/27\">1</a>)</li>\n<li><a href=\"https://github.com/cohuman\">cohuman</a>\n(<a href=\"https://github.com/bitovi/canjs/pull/23\">1</a>, <a href=\"https://github.com/bitovi/canjs/pull/26\">2</a>)</li>\n<li><a href=\"https://twitter.com/roelmonnens\">roelmonnens</a></li>\n<li><a href=\"https://github.com/mindscratch\">Craig Wickesser</a> (<a href=\"https://github.com/bitovi/canjs/pull/188\">1</a>)</li>\n<li><a href=\"https://github.com/jeffrose\">Jeff Rose</a> (<a href=\"https://github.com/bitovi/canjs/pull/201\">1</a>)</li>\n<li><a href=\"https://github.com/bmomberger-reciprocity\">Brad Momberger</a> (<a href=\"https://github.com/bitovi/canjs/pull/292\">1</a>)</li>\n<li><a href=\"https://github.com/scorphus\">Pablo Aguiar</a> (<a href=\"https://github.com/bitovi/canjs/pull/303\">1</a>,\n<a href=\"https://github.com/bitovi/canjs/pull/313\">2</a>,\n<a href=\"https://github.com/bitovi/canjs/pull/317\">3</a>)</li>\n<li><a href=\"https://github.com/schovi\">David Schovanec</a> (<a href=\"https://github.com/bitovi/canjs/pull/325\">1</a>,\n<a href=\"https://github.com/bitovi/canjs/pull/332\">2</a>)</li>\n<li><a href=\"https://github.com/onyxrev\">Dan Connor</a> (<a href=\"https://github.com/bitovi/canjs/pull/284\">1</a>)</li>\n<li><a href=\"https://github.com/jebaird\">Jesse Baird</a> (<a href=\"https://github.com/bitovi/canjs/pull/319\">1</a>)</li>\n</ul>\n\n<p>for helping us with new features, bug fixes, and getting this out the door.</p>",
            "title": "Contributing to CanJS",
            "parent": "guides",
            "order": 4,
            "src": "can/contributing.md",
            "id": 27
        }, {
            "active": false,
            "type": "page",
            "name": "changelog",
            "body": "",
            "description": "<!--\n-->\n\n<p><strong>1.1.5</strong> ( Mar 28 2013 )</p>\n\n<ul>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/335\">Added Mustache.resolve to evaluate truthyness in a common way #333</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/334\">Fixed incorrect passing of context stacks with partials in Mustache #288</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/333\">Mustache {{#if}} does not correctly evaluate boolean value</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/332\">deparam: parse params with remaining ampersand</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/329\">Null objects within observes weren't working properly with Mustache sections #307</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/328\">Mustache: Pass raw array data as the context instead of trying to resolve it #281</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/325\">Allow to pass an array index to removeAttr in Observe and Observe.List</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/322\">fixing no arg helpers</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/321\">Mustache interpolation issues using Observes inside of an attribute tag</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/319\">isObject is undefined </a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/318\">Allow dots in Observe keys</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/317\">data-view-id being rendered in tag closing</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/315\">Execute startBatch callbacks</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/313\">HTML comments with either an element callback (EJS) or a helper (Mustache) rendered incorrectly</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/310\">Prevent leak from computes that have no bindings.</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/303\">Treat &quot;--&quot; as delimiter of empty element</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/300\">Fixing can.ajax with mootools</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/296\">CanJS tries to parse JSON-map which contains a dot in the key</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/292\">can.compute evaluations for the default Mustache handlers</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/288\">can.Mustache: Array of objects passed as context to partials, breaks data helper and rendering.</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/284\">adding greedy space to model url splitter</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/282\">Fix for numeric inputs not living binding</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/281\">Empty strings not handled properly</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/279\">can.Control event delegation problem</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/278\">fixing computes from converting type</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/276\">can.view with Deferreds doesn't pass failures</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/271\">HTML comments trip EJS rendering</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/258\">can.Observe.prototype.each overrides {{#each}} Mustache helper.</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/257\">Any model with a &quot;.&quot; in the key name will cause observe.js _set() to throw and error</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/253\">Item.List splice method does not convert inserted elements to Item type</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/243\">Mustache: DOM exception when applying certain block patterns</a></li>\n<li>change: <a href=\"https://github.com/bitovi/canjs/issues/153\">Mustache: Interpolated values when iterating through an Observe.List fail if not surrounded by a DOM node</a></li>\n</ul>\n\n<p><strong>1.1.4</strong> ( February 5, 2013 )</p>\n\n<ul>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/265\">Haschange binding and route ready for all libraries</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/264\">Get converters and .attr working the right way with nested objects</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/233\">CanJS/ejs table+tbody rendering of a list gives nested tbody items</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/231\">Mustache: Inconsistent treatment of function attributes</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/230\">EJS renders \"@!!@\" instead of Model data when a Deferred is passed into can.view that takes a long time to resolve</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/228\">Mustache: registered helpers do not create the context stack correctly</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/227\">Mustache: only the current context is passed to partials, instead of the full stack</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/226\">IE8 error when setting up observe list</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/223\">Resetting a live-bound <textarea> changes its value to <strong>!!</strong></a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/216\">hashchange binding still broken in mootools</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/215\">can.Mustache - with context lost in nested sections</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/214\">Enabled passing in helpers and partials to Mustache views</a>, (<a href=\"https://github.com/bitovi/canjs/pull/260\">1</a>)</li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/209\">Make the resolved data available when using can.view</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/207\">.attr method doesn't merge nested objects</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/204\">Live binding on observe.lists nested in an observe doesn't work</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/174\">Attributes/Converters Issue</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/170\">Observe.List push/unshift doesn't fire when sort comparator is set</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/169\">Observe.List sort doesn't use custom method passed</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/145\">test&amp;fix: null values crashing validations</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/118\">EJS rendering null value</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/205\">can.Observe sort plugin doesn't trigger add events</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/88\">Observe.List sort plugin erroring on item removal</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/204\">Live binding on observe.lists nested in an observe doesn't work</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/169\">Observe.List sort doesn't use custom method passed</a></li>\n<li>add: <a href=\"https://github.com/bitovi/canjs/pull/245\">removeAttr can.Model attribute</a></li>\n<li>add: <a href=\"https://github.com/bitovi/canjs/pull/181\">Calling destroy on non persisted model</a></li>\n<li>add: <a href=\"https://github.com/bitovi/canjs/pull/237\">jQuery 1.9.x support</a></li>\n<li>add: <a href=\"https://github.com/bitovi/canjs/issues/254\">Mustache Helpers that accept computes and return an element should work</a></li>\n</ul>\n\n<p><strong>1.1.3</strong> ( December 11, 2012 )</p>\n\n<ul>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/196\">Empty model displays <strong>!!</strong> as input values</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/202\">Rendering models in tables produces different results than an equivalent observe</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/200\"><code>data</code> Mustache helper doesn't parse attribute properly</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/commit/492a22f7655d1ff15c37b95213252c87a264fe3e\">Partial Mustache views assume the right parent tag for live-binding</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/199\">Mustache partials don't parse properly</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/191\">can.Control will fail to find $.event.special in a $.noConflict(true) scenario</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/195\">Nameless view renderers should return document fragment</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/commit/9cb47dfabba5dbe3bef161e6aae4a5ce2965ac49\">compute only updates once when a list's contents are replaced</a></li>\n<li>add: <a href=\"https://github.com/bitovi/canjs/pull/201\">Updated jQuery hashchange plugin</a></li>\n<li>add: <a href=\"https://github.com/bitovi/canjs/issues/203\">Generate computes from an observe property</a></li>\n<li>add: <a href=\"https://github.com/bitovi/canjs/issues/194\">Add can.Observe.List.prototype.replace</a></li>\n<li>add: [Return resolved data models in view callback](https://github.com/bitovi/canjs/issues/1log\n83)</li>\n</ul>\n\n<p><strong>1.1.2</strong> ( November 28, 2012 )</p>\n\n<ul>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/175\">Solve issue when stealing mustache templates</a> - <code>can/view/mustache</code> returns <code>can</code> object now</li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/commit/e90bc56d9c1ec46ae01f084ccbcab43c9c611d0c\">Controls shouldn't bind to templated events that contain undefined values</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/166\">Resetting a form changes input values to <strong>!!</strong></a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/168\">Further AMD build improvements</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/172\">Strange conversion of nested arrays to Observe.List</a></li>\n</ul>\n\n<p><strong>1.1.1</strong> ( November 19, 2012 )</p>\n\n<ul>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/156\">@!!@ Appears on Page With EJS and Table in non-IE Browsers</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/152\">can.deparam leaks to global scope</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/160\">nested attr() call on a model with List attributes blows away existing List</a></li>\n<li>add: <a href=\"https://github.com/bitovi/canjs/issues/162\">https://github.com/bitovi/canjs/issues/162</a></li>\n<li>Improved AMD support, see <a href=\"https://github.com/bitovi/canjs/issues/155\">#155</a></li>\n</ul>\n\n<p><strong>1.1.0</strong> ( November 13, 2012 )</p>\n\n<ul>\n<li><p>add: <a href=\"#using_canjs-amd\">AMD module</a> support for each dependency (<a href=\"https://github.com/bitovi/canjs/issues/46\">#46</a>)</p></li>\n<li><p>can.util</p>\n\n<ul><li>Updated jQuery to 1.8.2</li>\n<li>Updated Zepto to 1.0rc1</li>\n<li>Updated YUI to 3.7.3</li></ul></li>\n<li><p>can.Mustache</p>\n\n<ul><li>Added Mustache/Handlebars support with Live Binding</li></ul></li>\n<li><p>can.view</p>\n\n<ul><li>Changed <a href=\"https://github.com/bitovi/canjs/pull/131\">passing jQuery a node list instead of a fragment in View Modifiers</a></li></ul></li>\n<li><p>can.EJS</p>\n\n<ul><li>fix: <a href=\"https://github.com/bitovi/canjs/pull/134\">the way EJS handles multiple hookups in the same attribute</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/135\">Nested Loops in EJS</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/118\">can.EJS template rendering issue</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/76\">multiline elements in EJS</a></li></ul></li>\n<li><p>can.route</p>\n\n<ul><li>fix: <a href=\"https://github.com/bitovi/canjs/issues/124\">hashchange binding with mootools broken</a></li></ul></li>\n<li><p>can.Control</p>\n\n<ul><li>add: <a href=\"https://github.com/bitovi/canjs/issues/104\">control does not listen to touchmove event on controller itself</a></li></ul></li>\n<li><p>can.Observe</p>\n\n<ul><li>add: <a href=\"https://github.com/bitovi/canjs/issues/142\">List binding on .length of an object</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/pull/132\">validation error that incorrectly labels an attribute with a value of 0 as empty</a></li>\n<li>add: <a href=\"https://github.com/bitovi/canjs/issues/122\">you can now pluralise event names to listen to matching events of that type (rather than firing a single event)</a></li>\n<li>add: <a href=\"https://github.com/bitovi/canjs/issues/119\">compound sets now behave correctly</a></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/123\">can.Observe.delegate sets wrong event.currentTarget</a></li>\n<li>add: <a href=\"https://github.com/bitovi/canjs/issues/107\">ability to assign object as attribute type in can.Observe</a></li></ul></li>\n<li><p>can.Model</p>\n\n<ul><li>fix: <a href=\"https://github.com/bitovi/canjs/pull/141\">can.Model with attributes that are models gets corrupted when you call attr()</a></li>\n<li>add: <a href=\"https://github.com/bitovi/canjs/pull/140\">missing dependency to can/model</a></li>\n<li>Moved can/model/elements to can/observe/elements and renamed <code>models</code> to <code>instances</code></li>\n<li>fix: <a href=\"https://github.com/bitovi/canjs/issues/129\">can.Model.List doesn't fire the change event on the expando properties </a></li></ul></li>\n</ul>\n\n<p><strong>1.0.7</strong> (June 25nd 2012)</p>\n\n<ul>\n<li><p>can.compute</p>\n\n<ul><li>Fixed a <a href=\"https://github.com/jupiterjs/canjs/commit/7aea62462f3d8d7855f71ccdf16330e60d59f6fa\">global collision</a> with <code>can.Control</code>.</li></ul></li>\n<li><p>Removed globals</p>\n\n<ul><li>Thanks <a href=\"https://github.com/daniel-franz\">Daniel Franz</a>!</li></ul></li>\n</ul>\n\n<p><strong>1.0.6</strong> (June 22nd 2012)</p>\n\n<ul>\n<li><p>can.compute</p>\n\n<ul><li>Added a <a href=\"https://github.com/jupiterjs/canjs/commit/8eb7847d410c840da38f4dd5157726e560d0a5f5\">computed value type object</a> that can be used to represent several observe properties or a single static value.</li></ul></li>\n<li><p>can.ejs</p>\n\n<ul><li>Fixed problem with <a href=\"https://github.com/jupiterjs/canjs/commit/419248bf190febe5c3ccacb188e9c812e997278e\">trailing text</a> not being added to template.</li></ul></li>\n</ul>\n\n<p><strong>1.0.5</strong> (June 2nd 2012)</p>\n\n<ul>\n<li><p>can.model</p>\n\n<ul><li>Added ability to <a href=\"https://github.com/jupiterjs/canjs/commit/235097a46e45329d63da9b6d28a6c284c1b2a157\">overwrite model crud operations</a> by defining a <code>make</code> prefixed static function, such as <code>makeFindAll</code></li></ul></li>\n<li><p>can.EJS</p>\n\n<ul><li><a href=\"https://github.com/jupiterjs/canjs/commit/4d4d31f12a57db1ff81f47fa0c8b4261d8133dbb\">Fixed problem</a> with nested block statements.</li></ul></li>\n<li><p>can.each</p>\n\n<ul><li><a href=\"https://github.com/jupiterjs/canjs/commit/bbd2ad5e38df90f0ebcc09a20f7ea216fe20bd72\">Added optional third argument</a> that defines the context for the iterator function.</li></ul></li>\n<li><p>can/util/function</p>\n\n<ul><li>Added <code>can.defer</code> <a href=\"https://github.com/jupiterjs/canjs/commit/64de5254ce8c284b20c3da487638497457152105\">method</a> as an alias for <code>setTimeout(function(){}, 0)</code>.</li></ul></li>\n<li><p>can.view</p>\n\n<ul><li>Fixed <code>toId</code> <a href=\"https://github.com/jupiterjs/canjs/commit/19c9ca0f07b00afe3c99bf439c089948c46464a6\">so it will work</a> with both older and newer <code>steal</code> versions.</li></ul></li>\n</ul>\n\n<p><strong>1.0.4</strong> (May 22nd 2012)</p>\n\n<ul>\n<li>Fixed plugin build process</li>\n</ul>\n\n<p><strong>1.0.2</strong> (May 20th 2012)</p>\n\n<ul>\n<li>Fixed breaking namespace issue.</li>\n</ul>\n\n<p><strong>1.0.1</strong> (May 18th 2012)</p>\n\n<ul>\n<li><p>can.util</p>\n\n<ul><li>fix: <code>can.each</code> now makes sure the <a href=\"https://github.com/jupiterjs/canjs/commit/c3016bc9d7075e5a31cc37576d944d9734457307\">collection being iterated</a> is not <code>undefined</code></li></ul></li>\n<li><p>can.control</p>\n\n<ul><li>add: Redirect to another controller <a href=\"https://github.com/jupiterjs/canjs/commit/cab9b518ac0193431815ac0d34938f1168e45d5f\">method using a string</a></li></ul></li>\n<li><p>can.model</p>\n\n<ul><li>fix: <a href=\"https://github.com/jupiterjs/canjs/commit/e4606906d37797d4ff551d1924d44f0c4d516fb7\">Model instances in model store will be updated when <code>findAll</code> or <code>findOne</code> retrieves updated instances fixes</a></li>\n<li>fix: Static methods such as <code>findOne</code> and <code>findAll</code> can <a href=\"https://github.com/jupiterjs/canjs/commit/ff17833b52162348413ebdc47baaa389a90464f9\">now be rejected</a>. Thanks <a href=\"https://twitter.com/roelmonnens\">roelmonnens</a>!</li></ul></li>\n<li><p>can.route</p>\n\n<ul><li>add: Deliminating tokens now <a href=\"https://github.com/jupiterjs/canjs/commit/ca98f8f2b781456a42866805e6f9879899dc38af\">configurable</a></li>\n<li>fix: <a href=\"https://github.com/jupiterjs/canjs/commit/863f37cc3d34f52517050444e0b31b7d63d6c784\">Current route wins if all else equal</a></li></ul></li>\n</ul>\n\n<p><strong>1.0</strong> (May 14st 2012)</p>\n\n<ul>\n<li><p><a href=\"https://github.com/jupiterjs/canjs/blob/master/util/exports.js\">Registers itself as an AMD</a> module if <code>define</code> is in the <code>window</code></p></li>\n<li><p>can.fixture</p>\n\n<ul><li>add: <a href=\"https://github.com/jupiterjs/canjs/tree/5277f6f526cfa2514954d66e6f759ec73c47bf09\">a fixture plugin</a></li></ul></li>\n<li><p>can.util</p>\n\n<ul><li>add: <a href=\"https://github.com/jupiterjs/canjs/commit/75e99f3b1545d4086ccdae259ccc87a3e8e7a018\">a util/function plugin</a></li></ul></li>\n<li><p>can.route</p>\n\n<ul><li>fix: <a href=\"https://github.com/jupiterjs/canjs/commit/863f37cc3d34f52517050444e0b31b7d63d6c784\">favor current route when matching</a></li>\n<li>fix: <a href=\"https://github.com/jupiterjs/canjs/commit/b0e59d287caba8fcb98871e4814b924588aef138\">uses defaults to match route better, and current route is not always selected</a></li></ul></li>\n</ul>\n\n<p><strong>1.0 Beta 2</strong> (April 21st 2012)</p>\n\n<ul>\n<li>can.util\n<ul><li>change: <a href=\"https://github.com/jupiterjs/canjs/commit/234fd3b9eca18abdbc3fdbea114be6a818bfe6e3\">reverse argument order of can.each</a></li>\n<li>change/fix: <a href=\"https://github.com/jupiterjs/canjs/issues/33\">buildFragment returns non cached frag</a></li>\n<li>fix: <a href=\"https://github.com/jupiterjs/canjs/commit/7fe391f59a1f54e3f197f31e20276646f82e7f2e\">zepto's isEmptyObject was broke</a></li></ul></li>\n<li><p>can.observe</p>\n\n<ul><li>feature: <a href=\"https://github.com/jupiterjs/canjs/issues/27\">recursive observes don't blow up</a></li>\n<li>change: <a href=\"https://github.com/jupiterjs/canjs/commit/234fd3b9eca18abdbc3fdbea114be6a818bfe6e3\">reverse argument order of can.each</a></li>\n<li>fix: <a href=\"https://github.com/jupiterjs/canjs/commit/4081a9baf4441c1002467342baae3cdd885994c6\">attr change events have old value</a></li></ul></li>\n<li><p>can.model</p>\n\n<ul><li>fix: <a href=\"https://github.com/jupiterjs/canjs/commit/c93ae5478eea7fdb88fa6fc03211d81c8d4ca3bd\">findOne and findAll work with super</a></li>\n<li>fix: <a href=\"https://github.com/jupiterjs/canjs/commit/14d05c29e71ed8c462ba49b740d9eb8e342d3c85\">model using custom id for store</a></li>\n<li>fix: <a href=\"https://github.com/jupiterjs/canjs/issues/32\">destroy not working with templated id</a></li></ul></li>\n<li><p>can.route</p>\n\n<ul><li>fix: a host of bugs in libaries other than jQuery because can.route was not properly tested in other libraries.</li>\n<li>fix: can.param fixed in <a href=\"https://github.com/jupiterjs/canjs/commit/77dfa012b2f6baa7dfb0fe84f2d62aeb5b04fc90\">dojo</a>,</li></ul></li>\n</ul>\n\n<p><strong>1.0 Beta 1</strong> (April 1st 2012)</p>\n\n<p>Released!</p>",
            "title": "Changelog",
            "parent": "guides",
            "order": 5,
            "src": "can/changelog.md",
            "id": 26
        }, {
            "active": false,
            "type": "page",
            "name": "license",
            "body": "",
            "description": "<!--\n-->\n\n<p>Copyright (C) 2013 <a href=\"http://bitovi.com\">Bitovi</a></p>\n\n<p>Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:</p>\n\n<p>The above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.</p>\n\n<p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.</p>",
            "title": "License",
            "parent": "guides",
            "order": 6,
            "src": "can/license.md",
            "id": 28
        }
    ]
}