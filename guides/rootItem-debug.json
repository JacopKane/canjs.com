{
    "active": false,
    "type": "page",
    "name": "guides",
    "body": "",
    "description": "",
    "title": "Guides",
    "src": "_guides/guides.md",
    "id": 4,
    "children": [{
            "active": false,
            "type": "page",
            "name": "Tutorial",
            "body": "<p>This tutorial will walk you though the basics of CanJS by building a small\nto-do app with CanJS and jQuery. When you are finished, your app will look\nsimilar to this:</p>\n\n<div class='iframe_wrapper' data-iframe-src='/path/to/to-do/demo' data-iframe-height='320'></div>\n\n<p>To get started, click [Constructs Constructs] in the navigation to the left. Or, if this\ntutorial isn't your thing, you can take a look at some [Videos Videos], see\nsome nifty [Recipes Recipes] for building functionality with CanJS, check out\nour <a href=\"../docs/index.html\">API</a>, or dive right in and poke around the [AnnotatedSources annotated\nsource] for CanJS.</p>",
            "description": "",
            "title": "Get Started with CanJS",
            "src": "_guides/route.md",
            "parent": "guides",
            "comment": " ",
            "id": 8,
            "children": [{
                    "active": false,
                    "type": "page",
                    "name": "Constructs",
                    "body": "<p>Constructor functions made with [can.Construct] are used to create objects with\nshared properties, and they make managing inheritance in JavaScript much easier.\n[Observes] (and through Observes, [Models] and [Controls]) are based off of\nConstructs, so learning how they work is fundamental to understanding CanJS.</p>\n\n<p>To create a constructor function of your own, call <code>can.Construct</code> and pass in\nan object of static properties (which will be attached directly to the \nconstructor) and an object of instance properties (which will be attached to\neach instance of the Construct):</p>\n\n<pre><code class=\"lang-javascript\">var Todo = can.Construct({ }, {\n    description: 'Something to do.',\n    author: 'Unknown',\n    allowedToEdit: function() {\n        return true;\n    }\n});\n\nvar t = new Todo();\n\nt.description; // 'Something to do.'\nt.author; // 'Unknown'\nt.allowedToEdit(); // true</code></pre>\n\n<p>There are a few other ways to create classes with  <code>can.Construct</code>; see\n[the API] for all the details.</p>\n\n<h2>Inheritance</h2>\n\n<p>can.Construct sets up the prototype chain so that Constructs are easy to\nsubclass. Call the constructor function of the class you want to extend and give\nit the arguments you would pass to <code>can.Construct</code>:</p>\n\n<pre><code class=\"lang-javascript\">// If only one argument is passed, they are considered instance properties.\nvar PrivateTodo = Todo({\n    description: 'Something secret!',\n    allowedToEdit: function(account) {\n        return account.owns(this);\n    }\n});\n\nvar p = new PrivateTodo();\np.author; // 'Unknown'\np.description; // 'Something secret!'\np.allowedToEdit({owns: function(){ return false; }}); // false</code></pre>\n\n<h2>Initialization</h2>\n\n<p>As you can see above, when a constructor function is called with <code>new</code>,\ncan.Construct creates a new instance of that class. If you've supplied an\ninstance method called <code>[init]</code>, can.Construct will call that as well, passing\nit the arguments you passed to the constructor.</p>\n\n<p>This helps make our Todo a little more configurable:</p>\n\n<pre><code class=\"lang-javascript\">var Todo = can.Construct({\n    description: 'Something to do.',\n    author: 'Unknown',\n\n    init: function(options) {\n        this.author = options.author || this.author;\n        this.description = options.description || this.description;\n    }\n});\n\nvar t = new Todo({author: 'Me!'});\nt.author; // 'Me!'\nt.description; // 'Something to do.'</code></pre>\n\n<p>If you're extending a Construct, you probably want to make sure you call the\nbase's <code>init</code> method inside the child's <code>init</code>:</p>\n\n<pre><code class=\"lang-javascript\">var PrivateTodo = can.Construct({\n    init: function(options) {\n        this.\n    }\n});</code></pre>",
                    "description": "",
                    "title": "Constructs",
                    "parent": "Tutorial",
                    "order": 0,
                    "comment": " ",
                    "src": "_guides/constructs.md",
                    "id": 0
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Controls",
                    "body": "<p>Controls made with can.Control are organized, memory-leak free,\nperformant, stateful UI controls. can.Control lets you create controls like\ntabs, grids, context menus, and forms, and helps you organize them into\nhigher-order business units, tying them all together with <a href=\"can.route\">can.route</a>.\nControls fill the traditional MVC controller role, managing data through Models\nmade with can.Model and directing it to be displayed through views made with\ncan.view.</p>\n\n<p>Because Controls are Constructs, you can create control constructors and\ninstances just like with can.Construct. Here's what the constructor for a Control\nthat manages a Todo list might look like:</p>\n\n<pre><code class=\"lang-javascript\">var Todos = can.Control({\n    init: function(el, options) {\n        var self = this;\n        Todo.findAll({}, function(todos) {\n            self.element.html(can.view('todoList', todos));\n        });\n    }\n});</code></pre>\n\n<p>When you instantiate a control, pass it a selector, element, or library-wrapped\nNodeList that corresponds to the DOM element you want the Control to set to\n<code>this.element</code> for that Control. Also pass the control an object with any options\nfor that particular instance. These options will be extended off of the Control's\nconstructor's static defaults and set as <code>this.options</code> for that Control.</p>\n\n<p>Here we'll initiate a Todos controller to hang off of the element with ID <em>todos</em>\nand with no options supplied:</p>\n\n<pre><code class=\"lang-javascript\">var todosList = new Todos('#todos', {});</code></pre>\n\n<p>If you specify a method called <code>init</code> when creating your Control's constructor,\nthat method will be called when a new instance of that Control is created. The\n<code>init</code> method gets passed a library-wrapped NodeList containing <code>this.element</code>\nas the first parameter and <code>this.options</code> as the second parameter. Any other\nparameters you passed to the constructor during instantiation will also be passed\nto <code>init</code>.</p>\n\n<p>To demonstrate this, here is another version of the Todo list Control constructor\nthat can have its view overridden, and the instantiation of that Control:</p>\n\n<pre><code class=\"lang-javascript\">var Todos = can.Control({\n    defaults: {\n        view: 'todos.ejs'\n    }\n},{\n    init: function(el, options) {\n        var self = this;\n        Todo.findAll({}, function(todos) {\n            self.element.html(can.view(this.options.view, todos));\n        });\n    }\n});\n\n// this Control will use todos.ejs\nnew Todos(document.body.firstChild);\n\n// this Control will use todos2.ejs\nnew Todos('#todoList', {view: 'todos2.ejs'});</code></pre>\n\n<h2>Listening to events</h2>\n\n<p>Controls will automatically bind instance methods that look like event handlers.\nOn this Control, <em>click</em> events on &lit;li> elements inside <code>this.element</code> will\ntrigger the console log to be written to:</p>\n\n<pre><code class=\"lang-javascript\">var Todos = can.Control({\n    init: function(el, options) {\n        var self = this;\n        Todo.findAll({}, function(todos) {\n            self.element.html(can.view('todoList', todos));\n        });\n    },\n    'li click': function(el, ev) {\n        console.log('You clicked ' + el.text());\n    }\n});</code></pre>\n\n<p>The event handlers are passed a library-wrapped NodeList containing the element\nthat was clicked, and the event. can.Control uses event delegation, so you don't\nneed to rebind handlers when you add or remove elements.</p>\n\n<p>One of the things we want to do with our to-do list is delete Todos. This is\nmade easy with event handling in can.Control. Let's say that our view template looks like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/ejs\" id=\"todoList\">\n<% this.each(function(todo) { %>\n&lt;li <%= (el) -> el.data('todo', todo) %>>\n    <%= todo.attr('description'); %>\n    &lt;a class=\"destroy\">X</a>\n&lt;/li>\n<% }) %>\n&lt;/script></code></pre>\n\n<p>We should put an event listener on our Todos Control to remove a Todo when its\ndestruction link is clicked:</p>\n\n<pre><code class=\"lang-javascript\">var Todos = can.Control({\n    init: function(el, options) {\n        var self = this;\n        Todo.findAll({}, function(todos) {\n            self.element.html(can.view('todoList', todos));\n        });\n    },\n    'li click': function(el, ev) {\n        console.log('You clicked ' + el.text());\n    },\n    'li .destroy click': function(el, ev) {\n        var li = el.closest('li'),\n            todo = li.data('todo');\n\n        todo.destroy();\n    }\n});</code></pre>\n\n<p>Destroying the Todo will take it out of the list of Todos being rendered\n(because the list of Todos passed into the template is a Model List), which will\ncause the template to re-render itself. This means that EJS's live binding will\nremove the appropriate &lt;li> automatically.</p>\n\n<h2>Templating event handlers</h2>\n\n<p>If a variable is placed in braces in the event handler key, can.Control will\nlook up that key in the Control's <code>options</code>, and then on <code>window</code>. You can use\nthis to customize the events that cause handlers to fire:</p>\n\n<pre><code class=\"lang-javascript\">var Todos = can.Control({\n    defaults: {\n        destroyEvent: 'click'\n    }\n},{\n    init: function(el, options) {\n        var self = this;\n        Todo.findAll({}, function(todos) {\n            self.element.html(can.view(this.options.view, todos));\n        });\n    },\n    'li .destroy {destroyEvent}': function(el, ev) {\n        var li = el.closest('li'),\n            todo = li.data('todo');\n\n        todo.destroy();\n    }\n});\n\nnew Todos('#todos', {destroyEvent; 'mouseenter'});</code></pre>\n\n<p>You can also use this to bind events to objects other that <code>this.element</code>\nwithin Controls. This is critical for avoiding memory leaks that are\ncommonplace with other MVC applications and frameworks because it ensures that\nthese handlers get unbound when the control is destroyed:</p>\n\n<pre><code class=\"lang-javascript\">var Tooltip = can.Control({\n    '{window} click': function(el, ev) {\n        // hide only if we clicked outside the tooltip\n        if(! this.element.has(ev.target).length) {\n            this.element.remove();\n        }\n    }\n});</code></pre>\n\n<p>This is useful for listening to changes on models. Say that our live-binding did\nnot take care of removing &lt;li>s after the corresponding Model was destroyed.\nIn that case, we could implement that functionality by listening to when Todos\nare destroyed:</p>\n\n<pre><code class=\"lang-javascript\">var Todos = can.Control({\n    defaults: {\n        destroyEvent: 'click'\n    }\n},{\n    init: function(el, options) {\n        var self = this;\n        self.todosList = todos;\n        Todo.findAll({}, function(todos) {\n            self.element.html(can.view(this.options.view, todos));\n        });\n    },\n    'li .destroy {destroyEvent}': function(el, ev) {\n        var li = el.closest('li'),\n            todo = li.data('todo');\n\n        todo.destroy();\n    },\n    '{Todo} destroyed': function(Todo, ev, destroyed) {\n        // find where the element is in the list\n        var index = this.todosList.indexOf(destroyed);\n        this.element.children(':nth-child(' + (index + 1) + ')').remove();\n        this.todosList.splice(index, 1);\n    }\n});</code></pre>\n\n<h2>Rebinding events</h2>\n\n<p>You can unbind and rebind all a Control's event handlers by calling <code>on</code> on it.\nThis is useful when a Control starts listening to a specific Model, and you want\nto change which model it is listening to.</p>\n\n<p>In the example below, an Editor Control keeps a reference to the specific Todo\nit is editing. Its <code>todo</code> method calls <code>on</code> when the Todo being edited switches,\nbecause it needs to rebind <code>{todo} updated</code>.</p>\n\n<pre><code class=\"lang-javascript\">var Editor = can.Control({\n    setDesc: function() {\n        this.element.val(this.options.todo.description);\n    },\n    // change what Todo this Control points at\n    todo: function(todo) {\n        this.options.todo = todo;\n        this.on();\n        this.setDesc();\n    },\n    // listen for changes in the Todo\n    '{todo} updated': function() {\n        this.setDesc();\n    },\n    // when the input changes, update the Todo\n    ' change': function(el, ev) {\n        this.options.todo.attr('description', el.val());\n        this.options.todo.save();\n    }\n});\n\nvar todo1 = new Todo({id: 7, description: 'Take out the trash.'}),\n    todo2 = new Todo({id: 8, description: 'Wash the dishes.'}),\n    editor = new Editor('#editor');\n\n// start editing the first Todo\neditor.todo(todo1);\n\n// switch to editing the second Todo\neditor.todo(todo2);</code></pre>\n\n<h2>Destrying Controls</h2>\n\n<p>Calling <code>destroy</code> on a Control unbinds the Control's event handlers and removes\nits association with its element, but it does not remove the element from the\npage.</p>\n\n<pre><code class=\"lang-javascript\">var list = new Todos('#todos');\n$('#todos').length; // 1\nlist.destroy();\n$('#todos').length; // 1</code></pre>\n\n<p>However, when a Control's element is removed from the page, <code>destroy</code> is called\non the Control.</p>\n\n<p>Taken together, templated event binding and Control's automatic cleanup make it\nnearly impossible to write applications with memory leaks. An application that\nuses only templated event handlers on the controls within the body could free\nup all the data it uses by calling <code>$(document.body).empty()</code>.</p>",
                    "description": "",
                    "title": "Controls",
                    "parent": "Tutorial",
                    "comment": " ",
                    "src": "_guides/controls.md",
                    "id": 1
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Deferreds",
                    "body": "<p>Deferreds in CanJS are explained in greater detail in the <a href=\"can.Deferred\">API</a>.\nBelow is a quick tour through can.Deferred, which should look familiar to you\nif you have experience with the Deferred pattern.</p>\n\n<pre><code class=\"lang-javascript\">// Create a new Deferred:\nvar dfd = new can.Deferred();\n\n// Add a done callback:\ndfd.done(function(foo) {\n    console.log('Resolved!');\n});\n// Add a fail callback:\ndfd.fail(function(bar) {\n    console.log('Rejected!');\n});\n// Add a callback that fires whether the\n// Deferred is resolve or rejected.\ndfd.always(function(obj) {\n    console.log('Apathetic!');\n});\n\nvar dfd2 = new can.Deferred();\n// Add done and fail callbacks:\ndfd2.then(functon(foo) {\n    console.log('Also resolved.');\n}, function(bar) {\n    console.log('Also rejected.');\n});\n\n// Create a Deferred that resolves when\n// all passed Deferreds resolve:\nvar endDfd = can.when(dfd, dfd2).then(function() {\n    console.log('I open at the close.');\n});\n\n// Resolve a Deferred (and call all its done callbacks):\ndfd.resolve('foo');\n\n// Reject a Deferred (and call all its fail callbacks):\ndfd.reject('bar');</code></pre>",
                    "description": "",
                    "title": "Deferreds",
                    "parent": "Tutorial",
                    "order": 5,
                    "comment": " ",
                    "src": "_guides/deferred.md",
                    "id": 2
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Models",
                    "body": "<p>Models are Observes that connect to a RESTful interface. They come with a set of\nmethods designed to make it easy to manage changes remotely. To create a Model\nclass, call <code>can.Model</code> and supply it with specific static properties that tell\nit how to interact with the server, along with any instance properties or helper\nmethods the Model may need. The important static properties are:</p>\n\n<ul>\n<li><a href=\"can.Model.static.findAll\">findAll</a>, which describes how to get a group of\nitems.</li>\n<li><a href=\"can.Model.static.findOne\">findOne</a>, which describes how to get a specific\nitem.</li>\n<li><a href=\"can.Model.static.create\">create</a>, which describes how to save a new item.</li>\n<li><a href=\"can.Model.static.update\">update</a>, which describes how to update an\nexisting item.</li>\n<li><a href=\"can.Model.static.destroy\">destroy</a>, which describes how to delete an item.</li>\n</ul>\n\n<p>When accessing a straightforward RESTful API, creating a Model class and an\ninstance of that Model class might be as simple as this:</p>\n\n<pre><code class=\"lang-javascript\">var Todo = can.Model({\n    findAll: 'GET /todos',\n    findOne: 'GET /todos/{id}',\n    create:  'POST /todos',\n    update:  'PUT /todos/{id}',\n    destroy: 'DELETE /todos/{id}'\n}, {});\n\nvar dishesTask = new Todo({description: 'Do the dishes.'});</code></pre>\n\n<p>Because Models are Observes, don't forget to set all your properties with <code>attr</code>.</p>\n\n<h2>Talking to the server</h2>\n\n<p>By supplying the <code>findAll</code>, <code>findOne</code>, <code>create</code>, <code>update</code>, and <code>destroy</code>\nproperties, you show a Model class how to communicate with the server. You can\ncall <code>findAll</code> and <code>findOne</code> on the Model class to retrieve Models and <code>save</code>\nand <code>destroy</code> on Models to create, update, and delete them.</p>\n\n<h3>Retrieving items from a server</h3>\n\n<p><code>can.Model.findAll</code> retrieves a group of Models by making a call to a server.\nHere's how you call <code>findAll</code> on our Todo class above:</p>\n\n<pre><code class=\"lang-javascript\">Todo.findAll({}, function(todos) {\n    // todos is a can.Model.List of Todo Models.\n}, function(xhr) {\n    // handle errors\n});</code></pre>\n\n<p>This will make a <code>GET</code> request to <code>/todos</code>, which should return JSON that looks\nsimilar to:</p>\n\n<pre><code class=\"lang-javascript\">{\n    \"data\": [\n        {\"id\":1, \"description\":\"Do the dishes.\"},\n        {\"id\":2, \"description\":\"Mow the lawn.\"},\n        {\"id\":3, \"description\":\"Finish the laundry.\"}\n    ]\n}</code></pre>\n\n<p>(<code>findAll</code> will also accept an array from the service, but <a href=\"http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\">you probably should not be returning an array from a JSON service</a>.)</p>\n\n<p>When the service has returned, <code>findAll</code> will massage the data into Model\ninstances, put them in a can.Model.List (which is like a can.Observe.List for\nModels), and pass the List to the callback in its second parameter. If there was\nan error, <code>findAll</code> will call the callback in its third parameter and pass it the\nXmlHttpRequest object used to make the call.</p>\n\n<p><code>findAll</code> returns a <a href=\"can.Deferred\">can.Deferred</a> that will resolve to a Model\nList of items if the call succeeds and rejects to the XmlHttpRequest object if\nthere is an error.</p>\n\n<p><code>can.Model.findOne</code> works similarly to <code>findAll</code>, except that it retrieves a\nsingle Model from a server:</p>\n\n<pre><code class=\"lang-javascript\">Todo.findOne({id: 1}, function(todo) {\n    // todo is an instance of Todo\n});</code></pre>\n\n<p>This makes a <code>GET</code> request to <code>/todos/1</code>, which should return JSON that looks\nsimilar to:</p>\n\n<pre><code class=\"lang-javascript\">{\n    \"id\":1,\n    \"description\":\"Do the dishes\"\n}</code></pre>\n\n<p><code>findOne</code> returns a Deferred that resolves to the Todo if the call succeeds and\nrejects to the XmlHttpRequest object if there is an error.</p>\n\n<h3>Modifying items</h3>\n\n<p>You can call <code>[save](can.Model.prototype.save)</code> on a Model instance to save it\nback to the server. If the Model has an <strong>id</strong>, it will be updated using the\nfunction specified under <code>update</code>. Otherwise, can.Model assumes the Model is new\nand creates the item on the server using the function in <code>create</code>.</p>\n\n<p>Either way, the callback in the first parameter will be called on a successful\nsave with the updated Model; if an error occurs, the callback in the second\nparameter will be called with the XmlHttpRequest object. Like <code>findAll</code>, <code>save</code>\nreturns a Deferred that resolves to the updated Model on success and rejects to\nthe XmlHttpRequest object on failure.</p>\n\n<pre><code class=\"lang-javascript\">var shopping = new Todo({description: \"Go grocery shopping.\"});\nshopping.save(function(saved) {\n    // saved is the saved Todo\n    saved.attr('description', 'Remember the milk.');\n    saved.save();\n});</code></pre>\n\n<p>In the code above, the first time <code>shopping.save()</code> is called, can.Model will\nmake a <code>POST</code> request to <code>/todos</code> with a request body of <code>description=Go\ngrocery shopping.</code>. When the response comes back, it should have an <strong>id</strong>\n(say, 5) and that <strong>id</strong> property will be reflected in <code>todo</code>.</p>\n\n<p>The second time <code>saved.save()</code> is called, <code>saved</code> has an <strong>id</strong>, so can.Model\nwill make a <code>PUT</code> request to <code>/todos/5</code> with a request body of\n<code>description=Remember the milk.</code>.</p>\n\n<h3>Deleting items</h3>\n\n<p>When you need to delete a Model's counterpart on the server, just call <code>destroy</code>\non the Model, passing it success and error handlers just like <code>save</code>, except\nthat the success handler will be passed the Model that has been deleted.\n<code>destroy</code> also retuns a Deferred, which resolves to the deleted Model and\nrejects to the XmlHttpRequest object.</p>\n\n<pre><code class=\"lang-javascript\">var cats = new Todo({description: \"Feed the cats.\"});\ncats.save(function(saved) {\n    saved.destroy(function(destroyed) {\n        // destroyed is the Todo that was destroyed\n    });\n});</code></pre>\n\n<p>When <code>destroy</code> is called in the above code, can.Model makes a <code>DELETE</code> request\nto <code>/todos/6</code>.</p>\n\n<h2>Listening to events</h2>\n\n<p>Because Models are Observes, you can bind to the same events as on any other\nObserve. In addition to those events, Models emit three new kinds of events:</p>\n\n<ul>\n<li><em>created</em>, when an instance is created on the server.</li>\n<li><em>updated</em>, when an instance is updated on the server.</li>\n<li><em>destroyed</em>, when an instance is destroyed on the server.</li>\n</ul>\n\n<p>For example, here is how you listen for an instance being created on the server:</p>\n\n<pre><code class=\"lang-javascript\">var mop = new Todo({description: 'Mop the floor.'});\nmop.bind('created', function(ev, created) {\n    // created is the created Todo\n});\nmop.save();</code></pre>\n\n<p>You can also bind directly onto the Model class to listen for any time <strong>any</strong>\ninstance is created, updated, or destroyed:</p>\n\n<pre><code class=\"lang-javascript\">Todo.bind('created', function(ev, created) {\n    // created is the created Todo\n});</code></pre>\n\n<h2>Model Lists</h2>\n\n<p>Model Lists (provided by <code>can.Model.List</code>) are Lists whose items are Models.\nWhen one of a Model List's elements are destroyed, that element is removed from\nthe list.</p>\n\n<pre><code class=\"lang-javascript\">Todo.findAll({}, function(todos) {\n    todos.length; // 5\n    todos[0].destroy(function() {\n        todos.length; // 4\n    }\n});</code></pre>",
                    "description": "",
                    "title": "Models",
                    "parent": "Tutorial",
                    "order": 2,
                    "comment": " ",
                    "src": "_guides/models.md",
                    "id": 5
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Observes",
                    "body": "<p>Observes made with can.Observe will let you set and remove properties like on\nnormal objects, but they also emit events when properties change that you can\nlisten to. Observes also make it easy to work with nested properties and get the\nevents you expect. Both [can.Route] and [Models] are based on can.Observe, but\nObserves are also useful on their own: for example, to maintain client-side\nstate like pagination data.</p>\n\n<p>To create an Observe, call <code>new can.Observe(obj)</code>. This will give you an Observe\nwith the same properties and values as <em>obj</em>. can.Observe also provides\n<a href=\"can.Observe.List\">observable arrays called Lists</a>. To create a List, call <code>new\ncan.Observe.List(array)</code>, which will give you a List with the same elements as\n<em>array</em>.</p>\n\n<pre><code class=\"lang-javascript\">var pagination = new can.Observe({page: 1, perPage: 25, count: 1388});\npagination.perPage; // 25\n\nvar hobbies = new can.Observe.List(['programming', 'basketball', 'partying']);\nhobbies[2]; // 'partying'</code></pre>\n\n<h2>Getting and setting properties</h2>\n\n<p>Though you can read properties from an Observe in the normal way, if you want to\nset the value of a property, you'll need to use <code>[attr]()</code>. There are a couple\nways to use attr to set a property, and it can also be used to get property\nvalues, or get a regular object back from an Observe:</p>\n\n<pre><code class=\"lang-javascript\">pagination.attr('perPage');     // 25\npagination.attr('perPage', 50);\npagination.perPage;             // 50\n\npagination.attr({page: 10, lastVisited: 1});\npagination.attr(); // {page: 10, perPage: 50, count: 1388, lastVisited: 1}</code></pre>\n\n<p>It might not make sense to get properties from an Observe using <code>attr</code> when you\ncan read them directly, but when reading properties for use in a template with\n[can.view Views] or when using a property in a Compute, using <code>attr</code> tells the\ntemplate or compute you want to watch that value in case it changes.</p>\n\n<p>Properties can be removed from Observes with <code>removeAttr</code>. This is the\nequivalent of the <code>delete</code> keyword:</p>\n\n<pre><code class=\"lang-javascript\">pagination.removeAttr('count');\npagination.attr(); // {page: 10, perPage: 50, lastVisited: 1}</code></pre>\n\n<h2>Listening to events</h2>\n\n<p>When a property on an Observe is changed with <code>attr</code>, the Observe will emit two\nevents: a <em>change</em> event and an event with the same name as the property that\nwas changed. You can listen for these events by using\n<code>[bind](can.Observe.bind)</code>:</p>\n\n<pre><code class=\"lang-javascript\">paginate.bind('change', function(event, attr, how, newVal, oldVal) {\n    attr;   // 'perPage'\n    how;    // 'set'\n    newVal; // 30\n    oldVal; // 50\n});\npaginate.bind('perPage', function(event, newVal, oldVal) {\n    newVal; // 30\n    oldVal; // 50\n});\n\npaginate.attr('perPage', 30);</code></pre>\n\n<p>You can similarly stop listening to these events by using <a href=\"can.Observe.unbind\">unbind</a>:</p>\n\n<pre><code class=\"lang-javascript\">var timesChanged = 0,\n    changeHandler = function() { timesChanged++; },\n    obs = new can.Observe({value: 10});\n\nobs.bind('change', changeHandler);\nobs.attr('value', 20);\ntimesChanged; // 1\n\nobs.unbind('change', changeHandler);\nobs.attr('value', 30);\ntimesChanged; // 1</code></pre>\n\n<h2>Iterating though an Observe</h2>\n\n<p>If you want to iterate through the properties on an Observe, use <code>each</code>:</p>\n\n<pre><code class=\"lang-javascript\">paginate.each(function(val, key) {\n    console.log(key + ': ' + val);\n});\n\n// The console shows:\n// page: 10\n// perPage: 30\n// lastVisited: 1</code></pre>\n\n<h2>Observable arrays</h2>\n\n<p>As mentioned above, CanJS also provides observable arrays with can.Observe.List.\ncan.Observe.List inherits from can.Observe, so a List works much the same way an\nObserve does, with the addition of several methods useful for working with\narrays:</p>\n\n<ul>\n<li><a href=\"can.Observe.List.prototype.indexOf\">indexOf</a>, which looks for an item in a\nList.</li>\n<li><a href=\"can.Observe.List.prototype.pop\">pop</a>, which removes the last item from a\nList.</li>\n<li><a href=\"can.Observe.List.prototype.push\">push</a>, which adds an item to the end of a\nList.</li>\n<li><a href=\"can.Observe.List.prototype.shift\">shift</a>, which removes the first item from\na List.</li>\n<li><a href=\"can.Observe.List.prototype.unshift\">unshift</a>, which adds an item to the front\nof a List.</li>\n<li><a href=\"can.Observe.List.prototype.splice\">splice</a>, which removes and inserts items\nanywhere in a List.</li>\n</ul>\n\n<p>When these methods are used to modify a List, the appropriate events are emitted. See <a href=\"can.Observe.List\">the API for Lists</a> for more information on the\narguments passed to those event handlers.</p>\n\n<h2>Observable values</h2>\n\n<p>CanJS also provides a way to make values themselves observable with\n<a href=\"can.compute\">can.compute</a>. A Compute represents a value that can be read, set,\nand listened to just like an Observe.</p>\n\n<h3>Static Computes</h3>\n\n<p>A simple Compute contains a single value, and is created by calling\n<code>can.compute(value)</code>. This value can be read, set, and listened to:</p>\n\n<pre><code class=\"lang-javascript\">// create a Compute\nvar age = can.compute(25),\n    previousAge = 0;\n\n// read the Compute's value\nage(); // 25\n\n// listen for changes in the Compute's value\nage.bind('change', function(ev, newVal, oldVal) {\n    previousAge = oldVal;\n});\n\n// set the Compute's value\nage(26);\n\nage();       // 26\npreviousAge; // 25</code></pre>\n\n<h3>Composite Computes</h3>\n\n<p>Computes can also get values derived from other observable values. This type of\nCompute is created by calling <code>can.compute(getterFunction)</code>. When the values\nthe Compute is derived from changes, the value of the Compute changes:</p>\n\n<pre><code class=\"lang-javascript\">var name = new can.Observe({\n    first: 'Alice',\n    last: 'Liddell'\n});\nvar fullName = can.compute(function() {\n    // We use attr to read the values so the compute knows what to listen to.\n    return name.attr('first') + ' ' + name.attr('last');\n});\nvar previousName = '';\n\nfullName();   // 'Alice Liddell'\n\nfullName.bind('change', function(ev, newVal, oldVal) {\n    previousName = oldVal;\n});\n\nname.attr({\n    first: 'Allison',\n    last: 'Wonderland'\n});\n\nfullname();   // 'Allison Wonderland'\npreviousName; // 'Alice Liddell'</code></pre>\n\n<p>Since the value of the Compute is cached any time a constituent value is\nchanged, reading the value is fast.</p>\n\n<h3>Converted Computes</h3>\n\n<p>Computes are useful for creating a link to a property in an Observe, and one of\nthe most frequent examples of this is when converting from one unit to another.</p>\n\n<pre><code class=\"lang-javascript\">// progress ranges from 0 to 1.\nvar project = new can.Observe({ progress: 0.3 });\nvar progressPercentage = can.compute(function(newVal) {\n    if(newVal !== undefined) {\n        // set a value\n        project.attr('progress', newVal / 100);\n    } else {\n        // get the value\n        return project.attr('progress') * 100;\n    }\n});\n\npercentage();     // 30\n\n// Setting percentage...\npercentage(75);\n// ...updates project.progress!\nproject.progress; // .75</code></pre>",
                    "description": "",
                    "title": "Observes",
                    "parent": "Tutorial",
                    "order": 1,
                    "comment": " ",
                    "src": "_guides/observes.md",
                    "id": 7
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Utilities",
                    "body": "<p>CanJS provides a plethora of utility methods. These methods are usually mapped\nto similar methods in the library that underlies CanJS, but for libraries that\ndo not have the given methods, CanJS provides them for you. This way, you can\ncreate plugins for CanJS that work no matter what library someone else is using.</p>\n\n<h2>String utilities</h2>\n\n<p><code>can.trim</code> removes leading and trailing whitespace.</p>\n\n<pre><code class=\"lang-javascript\">can.trim(' foo '); // 'foo'</code></pre>\n\n<p><code>can.esc</code> escapes HTML code.</p>\n\n<pre><code class=\"lang-javascript\">can.esc('&lt;foo>&lt;bar>'); // '&amp;lt;foo&amp;gt;&amp;&amp;lt;bar&amp;gt;'</code></pre>\n\n<p><code>can.getObject</code> looks up an object by path.</p>\n\n<pre><code class=\"lang-javascript\">can.('foo.bar', [{foo: {bar: 'baz'}}]); // 'baz'</code></pre>\n\n<p><code>can.capitalize</code> capitalizes a string.</p>\n\n<pre><code class=\"lang-javascript\">can.('fooBar'); // 'FooBar'</code></pre>\n\n<p><code>can.sub</code> allows micro-templating.</p>\n\n<pre><code class=\"lang-javascript\">can.sub('{greet}, world!', {greet: 'Hello'}); // 'Hello, world!'</code></pre>\n\n<p><code>can.deparam</code> transforms a form-encoded string into an object..</p>\n\n<pre><code class=\"lang-javascript\">can.deparam('foo=bar&hello=world'); // {foo: 'bar', hello: 'world'}</code></pre>\n\n<h2>Array utilities</h2>\n\n<p><code>can.makeArray</code> converts array-like objects into real Arrays.</p>\n\n<pre><code class=\"lang-javascript\">can.makeArray({0: 'foo', 1: 'bar', length: 2}); // ['foo', 'bar']</code></pre>\n\n<p><code>can.isArray</code> checks if an object is an Array.</p>\n\n<pre><code class=\"lang-javascript\">can.isArray([]); // true</code></pre>\n\n<p><code>can.map</code> converts an array into another array using a callback.</p>\n\n<pre><code class=\"lang-javascript\">can.map(['foo', 'bar'], function(element, index) {\n    return el.toUppercase();\n}); // ['FOO', 'BAR']</code></pre>\n\n<p><code>can.each</code> iterates through an array.</p>\n\n<pre><code class=\"lang-javascript\">can.each([{prop: 'foo'}, {prop: 'bar'}], function(element, index) {\n    // this callback will be called with:\n    // element = {prop: 'foo'}, index = 0\n    // element = {prop: 'bar'}, index = 1\n});</code></pre>\n\n<h2>Object utilites</h2>\n\n<p><code>can.extend</code> extends one object with the properties of another.</p>\n\n<pre><code class=\"lang-javascript\">var first  = {},\n    second = {a: 'b', c: 'd'},\n    third  = {c: 'e'};\n\nvar extended = can.extend(first, second, third);\nextended === first; // true\nfirst;  // {a: 'b', c: 'e'}\nsecond; // {a: 'b', c: 'd'}\nthird;  // {c: 'e'}</code></pre>\n\n<p><code>can.param</code> turns an object into a query string.</p>\n\n<pre><code class=\"lang-javascript\">can.param({a: 'b', c: 'd'}); // 'a=b&c=d'</code></pre>\n\n<p><code>can.isEmptyObject</code> checks whether an object is empty.</p>\n\n<pre><code class=\"lang-javascript\">can.isEmptyObject({});           // true\ncan.isEmptyObject({foo: 'bar'}); // false</code></pre>\n\n<h2>Function utilites</h2>\n\n<p><code>can.proxy</code> returns a function that calls another function with a set context.</p>\n\n<pre><code class=\"lang-javascript\">var f = can.proxy(function(str) {\n    return this.a + str;\n}, {a: 'b'});\nf('bar'); // 'bbar'</code></pre>\n\n<p><code>can.isFunction</code> checks whether an object is a function.</p>\n\n<pre><code class=\"lang-javascript\">can.isFunction({});             // false\ncan.isFunction(function() { }); // true</code></pre>\n\n<h2>Event utilities</h2>\n\n<p><code>can.bind</code> binds a callback to an event on an object.</p>\n\n<pre><code class=\"lang-javascript\">can.bind(obj, eventName, handler); // Binds handler on obj's eventName event.</code></pre>\n\n<p><code>can.unbind</code> unbinds a callback from an event on an object.</p>\n\n<pre><code class=\"lang-javascript\">can.unbind(obj, eventName, handler); // Unbinds handler from obj's eventName event.</code></pre>\n\n<p><code>can.delegate</code> binds a callback to an event on an all elements that match a selector.</p>\n\n<pre><code class=\"lang-javascript\">can.delegate(obj, eventName, handler); // Binds handler on eventName events from all elements under obj that match selector.</code></pre>\n\n<p><code>can.undelegate</code> unbinds a callback from an event on an all elements that\nmatch a selector.</p>\n\n<pre><code class=\"lang-javascript\">can.undelegate(obj, eventName, handler); // Unbinds handler from eventName events from all elements under obj that match selector.</code></pre>\n\n<p><code>can.trigger</code> triggers an event on an object.</p>\n\n<pre><code class=\"lang-javascript\">can.trigger(obj, eventName, args); // Executes all handlers attached to obj for eventName with args as additional arguments.</code></pre>\n\n<h2>AJAX utilites</h2>\n\n<p><code>can.ajax</code> will make an AJAX call and return a Deferred that resolves when the\ncall has returned.</p>\n\n<pre><code class=\"lang-javascript\">can.ajax({\n    url: '/path/to/url',\n    type: 'GET',\n    async: true,\n    dataType: 'json',\n    success: function(json) { },\n    error: function(xhr) { }\n});</code></pre>\n\n<h2>Element utilities</h2>\n\n<p><code>can.$</code> creates a library-wrapped NodeList.</p>\n\n<pre><code class=\"lang-javascript\">can.$(div.bar); // (in jQuery, a jQuery.fn object)</code></pre>\n\n<p><code>can.append</code> appends elements to the elements in a NodeList.</p>\n\n<pre><code class=\"lang-javascript\">can.append(nodelist, content); // Appends content to each element in nodelist.</code></pre>",
                    "description": "",
                    "title": "Utilities",
                    "parent": "Tutorial",
                    "order": 6,
                    "comment": " ",
                    "src": "_guides/util.md",
                    "id": 9
                }, {
                    "active": false,
                    "type": "page",
                    "name": "Views",
                    "body": "<p><code>[can.view](can.view)</code> loads and renders templates with the data you provide, and\nreturns a documentFragment with the populated template. can.view supports many\ntemplating languages, but <a href=\"can.EJS\">EJS</a> and <a href=\"can.Mustache\">Mustache</a> allow you\nto live-bind Observes into templates.</p>\n\n<h2>Loading templates</h2>\n\n<p>You can load templates from a URL or directly from an existent script tag. To\nload from a script tag, pass <code>can.view</code> the tag's ID as the first parameter. To\nload from a URL, pass the URL as the first parameter. Use the second parameter to\npass the data to populate the template with.</p>\n\n<p>In order to register a template with can.view, create a script tag on the page\nwith an ID, a <code>type</code> attribute that matches the templating language, and the\ncontent of the template inside:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/ejs\" id=\"todoList\">\n<% can.each(this, function(val, key) { %>\n    &lt;li><%= val.description %>&lt;/li>\n<% }); %>\n&lt;/script></code></pre>\n\n<p>Then load the template using the script tag's ID and pass the template data:</p>\n\n<pre><code class=\"lang-javascript\">Todo.findAll({}, function(todos) {\n    $('#nav').html(can.view('todoList', todos))\n});</code></pre>\n\n<p>Or you can load a template without registering it first (or including it on the\npage) by giving the URL to <code>can.view</code>:</p>\n\n<pre><code class=\"lang-javascript\">Todo.findAll({}, function(todos) {\n    $('#nav').html(can.view('todos/todos.ejs', todos))\n});</code></pre>\n\n<h2>Passing Deferreds</h2>\n\n<p>If the second parameter you pass to <code>can.view</code> contains Deferreds, can.view will\ninstead return a Deferred that resolves to the documentFragment containing the\npopulated template after all the deferreds have resolved.</p>\n\n<p>This aspect is most useful because <code>can.Model.findAll</code> returns a Deferred, which\nmeans it's easy to lead a template, retrieve one or more Models, and render the\nresulting documentFragment when everything has been loaded:</p>\n\n<pre><code class=\"lang-javascript\">can.view('todos.ejs', {\n    todos: Todo.findAll().\n    user: User.findOne({id: 5})\n}).then(function(fragment) {\n    document.getElementById('todos').appendChild(fragment);\n});</code></pre>\n\n<h2>Rendering to string</h2>\n\n<p>To render to a string instead of a documentFragment, use <code>can.view.render</code>. This\nis mainly used to include templates inside of other templates:</p>\n\n<pre><code class=\"lang-javascript\"><% can.each(todos, function(todo, key) { %>\n    &lt;li><%== can.view.render('todos.ejs', todo); %>&lt;/li>\n<% }) %></code></pre>",
                    "description": "",
                    "title": "Views",
                    "parent": "Tutorial",
                    "order": 3,
                    "comment": " ",
                    "src": "_guides/views.md",
                    "id": 10,
                    "children": [{
                            "active": false,
                            "type": "page",
                            "name": "EJS",
                            "body": "<p><a href=\"can.EJS\">EJS</a> is CanJS's default template language, which provides live\nbinding when used with Observes. EJS is very easy to use; you write the HTML you\nwant to be in the template, along with a few magic tags where you want dynamic\nbehavior.</p>\n\n<p>Here's an example of a template that might render a list of Todos:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/ejs\" id=\"todoList\">\n<% for(var i = 0; i < todos.length; ++i) { %>\n    &lt;li><%= this[i].description &lt;/li>\n<% } %>\n&lt;/script></code></pre>\n\n<p>And you can use <code>can.view</code> to render the template:</p>\n\n<pre><code class=\"lang-javascript\">Todo.findAll({}, function(todos) {\n    document.getElementById('list').appendChild(can.view('todoList', todos));\n});</code></pre>\n\n<p>As you can see from the template and the call to <code>can.view</code>, <code>todos</code> becomes\n<code>this</code> inside the template. EJS can also access the properties of the <code>this</code>\nobject without having to prefix it with <code>this.</code>:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/ejs\" id=\"todosAndUser\">\n&lt;h2> <%= user.name %>&lt;/h2>\n<% for(var i = 0; i < todos.length; ++i) { %>\n    &lt;li><%= this[i].description &lt;/li>\n<% } %>\n&lt;/script></code></pre>\n\n<p>Which can be inserted in the document with:</p>\n\n<pre><code class=\"lang-javascript\">can.view('todosAndUser', {\n    todos: Todo.findAll(),\n    user: User.findOne({id: 5})\n}).then(function(frag) {\n    document.getElementById('todos').appendChild(fragment);\n});</code></pre>\n\n<h2>Magic tags</h2>\n\n<p>There are five kinds of magic tags used in EJS:</p>\n\n<p><code>&lt;% %&gt;</code> will run any JavaScript code inside of it. This tag doesn't modify or\npopulate the template, but allows you to use for loops, if/else statements, \nswitch statements, and variable declarations inside the EJS template. Because\nalmost any JavaScript code is valid in <code>&lt;% %&gt;</code>, EJS is incredibly powerful.</p>\n\n<pre><code class=\"lang-javascript\"><% if(todos.attr('length') > 0) { %>\n    &lt;div>You have no to-dos.&lt;/div>\n<% } else { %>\n    &lt;ul>\n        <% todos.each(function(todo) { %>\n        &lt;li>todo.description&lt;/li>\n        <% }); %>\n    &lt;/ul>\n<% } %></code></pre>\n\n<p><code>&lt;%= %&gt;</code> will evaluate a JavaScript statement and write the HTML-escaped result\ninto the populated template. For example, an EJS template like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;div>My favorite element is <%= '&lt;b>blink&lt;/b>' %>.&lt;/div></code></pre>\n\n<p>will result in HTML like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;div>My favorite element is &amp;lt;b&amp;gt;blink&amp;lt;/b&amp;gt;.&lt;/div></code></pre>\n\n<p>This is almost always the tag you want to use when writing values to your\ntemplate, because it protects you against <a href=\"http://en.wikipedia.org/wiki/Cross-site_scripting\">cross-site scripting attacks</a>.</p>\n\n<p><code>&lt;%== %&gt;</code> will evaluate a JavaScript statement and write the raw result into the\npopulated template. This is like <code>&lt;%= %&gt;</code> but without escaping the result first.\nFor example, an EJS template like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;div>My favorite element is <%== '&lt;b>blink&lt;/b>' %>.&lt;/div></code></pre>\n\n<p>will result in HTML like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;div>My favorite element is &lt;b>blink&lt;/b>.&lt;/div></code></pre>\n\n<p>The most common use of <code>&lt;%== %&gt;</code> is to include templates in other templates:</p>\n\n<pre><code class=\"lang-javascript\"><% todos.each(function(todo) { %>\n    &lt;li><%== can.view.render('todoEJS', todo); %>&lt;/li>\n<% }); %></code></pre>\n\n<p>The other two magic tags are less commonly used and can be found in the\n<a href=\"can.EJS\">documentation for EJS</a>.</p>\n\n<h2>Live binding</h2>\n\n<p>You can make your EJS templates automatically update themselves when the data\nthey are populated with changes. To do this, populate your templates with\nObserves and use <code>attr</code> to read properties. In this template, using <code>attr</code> sets\nup live binding on the <code>description</code> property of <code>todo</code>:</p>\n\n<pre><code class=\"lang-javascript\">&lt;li><%= todo.attr('description') %>&lt;/li></code></pre>\n\n<p>If you change the Todo's description, the template's output will automatically\nupdate:</p>\n\n<pre><code class=\"lang-javascript\">todo.attr('description', 'Clean up the bathroom.');</code></pre>\n\n<p>Live binding works by wrapping the code inside the magic tags with a function\nto call when the attributes inside the magic tags change. This means that a\ntemplate like this will not work:</p>\n\n<pre><code class=\"lang-javascript\"><% for(var i = 0; i < todos.length; ++i) { %>\n    &lt;li><%= todos[i].attr('name') %>&lt;/li>\n<% } %></code></pre>\n\n<p>This will not work because when the function wrapping <code>todos[i].attr('name')</code> is\ncalled, <code>i</code> will still be <em>3</em> (as that is what <code>i</code> is set to after the loop is\nrun). You can fix this by using a closure and the <code>each</code> method of Observes:</p>\n\n<pre><code class=\"lang-javascript\"><% todos.each(function() { %>\n    &lt;li><%= todo.attr('name') %>&lt;/li>\n<% }); %></code></pre>\n\n<p><code>each</code> will also watch the length of the list it is passed, so elements are\nadded or removed from it, it will update the output of the template.</p>\n\n<h2>Element callbacks</h2>\n\n<p>If the code inside <code>&lt;%= %&gt;</code> or <code>&lt;%== %&gt;</code> evaluates to a function, the function\nwill be called back with the element it's inside as its first argument. This is\nuseful to initialize functionality on an element within the template, like\nstarting an element hidden:</p>\n\n<pre><code class=\"lang-javascript\">&lt;img src=\"surprise.gif\" <%= function(element) { element.style.display = 'none'; } %>/></code></pre>\n\n<p>This is so common that EJS also supports <a href=\"http://wiki.ecmascript.org/doku.php?id=strawman:arrow_function_syntax\">ECMAScript 5 arrow functions</a>\nthat get passed a library-wrapped NodeList containing the element. Because we\nare using jQuery, the example above can be more simply written like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;img src=\"surprise.gif\" <%= (el) -> el.hide() %>/></code></pre>\n\n<p>You can use this functionality to easily attach data to an element. A common\nreason to do this is to attach a Model to the element that represents it:</p>\n\n<pre><code class=\"lang-javascript\"><% todos.each(function(todo) { %>\n&lt;li <%= (el) -> can.data(el, 'todo', todo) %>>\n    <%= todo.attr('description') %>\n&lt;/li>\n<% }) %></code></pre>",
                            "description": "",
                            "title": "EJS",
                            "parent": "Views",
                            "comment": " ",
                            "src": "_guides/ejs.md",
                            "id": 3
                        }, {
                            "active": false,
                            "type": "page",
                            "name": "Mustache",
                            "body": "<p><a href=\"can.Mustache\">Mustache</a> provides logic-less templates that will live-bind to\nObserves. You can get Mustache functionality as a <a href=\"http://canjs.us/release/latest/can.view.mustache.js\">plugin</a>\nfor CanJS. Mustach and Handlebar templates are both compatible with CanJS's\nMustache implementation, so you can reuse any existing templates you have.</p>\n\n<p>Mustache is easy to get started with. Templates look like normal HTML, except\nthey contain special tags for inserting data into the template, iterating\nthrough lists, and filtering blocks.</p>\n\n<p>Here's an example of a template that might render a list of Todos:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/mustache\" id=\"todosList\">\n{{#todos}}\n&lt;li>{{description}}&lt;/li>\n{{/todos}}\n&lt;/script></code></pre>\n\n<p>And you can use <code>can.view</code> to render the template:</p>\n\n<pre><code class=\"lang-javascript\">Todo.findAll({}, function(todos) {\n    document.getElementById('list')\n        .appendChild(can.view('todoList', {todos: todos}));\n});</code></pre>\n\n<h2>Magic tags</h2>\n\n<p>There are three kinds of magic tags used in Mustache:</p>\n\n<ul>\n<li><code>{{ }}</code> will HTML-escape the value enclosed inside the tags and write it to\nthe template.</li>\n<li><code>{{{ }}}</code> will write the value enclosed inside the tags and write it directly\nto the template without escaping it.</li>\n<li><code>{{! }}</code> will write nothing to the template and is mostly used for comments.</li>\n</ul>\n\n<h3>Keys</h3>\n\n<p>Keys insert data into the template. They reference variables in the current\ncontext.</p>\n\n<p>This template:</p>\n\n<pre><code class=\"lang-javascript\">Name: {{name}}</code></pre>\n\n<p>given this data:</p>\n\n<pre><code class=\"lang-javascript\">{name: 'Alice'}</code></pre>\n\n<p>will render thusly:</p>\n\n<pre><code class=\"lang-javascript\">Name: Alice</code></pre>\n\n<h3>Sections</h3>\n\n<p>Sections contain text blocks and are conditionally rendered based on the value\nenclosed in the opening tag. They also change the context inside them to the\nkey referenced in the opening tag.</p>\n\n<p>For the following examples, we will assume the template is being populated with\nthis set of data:</p>\n\n<pre><code class=\"lang-javascript\">{\n    name: 'Alice Liddell',\n    nickname: '',\n    friends: ['Bob', 'Eve'],\n    enemies: []\n}</code></pre>\n\n<p>If the key is <code>undefined</code>, <code>null</code>, <code>false</code>, <code>''</code>, or <code>[]</code>, it is considered\na falsey value and the section is not rendered at all. Neither of these sections\nwill render:</p>\n\n<pre><code class=\"lang-javascript\">{{#enemies}}\n&lt;li>{{.}}&lt;/li>\n{{/enemies}}</code></pre>\n\n<pre><code class=\"lang-javascript\">{{#nickname}}{{.}}{{/nickname}}</code></pre>\n\n<p>If the key is a non-empty array, the section will be rendered once for each\nelement in the array. If it is truthy but not an array, the section is rendered\nonce.</p>\n\n<p>This template:</p>\n\n<pre><code class=\"lang-javascript\">&lt;h1>{{#name}}{{.}}{{/name}}&lt;/h1>\n&lt;ul>\n    {{#friends}}\n    &lt;li>{{.}}&lt;/li>\n    {{/friends}}\n&lt;/ul></code></pre>\n\n<p>will render like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;h1>Alice Liddell&lt;/h1>\n&lt;ul>\n    &lt;li>Bob&lt;/li>\n    &lt;li>Eve&lt;/li>\n&lt;/ul></code></pre>\n\n<p>You can also make inverted sections that render if the key referenced in the\nopening tag is falsey:</p>\n\n<pre><code class=\"lang-javascript\">&lt;ul>\n    {{#friends}}\n    &lt;li>{{.}}&lt;/li>\n    {{/friends}}\n    {{^friends}}\n    &lt;li>You have no friends.&lt;/li>\n    {{/friends}}\n&lt;/ul></code></pre>\n\n<h3>Context</h3>\n\n<p>When Mustache is resolving an object in a section, it sets the current context\nto the object value for which it is iterating. (If the key in the opening tag\nof a section was not an array, it sets the context to the value of that key.)\nYou can reference the current context as <code>.</code>.</p>\n\n<p>Internally, Mustache keeps a stack of contexts as the template enters nested\nsections and helpers. If a key is not found in the current context, Mustache\nwill look for the the in each successive parent context until it resolves the\nkey or runs out of parent contexts.</p>\n\n<p>For example, with this data:</p>\n\n<pre><code class=\"lang-javascript\">{\n    brothers: [{name: 'Bob'}, {name: 'David'}],\n    sisters: [{name: 'Alice'}, {name: 'Eve'}]\n}</code></pre>\n\n<p>and this template:</p>\n\n<pre><code class=\"lang-javascript\">{{#brothers}}\n    {{#sisters}}\n        {{name}}\n    {{/sisters}}\n{{/brothers}}</code></pre>\n\n<p>the rendered result will be:</p>\n\n<pre><code class=\"lang-javascript\">Alice\nEve\nAlice\nEve</code></pre>\n\n<p>Since there is no <code>sisters</code> key in the context of the elements of the <code>brothers</code>\narray, Mustache jumps up to the parent context and resolves <code>sisters</code> there.</p>\n\n<h2>Helpers</h2>\n\n<p>Mustache lets you register functions to be called from inside the template called\nhelpers. Since Mustache template are logic-less, all your view logic will be\ninside helpers.</p>\n\n<p>To use a helper that is local to the template you're rendering, pass it as the\nthird argument to <code>can.view</code> in an object where the key is the name of the helper\nand the value is the helper function:</p>\n\n<pre><code class=\"lang-javascript\">var fragment = can.view('todosList', {todos: todos}, {\n    uppercase: function(str) {\n        return str.toUppercase();\n    }\n});</code></pre>\n\n<p>This might be used in a template like this:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/mustache\" id=\"todosList\">\n{{#todos}}\n&lt;li>{{uppercase description}}&lt;/li>\n{{/todos}}\n&lt;/script></code></pre>\n\n<p>If a property of an observe is passed to a helper function, the helper will\nbecome a <code>[can.compute](can.compute)</code>. As an example, if you had this template:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/mustache\" id=\"prefixedName\">\n&lt;div>{{addMs lastName}}&lt;/div>\n&lt;/script></code></pre>\n\n<p>And you ran this code:</p>\n\n<pre><code class=\"lang-javascript\">var name = new can.Observe({firstName: 'Alice', lastName: 'Liddell'});\ndocument.getElementById('name')\n    .appendChild(can.view('prefixedName', name, {\n        addMs: function(lastName) {\n            return 'Ms. ' + lastName;\n        }\n    }));\nname.attr({firstName: 'Allison', lastName: 'Wonderland'});</code></pre>\n\n<p>The contents of the &lt;div> would be <code>Ms. Wonderland</code>.</p>\n\n<h3>Global helpers</h3>\n\n<p>You can register global helpers using <code>can.Mustache.registerHelper</code>:</p>\n\n<pre><code class=\"lang-javascript\">can.Mustache.registerHelper('i10n', function(str, options) {\n    return (Globalize != undefined ? Globalize.localize(str) : str);\n});</code></pre>\n\n<h3>Data helpers</h3>\n\n<p>You can use the <code>data</code> helper in Mustache to associate data to an element. This\nhelper will associate the current context (<code>.</code>) with a key you pass to the\nhelper.</p>\n\n<p>For example, this template:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/mustache\" id=\"nameDiv\">\n&lt;div id=\"person\" {{data 'name'}}>{{firstName}} {{lastName}}&lt;/div>\n&lt;/script></code></pre>\n\n<p>lets you do this in code:</p>\n\n<pre><code class=\"lang-javascript\">document.body.appendChild(can.view('nameDiv', {\n    firstName: 'Alice',\n    lastName: 'Liddell'\n}));\n\nvar obj = can.data(document.getElementById('person'), 'name');\nobj; // { firstName: 'Alice', lastName: 'Liddell'}</code></pre>\n\n<h2>Partials</h2>\n\n<p>You can embed templates in other templates by using partials. Partials inherit\nthe context where they are called. They are evaluated at render time, so you\nshould be careful to avoid infinite loops. To include a partial, put its URL or\nID inside <code>{{&gt; }}</code>.</p>\n\n<p>With these templates:</p>\n\n<pre><code class=\"lang-javascript\">&lt;script type=\"text/mustache\" id=\"names\">\n&lt;ul>\n{{#names}}\n    {{>user}}\n{{/names}}\n&lt;/ul>\n&lt;/script>\n&lt;script type=\"text/mustache\" id=\"user\">\n&lt;li>{{firstName}} {{lastName}}&lt;/li>\n&lt;/script></code></pre>\n\n<p>the expanded template at render time would look similar to:</p>\n\n<pre><code class=\"lang-javascript\">&lt;ul>\n{{#names}}\n    &lt;li>{{firstName}} {{lastName}}&lt;/li>\n{{/names}}\n&lt;/ul></code></pre>",
                            "description": "",
                            "title": "Mustache",
                            "parent": "Views",
                            "comment": " ",
                            "src": "_guides/mustache.md",
                            "id": 6
                        }
                    ]
                }
            ]
        }
    ]
}